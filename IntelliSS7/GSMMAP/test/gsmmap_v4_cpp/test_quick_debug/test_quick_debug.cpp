////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//      Copyright 2000 IntelliNet Technologies, Inc. All Rights Reserved.     //
//              Manufactured in the United States of America.                 //
//        1990 W. New Haven Ste. 312, Melbourne, Florida, 32904 U.S.A.        //
//                                                                            //
//    This product and related documentation is protected by copyright and    //
//    distributed under licenses restricting its use, copying, distribution   //
//    and decompilation.  No part of this product or related documentation    //
//    may be reproduced in any form by any means without prior written        //
//    authorization of IntelliNet Technologies and its licensors, if any.     //
//                                                                            //
//    RESTRICTED RIGHTS LEGEND:  Use, duplication, or disclosure by the       //
//    government is subject to restrictions as set forth in subparagraph      //
//    (c)(1)(ii) of the Rights in Technical Data and Computer Software        //
//    clause at DFARS 252.227-7013 and FAR 52.227-19.                         //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// CONTRACT: INTERNAL                                                         //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////
//
//  ID: $Id: test_quick_debug.cpp,v 9.1 2005/03/23 12:51:36 cvsadmin Exp $
//
////////////////////////////////////////////////////////////////////////////////

//
//  MAP V4 ASN.1 codec quick debug example.
//
//  This example allows to quickly debug the decoding of a MAP V4 ASN.1 encoded
//  value using the MAP V4 C++ codec. Can be extended to other MAP versions.
//
// 

//
//  C++ related note:
//  
//  The code relies on STL (C++ Standard Template Library). A basic knowledge
//  of STL is assumed (mainly classes std::vector and std::list). Likewise, a 
//  basic knowledge of C++ standard classes (e.g. std::string, std::ostream...) 
//  is also assumed. 
// 


#include <iostream>

#include <its++.h>
#include <its_ss7_stubs.h>

#include <Asn.h>
#include <AsnException.h>

#include <map_cpp.h>
#include <map_v4_insert_subscriber_data_arg.h>


#if defined(ITS_STD_NAMESPACE)
using namespace std;
#endif // defined(ITS_STD_NAMESPACE)

#if defined(ITS_NAMESPACE)
using namespace its;
using namespace map_common;
using namespace map_v4;
#endif // defined(ITS_NAMESPACE)


////////////////////////////////////////////////////////////////////////////////
//
//  Utilities.
//

//
//  Macro to get the size (count of items) of a fixed array.
//
#define FixedArraySize(array)       \
    (sizeof(array) / sizeof(array[0]))

//
//  Macro to convert fixed arrays (of bytes) to vectors.
//
#define FixedByteArrayToVector(array)   \
    (vector<byte>(array, array + FixedArraySize(array)))



////////////////////////////////////////////////////////////////////////////////
//
//  MAP encoded values.
//

byte mapV4_InsertSubscriberDataArgValue1[] = { 
    
    0x11U, 0x12U, 0x13U, 0x14U, 0x15U

};

byte mapV4_InsertSubscriberDataArgValue2[] = {


    0x30U, 0x6FU, 0x80U, 0x04U, 0x01U, 0x02U, 0x03U, 0x04U, 0x81U, 0x05U,
    0x11U, 0x22U, 0x33U, 0x44U, 0x55U, 0x82U, 0x01U, 0x66U, 0x83U, 0x01U,
    0x00U, 0xA4U, 0x06U, 0x04U, 0x01U, 0xAAU, 0x04U, 0x01U, 0xBBU, 0xA6U,
    0x09U, 0x04U, 0x01U, 0xCCU, 0x04U, 0x01U, 0xDDU, 0x04U, 0x01U, 0xEEU,
    0xA7U, 0x3DU, 0xA0U, 0x14U, 0x04U, 0x01U, 0x33U, 0x30U, 0x0FU, 0x30U,
    0x0DU, 0x82U, 0x01U, 0x44U, 0x88U, 0x08U, 0x01U, 0x02U, 0x03U, 0x04U,
    0x05U, 0x06U, 0x07U, 0x08U, 0xA2U, 0x20U, 0x30U, 0x1EU, 0x30U, 0x0DU,
    0x02U, 0x02U, 0x07U, 0xCFU, 0x04U, 0x04U, 0x11U, 0x22U, 0x33U, 0x44U,
    0x0AU, 0x01U, 0x00U, 0x30U, 0x0DU, 0x02U, 0x02U, 0x07U, 0xD1U, 0x04U,
    0x04U, 0x44U, 0x33U, 0x22U, 0x11U, 0x0AU, 0x01U, 0x00U, 0xA3U, 0x03U,
    0x82U, 0x01U, 0x01U, 0xA8U, 0x08U, 0x03U, 0x02U, 0x02U, 0xA8U, 0x03U,
    0x02U, 0x04U, 0x50U

};

byte mapV4_InsertSubscriberDataArgValue3[] = {

    0x30U, 0x82U, 0x03U, 0xA0U, 0x80U, 0x08U, 0x11U, 0x22U, 0x33U, 0x44U,
    0x55U, 0x66U, 0x77U, 0x88U, 0x81U, 0x09U, 0x11U, 0x22U, 0x33U, 0x44U,
    0x55U, 0x66U, 0x77U, 0x88U, 0x99U, 0x82U, 0x01U, 0x11U, 0x83U, 0x01U,
    0x01U, 0xA4U, 0x81U, 0x96U, 0x04U, 0x01U, 0x11U, 0x04U, 0x01U, 0x11U,
    0x04U, 0x01U, 0x11U, 0x04U, 0x01U, 0x11U, 0x04U, 0x01U, 0x11U, 0x04U,
    0x01U, 0x11U, 0x04U, 0x01U, 0x11U, 0x04U, 0x01U, 0x11U, 0x04U, 0x01U,
    0x11U, 0x04U, 0x01U, 0x11U, 0x04U, 0x01U, 0x11U, 0x04U, 0x01U, 0x11U,
    0x04U, 0x01U, 0x11U, 0x04U, 0x01U, 0x11U, 0x04U, 0x01U, 0x11U, 0x04U,
    0x01U, 0x11U, 0x04U, 0x01U, 0x11U, 0x04U, 0x01U, 0x11U, 0x04U, 0x01U,
    0x11U, 0x04U, 0x01U, 0x11U, 0x04U, 0x01U, 0x11U, 0x04U, 0x01U, 0x11U,
    0x04U, 0x01U, 0x11U, 0x04U, 0x01U, 0x11U, 0x04U, 0x01U, 0x11U, 0x04U,
    0x01U, 0x11U, 0x04U, 0x01U, 0x11U, 0x04U, 0x01U, 0x11U, 0x04U, 0x01U,
    0x11U, 0x04U, 0x01U, 0x11U, 0x04U, 0x01U, 0x11U, 0x04U, 0x01U, 0x11U,
    0x04U, 0x01U, 0x11U, 0x04U, 0x01U, 0x11U, 0x04U, 0x01U, 0x11U, 0x04U,
    0x01U, 0x11U, 0x04U, 0x01U, 0x11U, 0x04U, 0x01U, 0x11U, 0x04U, 0x01U,
    0x11U, 0x04U, 0x01U, 0x11U, 0x04U, 0x01U, 0x11U, 0x04U, 0x01U, 0x11U,
    0x04U, 0x01U, 0x11U, 0x04U, 0x01U, 0x11U, 0x04U, 0x01U, 0x11U, 0x04U,
    0x01U, 0x11U, 0x04U, 0x01U, 0x11U, 0x04U, 0x01U, 0x11U, 0x04U, 0x01U,
    0x11U, 0x04U, 0x01U, 0x11U, 0xA6U, 0x3CU, 0x04U, 0x01U, 0x11U, 0x04U,
    0x01U, 0x11U, 0x04U, 0x01U, 0x11U, 0x04U, 0x01U, 0x11U, 0x04U, 0x01U,
    0x11U, 0x04U, 0x01U, 0x11U, 0x04U, 0x01U, 0x11U, 0x04U, 0x01U, 0x11U,
    0x04U, 0x01U, 0x11U, 0x04U, 0x01U, 0x11U, 0x04U, 0x01U, 0x11U, 0x04U,
    0x01U, 0x11U, 0x04U, 0x01U, 0x11U, 0x04U, 0x01U, 0x11U, 0x04U, 0x01U,
    0x11U, 0x04U, 0x01U, 0x11U, 0x04U, 0x01U, 0x11U, 0x04U, 0x01U, 0x11U,
    0x04U, 0x01U, 0x11U, 0x04U, 0x01U, 0x11U, 0xA7U, 0x82U, 0x02U, 0x6EU,
    0xA0U, 0x65U, 0x04U, 0x01U, 0x11U, 0x30U, 0x60U, 0x30U, 0x2EU, 0x82U,
    0x01U, 0x11U, 0x84U, 0x01U, 0x11U, 0x85U, 0x09U, 0x11U, 0x22U, 0x33U,
    0x44U, 0x55U, 0x66U, 0x77U, 0x88U, 0x99U, 0x88U, 0x15U, 0x11U, 0x22U,
    0x33U, 0x44U, 0x55U, 0x66U, 0x77U, 0x88U, 0x99U, 0x00U, 0x11U, 0x22U,
    0x33U, 0x44U, 0x55U, 0x66U, 0x77U, 0x88U, 0x99U, 0x00U, 0x11U, 0x86U,
    0x01U, 0x11U, 0x87U, 0x01U, 0x1EU, 0x30U, 0x2EU, 0x83U, 0x01U, 0x11U,
    0x84U, 0x01U, 0x22U, 0x85U, 0x09U, 0x11U, 0x22U, 0x33U, 0x44U, 0x55U,
    0x66U, 0x77U, 0x88U, 0x99U, 0x88U, 0x15U, 0x11U, 0x22U, 0x33U, 0x44U,
    0x55U, 0x66U, 0x77U, 0x88U, 0x99U, 0x00U, 0x11U, 0x22U, 0x33U, 0x44U,
    0x55U, 0x66U, 0x77U, 0x88U, 0x99U, 0x00U, 0x11U, 0x86U, 0x01U, 0x22U,
    0x87U, 0x01U, 0x1EU, 0xA1U, 0x6DU, 0x04U, 0x01U, 0x11U, 0x30U, 0x68U,
    0x30U, 0x06U, 0x82U, 0x01U, 0x11U, 0x84U, 0x01U, 0x11U, 0x30U, 0x06U,
    0x83U, 0x01U, 0x11U, 0x84U, 0x01U, 0x22U, 0x30U, 0x06U, 0x82U, 0x01U,
    0x11U, 0x84U, 0x01U, 0x11U, 0x30U, 0x06U, 0x83U, 0x01U, 0x11U, 0x84U,
    0x01U, 0x22U, 0x30U, 0x06U, 0x82U, 0x01U, 0x11U, 0x84U, 0x01U, 0x11U,
    0x30U, 0x06U, 0x83U, 0x01U, 0x11U, 0x84U, 0x01U, 0x22U, 0x30U, 0x06U,
    0x82U, 0x01U, 0x11U, 0x84U, 0x01U, 0x11U, 0x30U, 0x06U, 0x83U, 0x01U,
    0x11U, 0x84U, 0x01U, 0x22U, 0x30U, 0x06U, 0x82U, 0x01U, 0x11U, 0x84U,
    0x01U, 0x11U, 0x30U, 0x06U, 0x83U, 0x01U, 0x11U, 0x84U, 0x01U, 0x22U,
    0x30U, 0x06U, 0x82U, 0x01U, 0x11U, 0x84U, 0x01U, 0x11U, 0x30U, 0x06U,
    0x83U, 0x01U, 0x11U, 0x84U, 0x01U, 0x22U, 0x30U, 0x06U, 0x83U, 0x01U,
    0x11U, 0x84U, 0x01U, 0x22U, 0xA2U, 0x82U, 0x01U, 0x81U, 0x30U, 0x81U,
    0xE6U, 0x30U, 0x15U, 0x02U, 0x02U, 0x7FU, 0xFFU, 0x04U, 0x04U, 0x11U,
    0x22U, 0x33U, 0x44U, 0x0AU, 0x01U, 0x02U, 0x30U, 0x06U, 0x82U, 0x01U,
    0x11U, 0x83U, 0x01U, 0x22U, 0x30U, 0x15U, 0x02U, 0x02U, 0x7FU, 0xFFU,
    0x04U, 0x04U, 0x11U, 0x22U, 0x33U, 0x44U, 0x0AU, 0x01U, 0x02U, 0x30U,
    0x06U, 0x82U, 0x01U, 0x11U, 0x83U, 0x01U, 0x22U, 0x30U, 0x15U, 0x02U,
    0x02U, 0x7FU, 0xFFU, 0x04U, 0x04U, 0x11U, 0x22U, 0x33U, 0x44U, 0x0AU,
    0x01U, 0x02U, 0x30U, 0x06U, 0x82U, 0x01U, 0x11U, 0x83U, 0x01U, 0x22U,
    0x30U, 0x15U, 0x02U, 0x02U, 0x7FU, 0xFFU, 0x04U, 0x04U, 0x11U, 0x22U,
    0x33U, 0x44U, 0x0AU, 0x01U, 0x02U, 0x30U, 0x06U, 0x82U, 0x01U, 0x11U,
    0x83U, 0x01U, 0x22U, 0x30U, 0x15U, 0x02U, 0x02U, 0x7FU, 0xFFU, 0x04U,
    0x04U, 0x11U, 0x22U, 0x33U, 0x44U, 0x0AU, 0x01U, 0x02U, 0x30U, 0x06U,
    0x82U, 0x01U, 0x11U, 0x83U, 0x01U, 0x22U, 0x30U, 0x15U, 0x02U, 0x02U,
    0x7FU, 0xFFU, 0x04U, 0x04U, 0x11U, 0x22U, 0x33U, 0x44U, 0x0AU, 0x01U,
    0x02U, 0x30U, 0x06U, 0x82U, 0x01U, 0x11U, 0x83U, 0x01U, 0x22U, 0x30U,
    0x15U, 0x02U, 0x02U, 0x7FU, 0xFFU, 0x04U, 0x04U, 0x11U, 0x22U, 0x33U,
    0x44U, 0x0AU, 0x01U, 0x02U, 0x30U, 0x06U, 0x82U, 0x01U, 0x11U, 0x83U,
    0x01U, 0x22U, 0x30U, 0x15U, 0x02U, 0x02U, 0x7FU, 0xFFU, 0x04U, 0x04U,
    0x11U, 0x22U, 0x33U, 0x44U, 0x0AU, 0x01U, 0x02U, 0x30U, 0x06U, 0x82U,
    0x01U, 0x11U, 0x83U, 0x01U, 0x22U, 0x30U, 0x15U, 0x02U, 0x02U, 0x7FU,
    0xFFU, 0x04U, 0x04U, 0x11U, 0x22U, 0x33U, 0x44U, 0x0AU, 0x01U, 0x02U,
    0x30U, 0x06U, 0x82U, 0x01U, 0x11U, 0x83U, 0x01U, 0x22U, 0x30U, 0x15U,
    0x02U, 0x02U, 0x7FU, 0xFFU, 0x04U, 0x04U, 0x11U, 0x22U, 0x33U, 0x44U,
    0x0AU, 0x01U, 0x02U, 0x30U, 0x06U, 0x82U, 0x01U, 0x11U, 0x83U, 0x01U,
    0x22U, 0x30U, 0x81U, 0x95U, 0x30U, 0x0AU, 0x82U, 0x01U, 0x11U, 0x02U,
    0x02U, 0x7FU, 0xFFU, 0x04U, 0x01U, 0x11U, 0x30U, 0x09U, 0x83U, 0x01U,
    0x22U, 0x02U, 0x01U, 0x00U, 0x04U, 0x01U, 0x22U, 0x30U, 0x0AU, 0x82U,
    0x01U, 0x11U, 0x02U, 0x02U, 0x7FU, 0xFFU, 0x04U, 0x01U, 0x11U, 0x30U,
    0x09U, 0x83U, 0x01U, 0x22U, 0x02U, 0x01U, 0x00U, 0x04U, 0x01U, 0x22U,
    0x30U, 0x0AU, 0x82U, 0x01U, 0x11U, 0x02U, 0x02U, 0x7FU, 0xFFU, 0x04U,
    0x01U, 0x11U, 0x30U, 0x09U, 0x83U, 0x01U, 0x22U, 0x02U, 0x01U, 0x00U,
    0x04U, 0x01U, 0x22U, 0x30U, 0x0AU, 0x82U, 0x01U, 0x11U, 0x02U, 0x02U,
    0x7FU, 0xFFU, 0x04U, 0x01U, 0x11U, 0x30U, 0x09U, 0x83U, 0x01U, 0x22U,
    0x02U, 0x01U, 0x00U, 0x04U, 0x01U, 0x22U, 0x30U, 0x0AU, 0x82U, 0x01U,
    0x11U, 0x02U, 0x02U, 0x7FU, 0xFFU, 0x04U, 0x01U, 0x11U, 0x30U, 0x09U,
    0x83U, 0x01U, 0x22U, 0x02U, 0x01U, 0x00U, 0x04U, 0x01U, 0x22U, 0x30U,
    0x0AU, 0x82U, 0x01U, 0x11U, 0x02U, 0x02U, 0x7FU, 0xFFU, 0x04U, 0x01U,
    0x11U, 0x30U, 0x09U, 0x83U, 0x01U, 0x22U, 0x02U, 0x01U, 0x00U, 0x04U,
    0x01U, 0x22U, 0x30U, 0x09U, 0x83U, 0x01U, 0x22U, 0x02U, 0x01U, 0x00U,
    0x04U, 0x01U, 0x22U, 0xA3U, 0x11U, 0x04U, 0x01U, 0x11U, 0x84U, 0x01U,
    0x11U, 0x82U, 0x01U, 0x02U, 0x30U, 0x06U, 0x82U, 0x01U, 0x11U, 0x83U,
    0x01U, 0x22U, 0xA8U, 0x0EU, 0x03U, 0x05U, 0x00U, 0x04U, 0x00U, 0x00U,
    0x00U, 0x03U, 0x05U, 0x00U, 0x10U, 0x00U, 0x00U, 0x00U, 0x89U, 0x00U,
    0xAAU, 0x28U, 0x04U, 0x02U, 0x11U, 0x22U, 0x04U, 0x02U, 0x11U, 0x22U,
    0x04U, 0x02U, 0x11U, 0x22U, 0x04U, 0x02U, 0x11U, 0x22U, 0x04U, 0x02U,
    0x11U, 0x22U, 0x04U, 0x02U, 0x11U, 0x22U, 0x04U, 0x02U, 0x11U, 0x22U,
    0x04U, 0x02U, 0x11U, 0x22U, 0x04U, 0x02U, 0x11U, 0x22U, 0x04U, 0x02U,
    0x11U, 0x22U

};


//
//  To be completed (add more encoded values).
//




////////////////////////////////////////////////////////////////////////////////
//
//  MAP test decode functions.
//


void
MapV4_TestDecodeInsertSubscriberDataArg(
                    const vector<byte>& encodedInsertSubscriberDataArg)
{
    //  [1] Create an Octets object from the InsertSubscriberDataArg ASN.1 
    //  encoded value.

    Octets* octets = new Octets(encodedInsertSubscriberDataArg);

    ////////////////////////////////////////////////////////////////////////////

    //  [2] Create InsertSubscriberDataArg object (used by the decode phase).

    InsertSubscriberDataArg* 
        insertSubscriberDataArg = new 
            InsertSubscriberDataArg();

    ////////////////////////////////////////////////////////////////////////////

    //  [3] Decode the InsertSubscriberDataArg ASN.1 encoded value and therefore
    //  populate previously created InsertSubscriberDataArg object.

    try
    {
        //  Can throw and AsnDecodeError exception.

        insertSubscriberDataArg->Decode(*octets);
    }
    catch (AsnDecodeError& decodeError)
    {
        cout << endl << decodeError.GetDescription() << endl;
    }

    cout << endl;
    cout << "Printing decoded InsertSubscriberDataArg object..." << endl;
    cout << *insertSubscriberDataArg;
    cout << endl;

    

    //  [4] Free all memory allocated on the heap.

    //  [4-1] Delete Octets object.

    delete octets;

    //  [4-2] Delete InsertSubscriberDataArg object.

    delete insertSubscriberDataArg;
}


//
//  To be completed (add more decode functions).
//





////////////////////////////////////////////////////////////////////////////////
//
//  Entry point:
//
//  o   Initialize IntelliSS7.
//
//  o   Call test decode function(s).
//  
//  o   Terminate IntelliSS7.
// 

int main(int argc, char* argv[])
{
    cout << endl << "Begin MAP Quick Debug ASN.1 codec example..." << endl;

    try
    {
        // IntelliSS7 initialization (including licensing).

        int res = ITS_GlobalStart(0);

        if (res != ITS_SUCCESS)
        {
            throw ITS_Error(res, __FILE__, __LINE__);
        }

        ////////////////////////////////////////////////////////////////////////

        //  Call test decode function(s) with specific ASN.1 encoded values.


        // Should fail.

        MapV4_TestDecodeInsertSubscriberDataArg(
            FixedByteArrayToVector(
                mapV4_InsertSubscriberDataArgValue1));


        // Should fail.

        MapV4_TestDecodeInsertSubscriberDataArg(
            FixedByteArrayToVector(
                mapV4_InsertSubscriberDataArgValue2));


        // Should succeed.

        MapV4_TestDecodeInsertSubscriberDataArg(
            FixedByteArrayToVector(
                mapV4_InsertSubscriberDataArgValue3));


        ////////////////////////////////////////////////////////////////////////

        // IntelliSS7 termination.

        ITS_GlobalStop();
    }
    catch (ITS_GenericException& exp)
    {
        cout << endl << exp.GetDescription() << endl;

        ITS_GlobalStop();
    }

    cout << endl << "End of MAP Quick Debug ASN.1 codec example." << endl;
    

    // To stop here in console application.

    cout << endl << "Press Enter to quit...";

    char c = '\0';
    cin.get(c);

    return EXIT_SUCCESS;
}

