//
// Generated by IntelliAsnCC ASN.1 compiler (C, C++, Java).
//
// Do not edit!
//
//
//
// (C) 2000, 2001 IntelliNet Technologies Inc. All Rights Reserved.
//
//


#include <map_v13_insert_subscriber_data_arg.h>

#include <AsnDescSequence.h>
#include <AsnDescNull.h>
#include <AsnDescBoolean.h>
#include <AsnDescOctetString.h>
#include <AsnDescEnumerated.h>
#include <AsnDescSequenceOf.h>
#include <AsnDescInteger.h>
#include <AsnDescBitString.h>


using namespace its;
using namespace map_v13;




////////// Begin Nested Class(es) //////////


// Type IMSI is a reference => no code generated.

// Type ISDN_AddressString is a reference => no code generated.

// Type Category is a reference => no code generated.

// Type SubscriberStatus is a reference => no code generated.

// Type BearerServiceList is a reference => no code generated.

// Type TeleserviceList is a reference => no code generated.

// Type Ext_SS_InfoList is a reference => no code generated.

// Type ODB_Data is a reference => no code generated.


AsnDescObject* InsertSubscriberDataArg::RoamingRestrictionDueToUnsupportedFeature::GetStaticDescription()
{
    static volatile bool initialized = false;
    static AsnDescObject* result = NULL;
    static AsnDescNull staticDesc;

    if (initialized)
    {
        return result;
    }

    Asn::Lock();

    if (initialized)
    {
        Asn::Unlock();
        return result;
    }
    else
    {
        staticDesc.SetCloneForFactory(new RoamingRestrictionDueToUnsupportedFeature(&staticDesc));
        staticDesc.TagAddLevel(new Tag(Tag::ASN_CLASS_CONTEXT_SPECIFIC, Tag::ASN_PRIMITIVE, 9));
        staticDesc._clauseOptional = true;
        staticDesc.SetNamedTypeName("roamingRestrictionDueToUnsupportedFeature");
        result = &staticDesc;
        initialized = true;
        Asn::Unlock();
        return result;
    }
}


// Type ZoneCodeList is a reference => no code generated.

// Type VBSDataList is a reference => no code generated.

// Type VGCSDataList is a reference => no code generated.

// Type VlrCamelSubscriptionInfo is a reference => no code generated.

// Type ExtensionContainer is a reference => no code generated.

// Type NAEA_PreferredCI is a reference => no code generated.

// Type GPRSSubscriptionData is a reference => no code generated.


AsnDescObject* InsertSubscriberDataArg::RoamingRestrictedInSgsnDueToUnsupportedFeature::GetStaticDescription()
{
    static volatile bool initialized = false;
    static AsnDescObject* result = NULL;
    static AsnDescNull staticDesc;

    if (initialized)
    {
        return result;
    }

    Asn::Lock();

    if (initialized)
    {
        Asn::Unlock();
        return result;
    }
    else
    {
        staticDesc.SetCloneForFactory(new RoamingRestrictedInSgsnDueToUnsupportedFeature(&staticDesc));
        staticDesc.TagAddLevel(new Tag(Tag::ASN_CLASS_CONTEXT_SPECIFIC, Tag::ASN_PRIMITIVE, 23));
        staticDesc._clauseOptional = true;
        staticDesc.SetNamedTypeName("roamingRestrictedInSgsnDueToUnsupportedFeature");
        result = &staticDesc;
        initialized = true;
        Asn::Unlock();
        return result;
    }
}


// Type NetworkAccessMode is a reference => no code generated.

// Type LSAInformation is a reference => no code generated.


AsnDescObject* InsertSubscriberDataArg::Lmu_Indicator::GetStaticDescription()
{
    static volatile bool initialized = false;
    static AsnDescObject* result = NULL;
    static AsnDescNull staticDesc;

    if (initialized)
    {
        return result;
    }

    Asn::Lock();

    if (initialized)
    {
        Asn::Unlock();
        return result;
    }
    else
    {
        staticDesc.SetCloneForFactory(new Lmu_Indicator(&staticDesc));
        staticDesc.TagAddLevel(new Tag(Tag::ASN_CLASS_CONTEXT_SPECIFIC, Tag::ASN_PRIMITIVE, 21));
        staticDesc._clauseOptional = true;
        staticDesc.SetNamedTypeName("lmu-Indicator");
        result = &staticDesc;
        initialized = true;
        Asn::Unlock();
        return result;
    }
}


// Type LCSInformation is a reference => no code generated.

// Type IST_AlertTimerValue is a reference => no code generated.

// Type AgeIndicator is a reference => no code generated.

// Type MC_SS_Info is a reference => no code generated.

// Type CS_AllocationRetentionPriority is a reference => no code generated.

// Type SGSN_CAMEL_SubscriptionInfo is a reference => no code generated.

// Type ChargingCharacteristics is a reference => no code generated.

// Type AccessRestrictionData is a reference => no code generated.


AsnDescObject* InsertSubscriberDataArg::Ics_Indicator::GetStaticDescription()
{
    static volatile bool initialized = false;
    static AsnDescObject* result = NULL;
    static AsnDescBoolean staticDesc;

    if (initialized)
    {
        return result;
    }

    Asn::Lock();

    if (initialized)
    {
        Asn::Unlock();
        return result;
    }
    else
    {
        staticDesc.SetCloneForFactory(new Ics_Indicator(&staticDesc));
        staticDesc.TagAddLevel(new Tag(Tag::ASN_CLASS_CONTEXT_SPECIFIC, Tag::ASN_PRIMITIVE, 20));
        staticDesc._clauseOptional = true;
        staticDesc.SetNamedTypeName("ics-Indicator");
        result = &staticDesc;
        initialized = true;
        Asn::Unlock();
        return result;
    }
}


// Type EPS_SubscriptionData is a reference => no code generated.

// Type CSG_SubscriptionDataList is a reference => no code generated.


AsnDescObject* InsertSubscriberDataArg::Ue_ReachabilityRequestIndicator::GetStaticDescription()
{
    static volatile bool initialized = false;
    static AsnDescObject* result = NULL;
    static AsnDescNull staticDesc;

    if (initialized)
    {
        return result;
    }

    Asn::Lock();

    if (initialized)
    {
        Asn::Unlock();
        return result;
    }
    else
    {
        staticDesc.SetCloneForFactory(new Ue_ReachabilityRequestIndicator(&staticDesc));
        staticDesc.TagAddLevel(new Tag(Tag::ASN_CLASS_CONTEXT_SPECIFIC, Tag::ASN_PRIMITIVE, 33));
        staticDesc._clauseOptional = true;
        staticDesc.SetNamedTypeName("ue-ReachabilityRequestIndicator");
        result = &staticDesc;
        initialized = true;
        Asn::Unlock();
        return result;
    }
}


// Type ISDN_AddressString is a reference => no code generated.

// Type DiameterIdentity is a reference => no code generated.

// Type SubscribedPeriodicRAUTAUtimer is a reference => no code generated.


AsnDescObject* InsertSubscriberDataArg::VplmnLIPAAllowed::GetStaticDescription()
{
    static volatile bool initialized = false;
    static AsnDescObject* result = NULL;
    static AsnDescNull staticDesc;

    if (initialized)
    {
        return result;
    }

    Asn::Lock();

    if (initialized)
    {
        Asn::Unlock();
        return result;
    }
    else
    {
        staticDesc.SetCloneForFactory(new VplmnLIPAAllowed(&staticDesc));
        staticDesc.TagAddLevel(new Tag(Tag::ASN_CLASS_CONTEXT_SPECIFIC, Tag::ASN_PRIMITIVE, 37));
        staticDesc._clauseOptional = true;
        staticDesc.SetNamedTypeName("vplmnLIPAAllowed");
        result = &staticDesc;
        initialized = true;
        Asn::Unlock();
        return result;
    }
}



AsnDescObject* InsertSubscriberDataArg::MdtUserConsent::GetStaticDescription()
{
    static volatile bool initialized = false;
    static AsnDescObject* result = NULL;
    static AsnDescBoolean staticDesc;

    if (initialized)
    {
        return result;
    }

    Asn::Lock();

    if (initialized)
    {
        Asn::Unlock();
        return result;
    }
    else
    {
        staticDesc.SetCloneForFactory(new MdtUserConsent(&staticDesc));
        staticDesc.TagAddLevel(new Tag(Tag::ASN_CLASS_CONTEXT_SPECIFIC, Tag::ASN_PRIMITIVE, 38));
        staticDesc._clauseOptional = true;
        staticDesc.SetNamedTypeName("mdtUserConsent");
        result = &staticDesc;
        initialized = true;
        Asn::Unlock();
        return result;
    }
}


// Type SubscribedPeriodicLAUtimer is a reference => no code generated.

////////// End Nested Class(es) //////////

AsnDescObject* InsertSubscriberDataArg::GetStaticDescription()
{
    static volatile bool initialized = false;
    static AsnDescObject* result = NULL;
    static AsnDescSequence staticDesc(38);

    if (initialized)
    {
        return result;
    }

    Asn::Lock();

    if (initialized)
    {
        Asn::Unlock();
        return result;
    }
    else
    {
        staticDesc.SetCloneForFactory(new InsertSubscriberDataArg(&staticDesc));
        staticDesc.TagAddLevel(new Tag(Tag::ASN_CLASS_UNIVERSAL, Tag::ASN_CONSTRUCTED, 16));
        staticDesc._clauseExtensible = true;
        staticDesc._elementVect[0] = GetImsiStaticDescription();
        staticDesc._elementVect[1] = GetMsisdnStaticDescription();
        staticDesc._elementVect[2] = GetCategoryStaticDescription();
        staticDesc._elementVect[3] = GetSubscriberStatusStaticDescription();
        staticDesc._elementVect[4] = GetBearerServiceListStaticDescription();
        staticDesc._elementVect[5] = GetTeleserviceListStaticDescription();
        staticDesc._elementVect[6] = GetProvisionedSSStaticDescription();
        staticDesc._elementVect[7] = GetOdb_DataStaticDescription();
        staticDesc._elementVect[8] = GetRoamingRestrictionDueToUnsupportedFeatureStaticDescription();
        staticDesc._elementVect[9] = GetRegionalSubscriptionDataStaticDescription();
        staticDesc._elementVect[10] = GetVbsSubscriptionDataStaticDescription();
        staticDesc._elementVect[11] = GetVgcsSubscriptionDataStaticDescription();
        staticDesc._elementVect[12] = GetVlrCamelSubscriptionInfoStaticDescription();
        staticDesc._elementVect[13] = GetExtensionContainerStaticDescription();
        staticDesc._elementVect[14] = GetNaea_PreferredCIStaticDescription();
        staticDesc._elementVect[15] = GetGprsSubscriptionDataStaticDescription();
        staticDesc._elementVect[16] = GetRoamingRestrictedInSgsnDueToUnsupportedFeatureStaticDescription();
        staticDesc._elementVect[17] = GetNetworkAccessModeStaticDescription();
        staticDesc._elementVect[18] = GetLsaInformationStaticDescription();
        staticDesc._elementVect[19] = GetLmu_IndicatorStaticDescription();
        staticDesc._elementVect[20] = GetLcsInformationStaticDescription();
        staticDesc._elementVect[21] = GetIstAlertTimerStaticDescription();
        staticDesc._elementVect[22] = GetSuperChargerSupportedInHLRStaticDescription();
        staticDesc._elementVect[23] = GetMc_SS_InfoStaticDescription();
        staticDesc._elementVect[24] = GetCs_AllocationRetentionPriorityStaticDescription();
        staticDesc._elementVect[25] = GetSgsn_CAMEL_SubscriptionInfoStaticDescription();
        staticDesc._elementVect[26] = GetChargingCharacteristicsStaticDescription();
        staticDesc._elementVect[27] = GetAccessRestrictionDataStaticDescription();
        staticDesc._elementVect[28] = GetIcs_IndicatorStaticDescription();
        staticDesc._elementVect[29] = GetEps_SubscriptionDataStaticDescription();
        staticDesc._elementVect[30] = GetCsg_SubscriptionDataListStaticDescription();
        staticDesc._elementVect[31] = GetUe_ReachabilityRequestIndicatorStaticDescription();
        staticDesc._elementVect[32] = GetSgsn_NumberStaticDescription();
        staticDesc._elementVect[33] = GetMme_NameStaticDescription();
        staticDesc._elementVect[34] = GetSubscribedPeriodicRAUTAUtimerStaticDescription();
        staticDesc._elementVect[35] = GetVplmnLIPAAllowedStaticDescription();
        staticDesc._elementVect[36] = GetMdtUserConsentStaticDescription();
        staticDesc._elementVect[37] = GetSubscribedPeriodicLAUtimerStaticDescription();
        staticDesc.SetTypeName("InsertSubscriberDataArg");
        result = &staticDesc;
        initialized = true;
        Asn::Unlock();
        return result;
    }
}

AsnDescObject* InsertSubscriberDataArg::GetImsiStaticDescription()
{
    static volatile bool initialized = false;
    static AsnDescObject* result = NULL;
    static AsnDescOctetString staticDesc;

    if (initialized)
    {
        return result;
    }

    Asn::Lock();

    if (initialized)
    {
        Asn::Unlock();
        return result;
    }
    else
    {
        staticDesc.SetCloneForFactory(new IMSI(&staticDesc));
        staticDesc.TagAddLevel(new Tag(Tag::ASN_CLASS_CONTEXT_SPECIFIC, Tag::ASN_PRIMITIVE, 0));
        staticDesc._clauseOptional = true;
        staticDesc.SetNamedTypeName("imsi");
        result = &staticDesc;
        initialized = true;
        Asn::Unlock();
        return result;
    }
}

AsnDescObject* InsertSubscriberDataArg::GetMsisdnStaticDescription()
{
    static volatile bool initialized = false;
    static AsnDescObject* result = NULL;
    static AsnDescOctetString staticDesc;

    if (initialized)
    {
        return result;
    }

    Asn::Lock();

    if (initialized)
    {
        Asn::Unlock();
        return result;
    }
    else
    {
        staticDesc.SetCloneForFactory(new ISDN_AddressString(&staticDesc));
        staticDesc.TagAddLevel(new Tag(Tag::ASN_CLASS_CONTEXT_SPECIFIC, Tag::ASN_PRIMITIVE, 1));
        staticDesc._clauseOptional = true;
        staticDesc._clauseSize = true;
        staticDesc._minSize = 1;
        staticDesc._maxSize = 20;
        staticDesc.SetNamedTypeName("msisdn");
        result = &staticDesc;
        initialized = true;
        Asn::Unlock();
        return result;
    }
}

AsnDescObject* InsertSubscriberDataArg::GetCategoryStaticDescription()
{
    static volatile bool initialized = false;
    static AsnDescObject* result = NULL;
    static AsnDescOctetString staticDesc;

    if (initialized)
    {
        return result;
    }

    Asn::Lock();

    if (initialized)
    {
        Asn::Unlock();
        return result;
    }
    else
    {
        staticDesc.SetCloneForFactory(new Category(&staticDesc));
        staticDesc.TagAddLevel(new Tag(Tag::ASN_CLASS_CONTEXT_SPECIFIC, Tag::ASN_PRIMITIVE, 2));
        staticDesc._clauseOptional = true;
        staticDesc._clauseSize = true;
        staticDesc._minSize = 1;
        staticDesc._maxSize = 1;
        staticDesc.SetNamedTypeName("category");
        result = &staticDesc;
        initialized = true;
        Asn::Unlock();
        return result;
    }
}

AsnDescObject* InsertSubscriberDataArg::GetSubscriberStatusStaticDescription()
{
    static volatile bool initialized = false;
    static AsnDescObject* result = NULL;
    static AsnDescEnumerated staticDesc;

    if (initialized)
    {
        return result;
    }

    Asn::Lock();

    if (initialized)
    {
        Asn::Unlock();
        return result;
    }
    else
    {
        staticDesc.SetCloneForFactory(new SubscriberStatus(&staticDesc));
        staticDesc.TagAddLevel(new Tag(Tag::ASN_CLASS_CONTEXT_SPECIFIC, Tag::ASN_PRIMITIVE, 3));
        staticDesc._clauseOptional = true;
        staticDesc._valueSet.insert(0);
        staticDesc._valueSet.insert(1);
        static AsnDescEnumerated::NamedNumber namedNumberList[] = {{"serviceGranted", 0}, {"operatorDeterminedBarring", 1}, {NULL, 0}};
        staticDesc.SetNamedNumberList(namedNumberList);
        staticDesc.SetNamedTypeName("subscriberStatus");
        result = &staticDesc;
        initialized = true;
        Asn::Unlock();
        return result;
    }
}

AsnDescObject* InsertSubscriberDataArg::GetBearerServiceListStaticDescription()
{
    static volatile bool initialized = false;
    static AsnDescObject* result = NULL;
    static AsnDescSequenceOf staticDesc;

    if (initialized)
    {
        return result;
    }

    Asn::Lock();

    if (initialized)
    {
        Asn::Unlock();
        return result;
    }
    else
    {
        staticDesc.SetCloneForFactory(new BearerServiceList(&staticDesc));
        staticDesc.TagAddLevel(new Tag(Tag::ASN_CLASS_CONTEXT_SPECIFIC, Tag::ASN_CONSTRUCTED, 4));
        staticDesc._clauseOptional = true;
        staticDesc._clauseSize = true;
        staticDesc._minSize = 1;
        staticDesc._maxSize = 50;
        staticDesc._element = BearerServiceList::GetExt_BearerServiceCodeStaticDescription();
        staticDesc.SetNamedTypeName("bearerServiceList");
        result = &staticDesc;
        initialized = true;
        Asn::Unlock();
        return result;
    }
}

AsnDescObject* InsertSubscriberDataArg::GetTeleserviceListStaticDescription()
{
    static volatile bool initialized = false;
    static AsnDescObject* result = NULL;
    static AsnDescSequenceOf staticDesc;

    if (initialized)
    {
        return result;
    }

    Asn::Lock();

    if (initialized)
    {
        Asn::Unlock();
        return result;
    }
    else
    {
        staticDesc.SetCloneForFactory(new TeleserviceList(&staticDesc));
        staticDesc.TagAddLevel(new Tag(Tag::ASN_CLASS_CONTEXT_SPECIFIC, Tag::ASN_CONSTRUCTED, 6));
        staticDesc._clauseOptional = true;
        staticDesc._clauseSize = true;
        staticDesc._minSize = 1;
        staticDesc._maxSize = 20;
        staticDesc._element = TeleserviceList::GetExt_TeleserviceCodeStaticDescription();
        staticDesc.SetNamedTypeName("teleserviceList");
        result = &staticDesc;
        initialized = true;
        Asn::Unlock();
        return result;
    }
}

AsnDescObject* InsertSubscriberDataArg::GetProvisionedSSStaticDescription()
{
    static volatile bool initialized = false;
    static AsnDescObject* result = NULL;
    static AsnDescSequenceOf staticDesc;

    if (initialized)
    {
        return result;
    }

    Asn::Lock();

    if (initialized)
    {
        Asn::Unlock();
        return result;
    }
    else
    {
        staticDesc.SetCloneForFactory(new Ext_SS_InfoList(&staticDesc));
        staticDesc.TagAddLevel(new Tag(Tag::ASN_CLASS_CONTEXT_SPECIFIC, Tag::ASN_CONSTRUCTED, 7));
        staticDesc._clauseOptional = true;
        staticDesc._clauseSize = true;
        staticDesc._minSize = 1;
        staticDesc._maxSize = 30;
        staticDesc._element = Ext_SS_InfoList::GetExt_SS_InfoStaticDescription();
        staticDesc.SetNamedTypeName("provisionedSS");
        result = &staticDesc;
        initialized = true;
        Asn::Unlock();
        return result;
    }
}

AsnDescObject* InsertSubscriberDataArg::GetOdb_DataStaticDescription()
{
    static volatile bool initialized = false;
    static AsnDescObject* result = NULL;
    static AsnDescSequence staticDesc(3);

    if (initialized)
    {
        return result;
    }

    Asn::Lock();

    if (initialized)
    {
        Asn::Unlock();
        return result;
    }
    else
    {
        staticDesc.SetCloneForFactory(new ODB_Data(&staticDesc));
        staticDesc.TagAddLevel(new Tag(Tag::ASN_CLASS_CONTEXT_SPECIFIC, Tag::ASN_CONSTRUCTED, 8));
        staticDesc._clauseOptional = true;
        staticDesc._clauseExtensible = true;
        staticDesc._elementVect[0] = ODB_Data::GetOdb_GeneralDataStaticDescription();
        staticDesc._elementVect[1] = ODB_Data::GetOdb_HPLMN_DataStaticDescription();
        staticDesc._elementVect[2] = ODB_Data::GetExtensionContainerStaticDescription();
        staticDesc.SetNamedTypeName("odb-Data");
        result = &staticDesc;
        initialized = true;
        Asn::Unlock();
        return result;
    }
}

AsnDescObject* InsertSubscriberDataArg::GetRoamingRestrictionDueToUnsupportedFeatureStaticDescription()
{
    static volatile bool initialized = false;
    static AsnDescObject* result = NULL;
    static AsnDescNull staticDesc;

    if (initialized)
    {
        return result;
    }

    Asn::Lock();

    if (initialized)
    {
        Asn::Unlock();
        return result;
    }
    else
    {
        staticDesc.SetCloneForFactory(new RoamingRestrictionDueToUnsupportedFeature(&staticDesc));
        staticDesc.TagAddLevel(new Tag(Tag::ASN_CLASS_CONTEXT_SPECIFIC, Tag::ASN_PRIMITIVE, 9));
        staticDesc._clauseOptional = true;
        staticDesc.SetNamedTypeName("roamingRestrictionDueToUnsupportedFeature");
        result = &staticDesc;
        initialized = true;
        Asn::Unlock();
        return result;
    }
}

AsnDescObject* InsertSubscriberDataArg::GetRegionalSubscriptionDataStaticDescription()
{
    static volatile bool initialized = false;
    static AsnDescObject* result = NULL;
    static AsnDescSequenceOf staticDesc;

    if (initialized)
    {
        return result;
    }

    Asn::Lock();

    if (initialized)
    {
        Asn::Unlock();
        return result;
    }
    else
    {
        staticDesc.SetCloneForFactory(new ZoneCodeList(&staticDesc));
        staticDesc.TagAddLevel(new Tag(Tag::ASN_CLASS_CONTEXT_SPECIFIC, Tag::ASN_CONSTRUCTED, 10));
        staticDesc._clauseOptional = true;
        staticDesc._clauseSize = true;
        staticDesc._minSize = 1;
        staticDesc._maxSize = 10;
        staticDesc._element = ZoneCodeList::GetZoneCodeStaticDescription();
        staticDesc.SetNamedTypeName("regionalSubscriptionData");
        result = &staticDesc;
        initialized = true;
        Asn::Unlock();
        return result;
    }
}

AsnDescObject* InsertSubscriberDataArg::GetVbsSubscriptionDataStaticDescription()
{
    static volatile bool initialized = false;
    static AsnDescObject* result = NULL;
    static AsnDescSequenceOf staticDesc;

    if (initialized)
    {
        return result;
    }

    Asn::Lock();

    if (initialized)
    {
        Asn::Unlock();
        return result;
    }
    else
    {
        staticDesc.SetCloneForFactory(new VBSDataList(&staticDesc));
        staticDesc.TagAddLevel(new Tag(Tag::ASN_CLASS_CONTEXT_SPECIFIC, Tag::ASN_CONSTRUCTED, 11));
        staticDesc._clauseOptional = true;
        staticDesc._clauseSize = true;
        staticDesc._minSize = 1;
        staticDesc._maxSize = 50;
        staticDesc._element = VBSDataList::GetVoiceBroadcastDataStaticDescription();
        staticDesc.SetNamedTypeName("vbsSubscriptionData");
        result = &staticDesc;
        initialized = true;
        Asn::Unlock();
        return result;
    }
}

AsnDescObject* InsertSubscriberDataArg::GetVgcsSubscriptionDataStaticDescription()
{
    static volatile bool initialized = false;
    static AsnDescObject* result = NULL;
    static AsnDescSequenceOf staticDesc;

    if (initialized)
    {
        return result;
    }

    Asn::Lock();

    if (initialized)
    {
        Asn::Unlock();
        return result;
    }
    else
    {
        staticDesc.SetCloneForFactory(new VGCSDataList(&staticDesc));
        staticDesc.TagAddLevel(new Tag(Tag::ASN_CLASS_CONTEXT_SPECIFIC, Tag::ASN_CONSTRUCTED, 12));
        staticDesc._clauseOptional = true;
        staticDesc._clauseSize = true;
        staticDesc._minSize = 1;
        staticDesc._maxSize = 50;
        staticDesc._element = VGCSDataList::GetVoiceGroupCallDataStaticDescription();
        staticDesc.SetNamedTypeName("vgcsSubscriptionData");
        result = &staticDesc;
        initialized = true;
        Asn::Unlock();
        return result;
    }
}

AsnDescObject* InsertSubscriberDataArg::GetVlrCamelSubscriptionInfoStaticDescription()
{
    static volatile bool initialized = false;
    static AsnDescObject* result = NULL;
    static AsnDescSequence staticDesc(12);

    if (initialized)
    {
        return result;
    }

    Asn::Lock();

    if (initialized)
    {
        Asn::Unlock();
        return result;
    }
    else
    {
        staticDesc.SetCloneForFactory(new VlrCamelSubscriptionInfo(&staticDesc));
        staticDesc.TagAddLevel(new Tag(Tag::ASN_CLASS_CONTEXT_SPECIFIC, Tag::ASN_CONSTRUCTED, 13));
        staticDesc._clauseOptional = true;
        staticDesc._clauseExtensible = true;
        staticDesc._elementVect[0] = VlrCamelSubscriptionInfo::GetO_CSIStaticDescription();
        staticDesc._elementVect[1] = VlrCamelSubscriptionInfo::GetExtensionContainerStaticDescription();
        staticDesc._elementVect[2] = VlrCamelSubscriptionInfo::GetSs_CSIStaticDescription();
        staticDesc._elementVect[3] = VlrCamelSubscriptionInfo::GetO_BcsmCamelTDP_CriteriaListStaticDescription();
        staticDesc._elementVect[4] = VlrCamelSubscriptionInfo::GetTif_CSIStaticDescription();
        staticDesc._elementVect[5] = VlrCamelSubscriptionInfo::GetM_CSIStaticDescription();
        staticDesc._elementVect[6] = VlrCamelSubscriptionInfo::GetMo_sms_CSIStaticDescription();
        staticDesc._elementVect[7] = VlrCamelSubscriptionInfo::GetVt_CSIStaticDescription();
        staticDesc._elementVect[8] = VlrCamelSubscriptionInfo::GetT_BCSM_CAMEL_TDP_CriteriaListStaticDescription();
        staticDesc._elementVect[9] = VlrCamelSubscriptionInfo::GetD_CSIStaticDescription();
        staticDesc._elementVect[10] = VlrCamelSubscriptionInfo::GetMt_sms_CSIStaticDescription();
        staticDesc._elementVect[11] = VlrCamelSubscriptionInfo::GetMt_smsCAMELTDP_CriteriaListStaticDescription();
        staticDesc.SetNamedTypeName("vlrCamelSubscriptionInfo");
        result = &staticDesc;
        initialized = true;
        Asn::Unlock();
        return result;
    }
}

AsnDescObject* InsertSubscriberDataArg::GetExtensionContainerStaticDescription()
{
    static volatile bool initialized = false;
    static AsnDescObject* result = NULL;
    static AsnDescSequence staticDesc(2);

    if (initialized)
    {
        return result;
    }

    Asn::Lock();

    if (initialized)
    {
        Asn::Unlock();
        return result;
    }
    else
    {
        staticDesc.SetCloneForFactory(new ExtensionContainer(&staticDesc));
        staticDesc.TagAddLevel(new Tag(Tag::ASN_CLASS_CONTEXT_SPECIFIC, Tag::ASN_CONSTRUCTED, 14));
        staticDesc._clauseOptional = true;
        staticDesc._clauseExtensible = true;
        staticDesc._elementVect[0] = ExtensionContainer::GetPrivateExtensionListStaticDescription();
        staticDesc._elementVect[1] = ExtensionContainer::GetPcs_ExtensionsStaticDescription();
        staticDesc.SetNamedTypeName("extensionContainer");
        result = &staticDesc;
        initialized = true;
        Asn::Unlock();
        return result;
    }
}

AsnDescObject* InsertSubscriberDataArg::GetNaea_PreferredCIStaticDescription()
{
    static volatile bool initialized = false;
    static AsnDescObject* result = NULL;
    static AsnDescSequence staticDesc(2);

    if (initialized)
    {
        return result;
    }

    Asn::Lock();

    if (initialized)
    {
        Asn::Unlock();
        return result;
    }
    else
    {
        staticDesc.SetCloneForFactory(new NAEA_PreferredCI(&staticDesc));
        staticDesc.TagAddLevel(new Tag(Tag::ASN_CLASS_CONTEXT_SPECIFIC, Tag::ASN_CONSTRUCTED, 15));
        staticDesc._clauseOptional = true;
        staticDesc._clauseExtensible = true;
        staticDesc._elementVect[0] = NAEA_PreferredCI::GetNaea_PreferredCICStaticDescription();
        staticDesc._elementVect[1] = NAEA_PreferredCI::GetExtensionContainerStaticDescription();
        staticDesc.SetNamedTypeName("naea-PreferredCI");
        result = &staticDesc;
        initialized = true;
        Asn::Unlock();
        return result;
    }
}

AsnDescObject* InsertSubscriberDataArg::GetGprsSubscriptionDataStaticDescription()
{
    static volatile bool initialized = false;
    static AsnDescObject* result = NULL;
    static AsnDescSequence staticDesc(4);

    if (initialized)
    {
        return result;
    }

    Asn::Lock();

    if (initialized)
    {
        Asn::Unlock();
        return result;
    }
    else
    {
        staticDesc.SetCloneForFactory(new GPRSSubscriptionData(&staticDesc));
        staticDesc.TagAddLevel(new Tag(Tag::ASN_CLASS_CONTEXT_SPECIFIC, Tag::ASN_CONSTRUCTED, 16));
        staticDesc._clauseOptional = true;
        staticDesc._clauseExtensible = true;
        staticDesc._elementVect[0] = GPRSSubscriptionData::GetCompleteDataListIncludedStaticDescription();
        staticDesc._elementVect[1] = GPRSSubscriptionData::GetGprsDataListStaticDescription();
        staticDesc._elementVect[2] = GPRSSubscriptionData::GetExtensionContainerStaticDescription();
        staticDesc._elementVect[3] = GPRSSubscriptionData::GetApn_oi_ReplacementStaticDescription();
        staticDesc.SetNamedTypeName("gprsSubscriptionData");
        result = &staticDesc;
        initialized = true;
        Asn::Unlock();
        return result;
    }
}

AsnDescObject* InsertSubscriberDataArg::GetRoamingRestrictedInSgsnDueToUnsupportedFeatureStaticDescription()
{
    static volatile bool initialized = false;
    static AsnDescObject* result = NULL;
    static AsnDescNull staticDesc;

    if (initialized)
    {
        return result;
    }

    Asn::Lock();

    if (initialized)
    {
        Asn::Unlock();
        return result;
    }
    else
    {
        staticDesc.SetCloneForFactory(new RoamingRestrictedInSgsnDueToUnsupportedFeature(&staticDesc));
        staticDesc.TagAddLevel(new Tag(Tag::ASN_CLASS_CONTEXT_SPECIFIC, Tag::ASN_PRIMITIVE, 23));
        staticDesc._clauseOptional = true;
        staticDesc.SetNamedTypeName("roamingRestrictedInSgsnDueToUnsupportedFeature");
        result = &staticDesc;
        initialized = true;
        Asn::Unlock();
        return result;
    }
}

AsnDescObject* InsertSubscriberDataArg::GetNetworkAccessModeStaticDescription()
{
    static volatile bool initialized = false;
    static AsnDescObject* result = NULL;
    static AsnDescEnumerated staticDesc;

    if (initialized)
    {
        return result;
    }

    Asn::Lock();

    if (initialized)
    {
        Asn::Unlock();
        return result;
    }
    else
    {
        staticDesc.SetCloneForFactory(new NetworkAccessMode(&staticDesc));
        staticDesc.TagAddLevel(new Tag(Tag::ASN_CLASS_CONTEXT_SPECIFIC, Tag::ASN_PRIMITIVE, 24));
        staticDesc._clauseOptional = true;
        staticDesc._clauseExtensible = true;
        staticDesc._valueSet.insert(0);
        staticDesc._valueSet.insert(1);
        staticDesc._valueSet.insert(2);
        static AsnDescEnumerated::NamedNumber namedNumberList[] = {{"packetAndCircuit", 0}, {"onlyCircuit", 1}, {"onlyPacket", 2}, {NULL, 0}};
        staticDesc.SetNamedNumberList(namedNumberList);
        staticDesc.SetNamedTypeName("networkAccessMode");
        result = &staticDesc;
        initialized = true;
        Asn::Unlock();
        return result;
    }
}

AsnDescObject* InsertSubscriberDataArg::GetLsaInformationStaticDescription()
{
    static volatile bool initialized = false;
    static AsnDescObject* result = NULL;
    static AsnDescSequence staticDesc(4);

    if (initialized)
    {
        return result;
    }

    Asn::Lock();

    if (initialized)
    {
        Asn::Unlock();
        return result;
    }
    else
    {
        staticDesc.SetCloneForFactory(new LSAInformation(&staticDesc));
        staticDesc.TagAddLevel(new Tag(Tag::ASN_CLASS_CONTEXT_SPECIFIC, Tag::ASN_CONSTRUCTED, 25));
        staticDesc._clauseOptional = true;
        staticDesc._clauseExtensible = true;
        staticDesc._elementVect[0] = LSAInformation::GetCompleteDataListIncludedStaticDescription();
        staticDesc._elementVect[1] = LSAInformation::GetLsaOnlyAccessIndicatorStaticDescription();
        staticDesc._elementVect[2] = LSAInformation::GetLsaDataListStaticDescription();
        staticDesc._elementVect[3] = LSAInformation::GetExtensionContainerStaticDescription();
        staticDesc.SetNamedTypeName("lsaInformation");
        result = &staticDesc;
        initialized = true;
        Asn::Unlock();
        return result;
    }
}

AsnDescObject* InsertSubscriberDataArg::GetLmu_IndicatorStaticDescription()
{
    static volatile bool initialized = false;
    static AsnDescObject* result = NULL;
    static AsnDescNull staticDesc;

    if (initialized)
    {
        return result;
    }

    Asn::Lock();

    if (initialized)
    {
        Asn::Unlock();
        return result;
    }
    else
    {
        staticDesc.SetCloneForFactory(new Lmu_Indicator(&staticDesc));
        staticDesc.TagAddLevel(new Tag(Tag::ASN_CLASS_CONTEXT_SPECIFIC, Tag::ASN_PRIMITIVE, 21));
        staticDesc._clauseOptional = true;
        staticDesc.SetNamedTypeName("lmu-Indicator");
        result = &staticDesc;
        initialized = true;
        Asn::Unlock();
        return result;
    }
}

AsnDescObject* InsertSubscriberDataArg::GetLcsInformationStaticDescription()
{
    static volatile bool initialized = false;
    static AsnDescObject* result = NULL;
    static AsnDescSequence staticDesc(4);

    if (initialized)
    {
        return result;
    }

    Asn::Lock();

    if (initialized)
    {
        Asn::Unlock();
        return result;
    }
    else
    {
        staticDesc.SetCloneForFactory(new LCSInformation(&staticDesc));
        staticDesc.TagAddLevel(new Tag(Tag::ASN_CLASS_CONTEXT_SPECIFIC, Tag::ASN_CONSTRUCTED, 22));
        staticDesc._clauseOptional = true;
        staticDesc._clauseExtensible = true;
        staticDesc._elementVect[0] = LCSInformation::GetGmlc_ListStaticDescription();
        staticDesc._elementVect[1] = LCSInformation::GetLcs_PrivacyExceptionListStaticDescription();
        staticDesc._elementVect[2] = LCSInformation::GetMolr_ListStaticDescription();
        staticDesc._elementVect[3] = LCSInformation::GetAdd_lcs_PrivacyExceptionListStaticDescription();
        staticDesc.SetNamedTypeName("lcsInformation");
        result = &staticDesc;
        initialized = true;
        Asn::Unlock();
        return result;
    }
}

AsnDescObject* InsertSubscriberDataArg::GetIstAlertTimerStaticDescription()
{
    static volatile bool initialized = false;
    static AsnDescObject* result = NULL;
    static AsnDescInteger staticDesc;

    if (initialized)
    {
        return result;
    }

    Asn::Lock();

    if (initialized)
    {
        Asn::Unlock();
        return result;
    }
    else
    {
        staticDesc.SetCloneForFactory(new IST_AlertTimerValue(&staticDesc));
        staticDesc.TagAddLevel(new Tag(Tag::ASN_CLASS_CONTEXT_SPECIFIC, Tag::ASN_PRIMITIVE, 26));
        staticDesc._clauseOptional = true;
        staticDesc.SetNamedTypeName("istAlertTimer");
        result = &staticDesc;
        initialized = true;
        Asn::Unlock();
        return result;
    }
}

AsnDescObject* InsertSubscriberDataArg::GetSuperChargerSupportedInHLRStaticDescription()
{
    static volatile bool initialized = false;
    static AsnDescObject* result = NULL;
    static AsnDescOctetString staticDesc;

    if (initialized)
    {
        return result;
    }

    Asn::Lock();

    if (initialized)
    {
        Asn::Unlock();
        return result;
    }
    else
    {
        staticDesc.SetCloneForFactory(new AgeIndicator(&staticDesc));
        staticDesc.TagAddLevel(new Tag(Tag::ASN_CLASS_CONTEXT_SPECIFIC, Tag::ASN_PRIMITIVE, 27));
        staticDesc._clauseOptional = true;
        staticDesc._clauseSize = true;
        staticDesc._minSize = 1;
        staticDesc._maxSize = 6;
        staticDesc.SetNamedTypeName("superChargerSupportedInHLR");
        result = &staticDesc;
        initialized = true;
        Asn::Unlock();
        return result;
    }
}

AsnDescObject* InsertSubscriberDataArg::GetMc_SS_InfoStaticDescription()
{
    static volatile bool initialized = false;
    static AsnDescObject* result = NULL;
    static AsnDescSequence staticDesc(5);

    if (initialized)
    {
        return result;
    }

    Asn::Lock();

    if (initialized)
    {
        Asn::Unlock();
        return result;
    }
    else
    {
        staticDesc.SetCloneForFactory(new MC_SS_Info(&staticDesc));
        staticDesc.TagAddLevel(new Tag(Tag::ASN_CLASS_CONTEXT_SPECIFIC, Tag::ASN_CONSTRUCTED, 28));
        staticDesc._clauseOptional = true;
        staticDesc._clauseExtensible = true;
        staticDesc._elementVect[0] = MC_SS_Info::GetSs_CodeStaticDescription();
        staticDesc._elementVect[1] = MC_SS_Info::GetSs_StatusStaticDescription();
        staticDesc._elementVect[2] = MC_SS_Info::GetNbrSBStaticDescription();
        staticDesc._elementVect[3] = MC_SS_Info::GetNbrUserStaticDescription();
        staticDesc._elementVect[4] = MC_SS_Info::GetExtensionContainerStaticDescription();
        staticDesc.SetNamedTypeName("mc-SS-Info");
        result = &staticDesc;
        initialized = true;
        Asn::Unlock();
        return result;
    }
}

AsnDescObject* InsertSubscriberDataArg::GetCs_AllocationRetentionPriorityStaticDescription()
{
    static volatile bool initialized = false;
    static AsnDescObject* result = NULL;
    static AsnDescOctetString staticDesc;

    if (initialized)
    {
        return result;
    }

    Asn::Lock();

    if (initialized)
    {
        Asn::Unlock();
        return result;
    }
    else
    {
        staticDesc.SetCloneForFactory(new CS_AllocationRetentionPriority(&staticDesc));
        staticDesc.TagAddLevel(new Tag(Tag::ASN_CLASS_CONTEXT_SPECIFIC, Tag::ASN_PRIMITIVE, 29));
        staticDesc._clauseOptional = true;
        staticDesc._clauseSize = true;
        staticDesc._minSize = 1;
        staticDesc._maxSize = 1;
        staticDesc.SetNamedTypeName("cs-AllocationRetentionPriority");
        result = &staticDesc;
        initialized = true;
        Asn::Unlock();
        return result;
    }
}

AsnDescObject* InsertSubscriberDataArg::GetSgsn_CAMEL_SubscriptionInfoStaticDescription()
{
    static volatile bool initialized = false;
    static AsnDescObject* result = NULL;
    static AsnDescSequence staticDesc(6);

    if (initialized)
    {
        return result;
    }

    Asn::Lock();

    if (initialized)
    {
        Asn::Unlock();
        return result;
    }
    else
    {
        staticDesc.SetCloneForFactory(new SGSN_CAMEL_SubscriptionInfo(&staticDesc));
        staticDesc.TagAddLevel(new Tag(Tag::ASN_CLASS_CONTEXT_SPECIFIC, Tag::ASN_CONSTRUCTED, 17));
        staticDesc._clauseOptional = true;
        staticDesc._clauseExtensible = true;
        staticDesc._elementVect[0] = SGSN_CAMEL_SubscriptionInfo::GetGprs_CSIStaticDescription();
        staticDesc._elementVect[1] = SGSN_CAMEL_SubscriptionInfo::GetMo_sms_CSIStaticDescription();
        staticDesc._elementVect[2] = SGSN_CAMEL_SubscriptionInfo::GetExtensionContainerStaticDescription();
        staticDesc._elementVect[3] = SGSN_CAMEL_SubscriptionInfo::GetMt_sms_CSIStaticDescription();
        staticDesc._elementVect[4] = SGSN_CAMEL_SubscriptionInfo::GetMt_smsCAMELTDP_CriteriaListStaticDescription();
        staticDesc._elementVect[5] = SGSN_CAMEL_SubscriptionInfo::GetMg_csiStaticDescription();
        staticDesc.SetNamedTypeName("sgsn-CAMEL-SubscriptionInfo");
        result = &staticDesc;
        initialized = true;
        Asn::Unlock();
        return result;
    }
}

AsnDescObject* InsertSubscriberDataArg::GetChargingCharacteristicsStaticDescription()
{
    static volatile bool initialized = false;
    static AsnDescObject* result = NULL;
    static AsnDescOctetString staticDesc;

    if (initialized)
    {
        return result;
    }

    Asn::Lock();

    if (initialized)
    {
        Asn::Unlock();
        return result;
    }
    else
    {
        staticDesc.SetCloneForFactory(new ChargingCharacteristics(&staticDesc));
        staticDesc.TagAddLevel(new Tag(Tag::ASN_CLASS_CONTEXT_SPECIFIC, Tag::ASN_PRIMITIVE, 18));
        staticDesc._clauseOptional = true;
        staticDesc._clauseSize = true;
        staticDesc._minSize = 2;
        staticDesc._maxSize = 2;
        staticDesc.SetNamedTypeName("chargingCharacteristics");
        result = &staticDesc;
        initialized = true;
        Asn::Unlock();
        return result;
    }
}

AsnDescObject* InsertSubscriberDataArg::GetAccessRestrictionDataStaticDescription()
{
    static volatile bool initialized = false;
    static AsnDescObject* result = NULL;
    static AsnDescBitString staticDesc;

    if (initialized)
    {
        return result;
    }

    Asn::Lock();

    if (initialized)
    {
        Asn::Unlock();
        return result;
    }
    else
    {
        staticDesc.SetCloneForFactory(new AccessRestrictionData(&staticDesc));
        staticDesc.TagAddLevel(new Tag(Tag::ASN_CLASS_CONTEXT_SPECIFIC, Tag::ASN_PRIMITIVE, 19));
        staticDesc._clauseOptional = true;
        staticDesc._clauseSize = true;
        staticDesc._minSize = 2;
        staticDesc._maxSize = 8;
        staticDesc.SetNamedTypeName("accessRestrictionData");
        result = &staticDesc;
        initialized = true;
        Asn::Unlock();
        return result;
    }
}

AsnDescObject* InsertSubscriberDataArg::GetIcs_IndicatorStaticDescription()
{
    static volatile bool initialized = false;
    static AsnDescObject* result = NULL;
    static AsnDescBoolean staticDesc;

    if (initialized)
    {
        return result;
    }

    Asn::Lock();

    if (initialized)
    {
        Asn::Unlock();
        return result;
    }
    else
    {
        staticDesc.SetCloneForFactory(new Ics_Indicator(&staticDesc));
        staticDesc.TagAddLevel(new Tag(Tag::ASN_CLASS_CONTEXT_SPECIFIC, Tag::ASN_PRIMITIVE, 20));
        staticDesc._clauseOptional = true;
        staticDesc.SetNamedTypeName("ics-Indicator");
        result = &staticDesc;
        initialized = true;
        Asn::Unlock();
        return result;
    }
}

AsnDescObject* InsertSubscriberDataArg::GetEps_SubscriptionDataStaticDescription()
{
    static volatile bool initialized = false;
    static AsnDescObject* result = NULL;
    static AsnDescSequence staticDesc(8);

    if (initialized)
    {
        return result;
    }

    Asn::Lock();

    if (initialized)
    {
        Asn::Unlock();
        return result;
    }
    else
    {
        staticDesc.SetCloneForFactory(new EPS_SubscriptionData(&staticDesc));
        staticDesc.TagAddLevel(new Tag(Tag::ASN_CLASS_CONTEXT_SPECIFIC, Tag::ASN_CONSTRUCTED, 31));
        staticDesc._clauseOptional = true;
        staticDesc._clauseExtensible = true;
        staticDesc._elementVect[0] = EPS_SubscriptionData::GetApn_oi_ReplacementStaticDescription();
        staticDesc._elementVect[1] = EPS_SubscriptionData::GetRfsp_idStaticDescription();
        staticDesc._elementVect[2] = EPS_SubscriptionData::GetAmbrStaticDescription();
        staticDesc._elementVect[3] = EPS_SubscriptionData::GetApn_ConfigurationProfileStaticDescription();
        staticDesc._elementVect[4] = EPS_SubscriptionData::GetStn_srStaticDescription();
        staticDesc._elementVect[5] = EPS_SubscriptionData::GetExtensionContainerStaticDescription();
        staticDesc._elementVect[6] = EPS_SubscriptionData::GetMps_CSPriorityStaticDescription();
        staticDesc._elementVect[7] = EPS_SubscriptionData::GetMps_EPSPriorityStaticDescription();
        staticDesc.SetNamedTypeName("eps-SubscriptionData");
        result = &staticDesc;
        initialized = true;
        Asn::Unlock();
        return result;
    }
}

AsnDescObject* InsertSubscriberDataArg::GetCsg_SubscriptionDataListStaticDescription()
{
    static volatile bool initialized = false;
    static AsnDescObject* result = NULL;
    static AsnDescSequenceOf staticDesc;

    if (initialized)
    {
        return result;
    }

    Asn::Lock();

    if (initialized)
    {
        Asn::Unlock();
        return result;
    }
    else
    {
        staticDesc.SetCloneForFactory(new CSG_SubscriptionDataList(&staticDesc));
        staticDesc.TagAddLevel(new Tag(Tag::ASN_CLASS_CONTEXT_SPECIFIC, Tag::ASN_CONSTRUCTED, 32));
        staticDesc._clauseOptional = true;
        staticDesc._clauseSize = true;
        staticDesc._minSize = 1;
        staticDesc._maxSize = 50;
        staticDesc._element = CSG_SubscriptionDataList::GetCSG_SubscriptionDataStaticDescription();
        staticDesc.SetNamedTypeName("csg-SubscriptionDataList");
        result = &staticDesc;
        initialized = true;
        Asn::Unlock();
        return result;
    }
}

AsnDescObject* InsertSubscriberDataArg::GetUe_ReachabilityRequestIndicatorStaticDescription()
{
    static volatile bool initialized = false;
    static AsnDescObject* result = NULL;
    static AsnDescNull staticDesc;

    if (initialized)
    {
        return result;
    }

    Asn::Lock();

    if (initialized)
    {
        Asn::Unlock();
        return result;
    }
    else
    {
        staticDesc.SetCloneForFactory(new Ue_ReachabilityRequestIndicator(&staticDesc));
        staticDesc.TagAddLevel(new Tag(Tag::ASN_CLASS_CONTEXT_SPECIFIC, Tag::ASN_PRIMITIVE, 33));
        staticDesc._clauseOptional = true;
        staticDesc.SetNamedTypeName("ue-ReachabilityRequestIndicator");
        result = &staticDesc;
        initialized = true;
        Asn::Unlock();
        return result;
    }
}

AsnDescObject* InsertSubscriberDataArg::GetSgsn_NumberStaticDescription()
{
    static volatile bool initialized = false;
    static AsnDescObject* result = NULL;
    static AsnDescOctetString staticDesc;

    if (initialized)
    {
        return result;
    }

    Asn::Lock();

    if (initialized)
    {
        Asn::Unlock();
        return result;
    }
    else
    {
        staticDesc.SetCloneForFactory(new ISDN_AddressString(&staticDesc));
        staticDesc.TagAddLevel(new Tag(Tag::ASN_CLASS_CONTEXT_SPECIFIC, Tag::ASN_PRIMITIVE, 34));
        staticDesc._clauseOptional = true;
        staticDesc._clauseSize = true;
        staticDesc._minSize = 1;
        staticDesc._maxSize = 20;
        staticDesc.SetNamedTypeName("sgsn-Number");
        result = &staticDesc;
        initialized = true;
        Asn::Unlock();
        return result;
    }
}

AsnDescObject* InsertSubscriberDataArg::GetMme_NameStaticDescription()
{
    static volatile bool initialized = false;
    static AsnDescObject* result = NULL;
    static AsnDescOctetString staticDesc;

    if (initialized)
    {
        return result;
    }

    Asn::Lock();

    if (initialized)
    {
        Asn::Unlock();
        return result;
    }
    else
    {
        staticDesc.SetCloneForFactory(new DiameterIdentity(&staticDesc));
        staticDesc.TagAddLevel(new Tag(Tag::ASN_CLASS_CONTEXT_SPECIFIC, Tag::ASN_PRIMITIVE, 35));
        staticDesc._clauseOptional = true;
        staticDesc._clauseSize = true;
        staticDesc._minSize = 9;
        staticDesc._maxSize = 55;
        staticDesc.SetNamedTypeName("mme-Name");
        result = &staticDesc;
        initialized = true;
        Asn::Unlock();
        return result;
    }
}

AsnDescObject* InsertSubscriberDataArg::GetSubscribedPeriodicRAUTAUtimerStaticDescription()
{
    static volatile bool initialized = false;
    static AsnDescObject* result = NULL;
    static AsnDescInteger staticDesc;

    if (initialized)
    {
        return result;
    }

    Asn::Lock();

    if (initialized)
    {
        Asn::Unlock();
        return result;
    }
    else
    {
        staticDesc.SetCloneForFactory(new SubscribedPeriodicRAUTAUtimer(&staticDesc));
        staticDesc.TagAddLevel(new Tag(Tag::ASN_CLASS_CONTEXT_SPECIFIC, Tag::ASN_PRIMITIVE, 36));
        staticDesc._clauseOptional = true;
        staticDesc.SetNamedTypeName("subscribedPeriodicRAUTAUtimer");
        result = &staticDesc;
        initialized = true;
        Asn::Unlock();
        return result;
    }
}

AsnDescObject* InsertSubscriberDataArg::GetVplmnLIPAAllowedStaticDescription()
{
    static volatile bool initialized = false;
    static AsnDescObject* result = NULL;
    static AsnDescNull staticDesc;

    if (initialized)
    {
        return result;
    }

    Asn::Lock();

    if (initialized)
    {
        Asn::Unlock();
        return result;
    }
    else
    {
        staticDesc.SetCloneForFactory(new VplmnLIPAAllowed(&staticDesc));
        staticDesc.TagAddLevel(new Tag(Tag::ASN_CLASS_CONTEXT_SPECIFIC, Tag::ASN_PRIMITIVE, 37));
        staticDesc._clauseOptional = true;
        staticDesc.SetNamedTypeName("vplmnLIPAAllowed");
        result = &staticDesc;
        initialized = true;
        Asn::Unlock();
        return result;
    }
}

AsnDescObject* InsertSubscriberDataArg::GetMdtUserConsentStaticDescription()
{
    static volatile bool initialized = false;
    static AsnDescObject* result = NULL;
    static AsnDescBoolean staticDesc;

    if (initialized)
    {
        return result;
    }

    Asn::Lock();

    if (initialized)
    {
        Asn::Unlock();
        return result;
    }
    else
    {
        staticDesc.SetCloneForFactory(new MdtUserConsent(&staticDesc));
        staticDesc.TagAddLevel(new Tag(Tag::ASN_CLASS_CONTEXT_SPECIFIC, Tag::ASN_PRIMITIVE, 38));
        staticDesc._clauseOptional = true;
        staticDesc.SetNamedTypeName("mdtUserConsent");
        result = &staticDesc;
        initialized = true;
        Asn::Unlock();
        return result;
    }
}

AsnDescObject* InsertSubscriberDataArg::GetSubscribedPeriodicLAUtimerStaticDescription()
{
    static volatile bool initialized = false;
    static AsnDescObject* result = NULL;
    static AsnDescInteger staticDesc;

    if (initialized)
    {
        return result;
    }

    Asn::Lock();

    if (initialized)
    {
        Asn::Unlock();
        return result;
    }
    else
    {
        staticDesc.SetCloneForFactory(new SubscribedPeriodicLAUtimer(&staticDesc));
        staticDesc.TagAddLevel(new Tag(Tag::ASN_CLASS_CONTEXT_SPECIFIC, Tag::ASN_PRIMITIVE, 39));
        staticDesc._clauseOptional = true;
        staticDesc.SetNamedTypeName("subscribedPeriodicLAUtimer");
        result = &staticDesc;
        initialized = true;
        Asn::Unlock();
        return result;
    }
}





