//
// Generated by IntelliAsnCC ASN.1 compiler (C, C++, Java).
//
// Do not edit!
//
//
//
// (C) 2000, 2001 IntelliNet Technologies Inc. All Rights Reserved.
//
//


#if !defined(_ASN_USEFUL_EXTERNAL_H_)
#define _ASN_USEFUL_EXTERNAL_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <Asn.h>
#include <AsnObject.h>
#include <AsnDescObject.h>
#include <AsnError.h>

#include <AsnSequence.h>
#include <AsnObjectIdentifier.h>
#include <AsnInteger.h>
#include <AsnChoice.h>
#include <AsnAny.h>
#include <AsnOctetString.h>
#include <AsnBitString.h>
#include <AsnBaseString.h>

#include <ObjectDescriptor.h>



namespace its {



class EXTERNAL : public its::AsnSequence
{
public:


////////// Begin Nested Class(es) //////////



    class Direct_reference : public its::AsnObjectIdentifier
    {
    public:

        Direct_reference() : its::AsnObjectIdentifier(false)
        {
            Initialize();
        }

        Direct_reference(const std::vector<long>& array) : its::AsnObjectIdentifier(array, false)
        {
            Initialize();
        }

        Direct_reference(its::Octets& octets) : its::AsnObjectIdentifier(false)
        {
            Initialize();
            Decode(octets);
        }

        Direct_reference(const Direct_reference& rhs) : its::AsnObjectIdentifier(rhs)
        {
            // Nothing to do.
        }

        Direct_reference(its::AsnDescObject* description) : its::AsnObjectIdentifier(description)
        {
            // Nothing to do.
        }

        Direct_reference(its::AsnDescObject* description, const std::vector<long>& array) : its::AsnObjectIdentifier(description, array)
        {
            // Nothing to do.
        }

    protected:

        void Initialize()
        {
            _description = GetStaticDescription();
        }

    public:

        static its::AsnDescObject* GetStaticDescription();

    public:

        virtual ~Direct_reference()
        {
            // Nothing to do.
        }

        virtual its::AsnObject* Clone() const
        {
            return new Direct_reference(*this);
        }

        virtual std::string GetName() const
        { return "Direct_reference"; }

    };



    class Indirect_reference : public its::AsnInteger
    {
    public:

        Indirect_reference() : its::AsnInteger(false)
        {
            Initialize();
        }

        Indirect_reference(long value) : its::AsnInteger(value, false)
        {
            Initialize();
        }

        Indirect_reference(its::Octets& octets) : its::AsnInteger(false)
        {
            Initialize();
            Decode(octets);
        }

        Indirect_reference(const Indirect_reference& rhs) : its::AsnInteger(rhs)
        {
            // Nothing to do.
        }

        Indirect_reference(its::AsnDescObject* description) : its::AsnInteger(description)
        {
            // Nothing to do.
        }

        Indirect_reference(its::AsnDescObject* description, long value) : its::AsnInteger(description, value)
        {
            // Nothing to do.
        }

    protected:

        void Initialize()
        {
            _description = GetStaticDescription();
        }

    public:

        static its::AsnDescObject* GetStaticDescription();

    public:

        virtual ~Indirect_reference()
        {
            // Nothing to do.
        }

        virtual its::AsnObject* Clone() const
        {
            return new Indirect_reference(*this);
        }

        virtual std::string GetName() const
        { return "Indirect_reference"; }

    };



    class Encoding : public its::AsnChoice
    {
    public:


    ////////// Begin Nested Class(es) //////////



        class Single_ASN1_type : public its::AsnAny
        {
        public:

            Single_ASN1_type() : its::AsnAny(false)
            {
                Initialize();
            }

            Single_ASN1_type(its::AsnObject* any) : its::AsnAny(any, false)
            {
                Initialize();
            }

            Single_ASN1_type(its::Octets& octets) : its::AsnAny(false)
            {
                Initialize();
                Decode(octets);
            }

            Single_ASN1_type(const Single_ASN1_type& rhs) : its::AsnAny(rhs)
            {
                // Nothing to do.
            }

            Single_ASN1_type(its::AsnDescObject* description) : its::AsnAny(description)
            {
                // Nothing to do.
            }

            Single_ASN1_type(its::AsnDescObject* description, its::AsnObject* any) : its::AsnAny(description, any)
            {
                // Nothing to do.
            }

        protected:

            void Initialize()
            {
                _description = GetStaticDescription();
            }

        public:

            static its::AsnDescObject* GetStaticDescription();

        public:

            virtual ~Single_ASN1_type()
            {
                // Nothing to do.
            }

            virtual its::AsnObject* Clone() const
            {
                return new Single_ASN1_type(*this);
            }

            virtual std::string GetName() const
            { return "Single_ASN1_type"; }

        };



        class Octet_aligned : public its::AsnOctetString
        {
        public:

            Octet_aligned() : its::AsnOctetString(false)
            {
                Initialize();
            }

            Octet_aligned(const std::vector<byte>& array) : its::AsnOctetString(array, false)
            {
                Initialize();
            }

            Octet_aligned(its::Octets& octets) : its::AsnOctetString(false)
            {
                Initialize();
                Decode(octets);
            }

            Octet_aligned(const Octet_aligned& rhs) : its::AsnOctetString(rhs)
            {
                // Nothing to do.
            }

            Octet_aligned(its::AsnDescObject* description) : its::AsnOctetString(description)
            {
                // Nothing to do.
            }

            Octet_aligned(its::AsnDescObject* description, const std::vector<byte>& array) : its::AsnOctetString(description, array)
            {
                // Nothing to do.
            }

        protected:

            void Initialize()
            {
                _description = GetStaticDescription();
            }

        public:

            static its::AsnDescObject* GetStaticDescription();

        public:

            virtual ~Octet_aligned()
            {
                // Nothing to do.
            }

            virtual its::AsnObject* Clone() const
            {
                return new Octet_aligned(*this);
            }

            virtual std::string GetName() const
            { return "Octet_aligned"; }

        };



        class Arbitrary : public its::AsnBitString
        {
        public:

            Arbitrary() : its::AsnBitString(false)
            {
                Initialize();
            }

            Arbitrary(const std::vector<bool>& array) : its::AsnBitString(array, false)
            {
                Initialize();
            }

            Arbitrary(its::Octets& octets) : its::AsnBitString(false)
            {
                Initialize();
                Decode(octets);
            }

            Arbitrary(const Arbitrary& rhs) : its::AsnBitString(rhs)
            {
                // Nothing to do.
            }

            Arbitrary(its::AsnDescObject* description) : its::AsnBitString(description)
            {
                // Nothing to do.
            }

            Arbitrary(its::AsnDescObject* description, const std::vector<bool>& array) : its::AsnBitString(description, array)
            {
                // Nothing to do.
            }

        protected:

            void Initialize()
            {
                _description = GetStaticDescription();
            }

        public:

            static its::AsnDescObject* GetStaticDescription();

        public:

            virtual ~Arbitrary()
            {
                // Nothing to do.
            }

            virtual its::AsnObject* Clone() const
            {
                return new Arbitrary(*this);
            }

            virtual std::string GetName() const
            { return "Arbitrary"; }

        };


    ////////// End Nested Class(es) //////////

        Encoding() : its::AsnChoice(false)
        {
            Initialize();
        }

        Encoding(its::Octets& octets) : its::AsnChoice(false)
        {
            Initialize();
            Decode(octets);
        }

        Encoding(const Encoding& rhs) : its::AsnChoice(rhs)
        {
            // Nothing to do.
        }

        Encoding(its::AsnDescObject* description) : its::AsnChoice(description)
        {
            // Nothing to do.
        }

        Encoding(its::AsnDescObject* description, its::AsnObject* choice) : its::AsnChoice(description, choice)
        {
            // Nothing to do.
        }

    protected:

        void Initialize()
        {
            _description = GetStaticDescription();
        }

    public:

        static its::AsnDescObject* GetStaticDescription();

        static its::AsnDescObject* GetSingle_ASN1_typeStaticDescription();
        static its::AsnDescObject* GetOctet_alignedStaticDescription();
        static its::AsnDescObject* GetArbitraryStaticDescription();

    public:

        virtual ~Encoding()
        {
            // Nothing to do.
        }

        virtual its::AsnObject* Clone() const
        {
            return new Encoding(*this);
        }

        virtual std::string GetName() const
        { return "Encoding"; }

        void SetChoiceSingle_ASN1_type(Single_ASN1_type* choice)
        {
            ITS_REQUIRE(choice != NULL);
            choice->AsnObject::SetDescription(GetSingle_ASN1_typeStaticDescription());
            SetChoice(choice);
        }

        void SetChoiceSingle_ASN1_type(const Single_ASN1_type& choice)
        {
            its::AsnObject& asnObject = const_cast<Single_ASN1_type&>(choice);
            asnObject.SetDescription(GetSingle_ASN1_typeStaticDescription());
            SetChoice(choice);
        }

        bool ChoiceSingle_ASN1_type() const
        {
            return Contains(GetSingle_ASN1_typeStaticDescription()->TagIdentity());
        }

        const Single_ASN1_type& GetChoiceSingle_ASN1_type() const
        {
            ITS_REQUIRE(ChoiceSingle_ASN1_type());
            return static_cast<const Single_ASN1_type&> (GetChoice());
        }

        void SetChoiceOctet_aligned(Octet_aligned* choice)
        {
            ITS_REQUIRE(choice != NULL);
            choice->AsnObject::SetDescription(GetOctet_alignedStaticDescription());
            SetChoice(choice);
        }

        void SetChoiceOctet_aligned(const Octet_aligned& choice)
        {
            its::AsnObject& asnObject = const_cast<Octet_aligned&>(choice);
            asnObject.SetDescription(GetOctet_alignedStaticDescription());
            SetChoice(choice);
        }

        bool ChoiceOctet_aligned() const
        {
            return Contains(GetOctet_alignedStaticDescription()->TagIdentity());
        }

        const Octet_aligned& GetChoiceOctet_aligned() const
        {
            ITS_REQUIRE(ChoiceOctet_aligned());
            return static_cast<const Octet_aligned&> (GetChoice());
        }

        void SetChoiceArbitrary(Arbitrary* choice)
        {
            ITS_REQUIRE(choice != NULL);
            choice->AsnObject::SetDescription(GetArbitraryStaticDescription());
            SetChoice(choice);
        }

        void SetChoiceArbitrary(const Arbitrary& choice)
        {
            its::AsnObject& asnObject = const_cast<Arbitrary&>(choice);
            asnObject.SetDescription(GetArbitraryStaticDescription());
            SetChoice(choice);
        }

        bool ChoiceArbitrary() const
        {
            return Contains(GetArbitraryStaticDescription()->TagIdentity());
        }

        const Arbitrary& GetChoiceArbitrary() const
        {
            ITS_REQUIRE(ChoiceArbitrary());
            return static_cast<const Arbitrary&> (GetChoice());
        }

    };


    typedef its::ObjectDescriptor ObjectDescriptor;


////////// End Nested Class(es) //////////

    EXTERNAL() : its::AsnSequence(4, false)
    {
        Initialize();
    }

    EXTERNAL(its::Octets& octets) : its::AsnSequence(4, false)
    {
        Initialize();
        Decode(octets);
    }

    EXTERNAL(const EXTERNAL& rhs) : its::AsnSequence(rhs)
    {
        // Nothing to do.
    }

    EXTERNAL(its::AsnDescObject* description) : its::AsnSequence(4, description)
    {
        // Nothing to do.
    }

protected:

    void Initialize()
    {
        _description = GetStaticDescription();
    }

public:

    static its::AsnDescObject* GetStaticDescription();

    static its::AsnDescObject* GetDirect_referenceStaticDescription();
    static its::AsnDescObject* GetIndirect_referenceStaticDescription();
    static its::AsnDescObject* GetData_value_descriptorStaticDescription();
    static its::AsnDescObject* GetEncodingStaticDescription();

public:

    virtual ~EXTERNAL()
    {
        // Nothing to do.
    }

    virtual its::AsnObject* Clone() const
    {
        return new EXTERNAL(*this);
    }

    virtual std::string GetName() const
    { return "EXTERNAL"; }

    void SetDirect_reference(Direct_reference* element)
    {
        ITS_REQUIRE(element != NULL);
        element->AsnObject::SetDescription(GetDirect_referenceStaticDescription());
        AddElement(0, element);
    }

    void SetDirect_reference(const Direct_reference& element)
    {
        its::AsnObject& asnObject = const_cast<Direct_reference&>(element);
        asnObject.SetDescription(GetDirect_referenceStaticDescription());
        AddElement(0, element);
    }

    bool OptionDirect_reference() const
    {
        return Contains(0);
    }

    const Direct_reference& GetDirect_reference() const
    {
        ITS_REQUIRE(OptionDirect_reference());
        return static_cast<const Direct_reference&> (ElementAt(0));
    }

    void SetIndirect_reference(Indirect_reference* element)
    {
        ITS_REQUIRE(element != NULL);
        element->AsnObject::SetDescription(GetIndirect_referenceStaticDescription());
        AddElement(1, element);
    }

    void SetIndirect_reference(const Indirect_reference& element)
    {
        its::AsnObject& asnObject = const_cast<Indirect_reference&>(element);
        asnObject.SetDescription(GetIndirect_referenceStaticDescription());
        AddElement(1, element);
    }

    bool OptionIndirect_reference() const
    {
        return Contains(1);
    }

    const Indirect_reference& GetIndirect_reference() const
    {
        ITS_REQUIRE(OptionIndirect_reference());
        return static_cast<const Indirect_reference&> (ElementAt(1));
    }

    void SetData_value_descriptor(ObjectDescriptor* element)
    {
        ITS_REQUIRE(element != NULL);
        element->AsnObject::SetDescription(GetData_value_descriptorStaticDescription());
        AddElement(2, element);
    }

    void SetData_value_descriptor(const ObjectDescriptor& element)
    {
        its::AsnObject& asnObject = const_cast<ObjectDescriptor&>(element);
        asnObject.SetDescription(GetData_value_descriptorStaticDescription());
        AddElement(2, element);
    }

    bool OptionData_value_descriptor() const
    {
        return Contains(2);
    }

    const ObjectDescriptor& GetData_value_descriptor() const
    {
        ITS_REQUIRE(OptionData_value_descriptor());
        return static_cast<const ObjectDescriptor&> (ElementAt(2));
    }

    void SetEncoding(Encoding* element)
    {
        ITS_REQUIRE(element != NULL);
        element->AsnObject::SetDescription(GetEncodingStaticDescription());
        AddElement(3, element);
    }

    void SetEncoding(const Encoding& element)
    {
        its::AsnObject& asnObject = const_cast<Encoding&>(element);
        asnObject.SetDescription(GetEncodingStaticDescription());
        AddElement(3, element);
    }

    const Encoding& GetEncoding() const
    {
        return static_cast<const Encoding&> (ElementAt(3));
    }

};



} // namespace.

#endif    // !defined(_ASN_USEFUL_EXTERNAL_H_)

