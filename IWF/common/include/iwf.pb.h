// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: iwf.proto

#ifndef PROTOBUF_iwf_2eproto__INCLUDED
#define PROTOBUF_iwf_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_iwf_2eproto();
void protobuf_AssignDesc_iwf_2eproto();
void protobuf_ShutdownFile_iwf_2eproto();

class pbState;
class pbIwfTranslator;
class pbRoutingLabel;
class pbDiaMsg;
class pbSccpAddress;
class QualityOfService;
class pbTcapDialogue;
class pbSCCPParameters;
class pbTcapComponent;
class pbTcapBeginDialogue;
class SubscriptionIdConfig;
class StoredIDPSMSToCCRIData;
class IDPToCCRIData;
class pbERBData;
class pbActivityTimerData;
class pbIwfDccaSessionCtxt;
class pbConnectArgData;
class pbACHData;
class pbCapRoTsl;
class pbStoredUserData;
class pbIwfTimerData;
class pbSCCP_ADDR;
class pbMtp3_Header;
class pbTcapTransactionData;
class pbDiameterSessionData;
class pbIwfFsmInfo;
class pbIwfSessionContextData;

enum pbIwfTimerData_ETimerType {
  pbIwfTimerData_ETimerType_NO_EVENT_TIMER = 1,
  pbIwfTimerData_ETimerType_FAKE_ACH_TIMER = 2,
  pbIwfTimerData_ETimerType_ACTIVITY_TIMER = 3,
  pbIwfTimerData_ETimerType_ACH_DELTA_TIMER = 4,
  pbIwfTimerData_ETimerType_ACR_TIMER = 5,
  pbIwfTimerData_ETimerType_CONNECT_MAX_CALL_DURATION = 6,
  pbIwfTimerData_ETimerType_ACTIVITY_RESPONSE_TIMER = 7,
  pbIwfTimerData_ETimerType_IWF_SUBSCRIBER_AUDIT_TIMER = 8,
  pbIwfTimerData_ETimerType_IWF_DCCA_TX_TIMER = 9,
  pbIwfTimerData_ETimerType_IWF_ISFOLLOWN_TIMER = 10,
  pbIwfTimerData_ETimerType_INVALID_TIMER = -1
};
bool pbIwfTimerData_ETimerType_IsValid(int value);
const pbIwfTimerData_ETimerType pbIwfTimerData_ETimerType_ETimerType_MIN = pbIwfTimerData_ETimerType_INVALID_TIMER;
const pbIwfTimerData_ETimerType pbIwfTimerData_ETimerType_ETimerType_MAX = pbIwfTimerData_ETimerType_IWF_ISFOLLOWN_TIMER;
const int pbIwfTimerData_ETimerType_ETimerType_ARRAYSIZE = pbIwfTimerData_ETimerType_ETimerType_MAX + 1;

const ::google::protobuf::EnumDescriptor* pbIwfTimerData_ETimerType_descriptor();
inline const ::std::string& pbIwfTimerData_ETimerType_Name(pbIwfTimerData_ETimerType value) {
  return ::google::protobuf::internal::NameOfEnum(
    pbIwfTimerData_ETimerType_descriptor(), value);
}
inline bool pbIwfTimerData_ETimerType_Parse(
    const ::std::string& name, pbIwfTimerData_ETimerType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<pbIwfTimerData_ETimerType>(
    pbIwfTimerData_ETimerType_descriptor(), name, value);
}
enum pbIwfTimerData_EKeyType {
  pbIwfTimerData_EKeyType_INVLAID_KEY = -1,
  pbIwfTimerData_EKeyType_SESSION_ID = 1,
  pbIwfTimerData_EKeyType_DIALOG_ID = 2
};
bool pbIwfTimerData_EKeyType_IsValid(int value);
const pbIwfTimerData_EKeyType pbIwfTimerData_EKeyType_EKeyType_MIN = pbIwfTimerData_EKeyType_INVLAID_KEY;
const pbIwfTimerData_EKeyType pbIwfTimerData_EKeyType_EKeyType_MAX = pbIwfTimerData_EKeyType_DIALOG_ID;
const int pbIwfTimerData_EKeyType_EKeyType_ARRAYSIZE = pbIwfTimerData_EKeyType_EKeyType_MAX + 1;

const ::google::protobuf::EnumDescriptor* pbIwfTimerData_EKeyType_descriptor();
inline const ::std::string& pbIwfTimerData_EKeyType_Name(pbIwfTimerData_EKeyType value) {
  return ::google::protobuf::internal::NameOfEnum(
    pbIwfTimerData_EKeyType_descriptor(), value);
}
inline bool pbIwfTimerData_EKeyType_Parse(
    const ::std::string& name, pbIwfTimerData_EKeyType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<pbIwfTimerData_EKeyType>(
    pbIwfTimerData_EKeyType_descriptor(), name, value);
}
enum pbProtocol {
  DIAMETER_S6A = 0,
  DIAMETER_RO = 1,
  MAP_GR = 2,
  CAP_GE = 3
};
bool pbProtocol_IsValid(int value);
const pbProtocol pbProtocol_MIN = DIAMETER_S6A;
const pbProtocol pbProtocol_MAX = CAP_GE;
const int pbProtocol_ARRAYSIZE = pbProtocol_MAX + 1;

const ::google::protobuf::EnumDescriptor* pbProtocol_descriptor();
inline const ::std::string& pbProtocol_Name(pbProtocol value) {
  return ::google::protobuf::internal::NameOfEnum(
    pbProtocol_descriptor(), value);
}
inline bool pbProtocol_Parse(
    const ::std::string& name, pbProtocol* value) {
  return ::google::protobuf::internal::ParseNamedEnum<pbProtocol>(
    pbProtocol_descriptor(), name, value);
}
enum TransState {
  INVALID_STATE = 0,
  RRB_SENT = 1,
  ACH_SENT = 2,
  FAKE_ACH_SENT = 3,
  ERB_RCVD = 4,
  ACR_RCVD = 5,
  FOLLOW_ON = 6,
  IS_FOLLOW_ON = 7,
  ER_SMS_RCVD = 8,
  ERB_DISCONNECT = 9,
  ACR_CALLACT_FALSE = 10,
  ABORT_RCVD = 11,
  REJECT_RCVD = 12,
  ACR_CALLACT_TRUE = 13
};
bool TransState_IsValid(int value);
const TransState TransState_MIN = INVALID_STATE;
const TransState TransState_MAX = ACR_CALLACT_TRUE;
const int TransState_ARRAYSIZE = TransState_MAX + 1;

const ::google::protobuf::EnumDescriptor* TransState_descriptor();
inline const ::std::string& TransState_Name(TransState value) {
  return ::google::protobuf::internal::NameOfEnum(
    TransState_descriptor(), value);
}
inline bool TransState_Parse(
    const ::std::string& name, TransState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TransState>(
    TransState_descriptor(), name, value);
}
// ===================================================================

class pbState : public ::google::protobuf::Message {
 public:
  pbState();
  virtual ~pbState();
  
  pbState(const pbState& from);
  
  inline pbState& operator=(const pbState& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const pbState& default_instance();
  
  void Swap(pbState* other);
  
  // implements Message ----------------------------------------------
  
  pbState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pbState& from);
  void MergeFrom(const pbState& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 Id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);
  
  // optional string Name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // @@protoc_insertion_point(class_scope:pbState)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::google::protobuf::uint32 id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_iwf_2eproto();
  friend void protobuf_AssignDesc_iwf_2eproto();
  friend void protobuf_ShutdownFile_iwf_2eproto();
  
  void InitAsDefaultInstance();
  static pbState* default_instance_;
};
// -------------------------------------------------------------------

class pbIwfTranslator : public ::google::protobuf::Message {
 public:
  pbIwfTranslator();
  virtual ~pbIwfTranslator();
  
  pbIwfTranslator(const pbIwfTranslator& from);
  
  inline pbIwfTranslator& operator=(const pbIwfTranslator& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const pbIwfTranslator& default_instance();
  
  void Swap(pbIwfTranslator* other);
  
  // implements Message ----------------------------------------------
  
  pbIwfTranslator* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pbIwfTranslator& from);
  void MergeFrom(const pbIwfTranslator& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string Name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional uint32 Id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:pbIwfTranslator)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_id();
  inline void clear_has_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::google::protobuf::uint32 id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_iwf_2eproto();
  friend void protobuf_AssignDesc_iwf_2eproto();
  friend void protobuf_ShutdownFile_iwf_2eproto();
  
  void InitAsDefaultInstance();
  static pbIwfTranslator* default_instance_;
};
// -------------------------------------------------------------------

class pbRoutingLabel : public ::google::protobuf::Message {
 public:
  pbRoutingLabel();
  virtual ~pbRoutingLabel();
  
  pbRoutingLabel(const pbRoutingLabel& from);
  
  inline pbRoutingLabel& operator=(const pbRoutingLabel& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const pbRoutingLabel& default_instance();
  
  void Swap(pbRoutingLabel* other);
  
  // implements Message ----------------------------------------------
  
  pbRoutingLabel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pbRoutingLabel& from);
  void MergeFrom(const pbRoutingLabel& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 oPc = 1;
  inline bool has_opc() const;
  inline void clear_opc();
  static const int kOPcFieldNumber = 1;
  inline ::google::protobuf::uint32 opc() const;
  inline void set_opc(::google::protobuf::uint32 value);
  
  // optional bool isNational = 2;
  inline bool has_isnational() const;
  inline void clear_isnational();
  static const int kIsNationalFieldNumber = 2;
  inline bool isnational() const;
  inline void set_isnational(bool value);
  
  // optional uint32 oSsn = 3;
  inline bool has_ossn() const;
  inline void clear_ossn();
  static const int kOSsnFieldNumber = 3;
  inline ::google::protobuf::uint32 ossn() const;
  inline void set_ossn(::google::protobuf::uint32 value);
  
  // optional bool useSccpCdPAFromInMsg = 4;
  inline bool has_usesccpcdpafrominmsg() const;
  inline void clear_usesccpcdpafrominmsg();
  static const int kUseSccpCdPAFromInMsgFieldNumber = 4;
  inline bool usesccpcdpafrominmsg() const;
  inline void set_usesccpcdpafrominmsg(bool value);
  
  // @@protoc_insertion_point(class_scope:pbRoutingLabel)
 private:
  inline void set_has_opc();
  inline void clear_has_opc();
  inline void set_has_isnational();
  inline void clear_has_isnational();
  inline void set_has_ossn();
  inline void clear_has_ossn();
  inline void set_has_usesccpcdpafrominmsg();
  inline void clear_has_usesccpcdpafrominmsg();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 opc_;
  ::google::protobuf::uint32 ossn_;
  bool isnational_;
  bool usesccpcdpafrominmsg_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_iwf_2eproto();
  friend void protobuf_AssignDesc_iwf_2eproto();
  friend void protobuf_ShutdownFile_iwf_2eproto();
  
  void InitAsDefaultInstance();
  static pbRoutingLabel* default_instance_;
};
// -------------------------------------------------------------------

class pbDiaMsg : public ::google::protobuf::Message {
 public:
  pbDiaMsg();
  virtual ~pbDiaMsg();
  
  pbDiaMsg(const pbDiaMsg& from);
  
  inline pbDiaMsg& operator=(const pbDiaMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const pbDiaMsg& default_instance();
  
  void Swap(pbDiaMsg* other);
  
  // implements Message ----------------------------------------------
  
  pbDiaMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pbDiaMsg& from);
  void MergeFrom(const pbDiaMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 CommandCode = 1;
  inline bool has_commandcode() const;
  inline void clear_commandcode();
  static const int kCommandCodeFieldNumber = 1;
  inline ::google::protobuf::uint32 commandcode() const;
  inline void set_commandcode(::google::protobuf::uint32 value);
  
  // optional bool RequestBit = 2;
  inline bool has_requestbit() const;
  inline void clear_requestbit();
  static const int kRequestBitFieldNumber = 2;
  inline bool requestbit() const;
  inline void set_requestbit(bool value);
  
  // optional string username = 3;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 3;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  
  // optional string SessionId = 4;
  inline bool has_sessionid() const;
  inline void clear_sessionid();
  static const int kSessionIdFieldNumber = 4;
  inline const ::std::string& sessionid() const;
  inline void set_sessionid(const ::std::string& value);
  inline void set_sessionid(const char* value);
  inline void set_sessionid(const char* value, size_t size);
  inline ::std::string* mutable_sessionid();
  inline ::std::string* release_sessionid();
  
  // @@protoc_insertion_point(class_scope:pbDiaMsg)
 private:
  inline void set_has_commandcode();
  inline void clear_has_commandcode();
  inline void set_has_requestbit();
  inline void clear_has_requestbit();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_sessionid();
  inline void clear_has_sessionid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 commandcode_;
  bool requestbit_;
  ::std::string* username_;
  ::std::string* sessionid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_iwf_2eproto();
  friend void protobuf_AssignDesc_iwf_2eproto();
  friend void protobuf_ShutdownFile_iwf_2eproto();
  
  void InitAsDefaultInstance();
  static pbDiaMsg* default_instance_;
};
// -------------------------------------------------------------------

class pbSccpAddress : public ::google::protobuf::Message {
 public:
  pbSccpAddress();
  virtual ~pbSccpAddress();
  
  pbSccpAddress(const pbSccpAddress& from);
  
  inline pbSccpAddress& operator=(const pbSccpAddress& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const pbSccpAddress& default_instance();
  
  void Swap(pbSccpAddress* other);
  
  // implements Message ----------------------------------------------
  
  pbSccpAddress* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pbSccpAddress& from);
  void MergeFrom(const pbSccpAddress& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  
  // optional bool hasPc = 2;
  inline bool has_haspc() const;
  inline void clear_haspc();
  static const int kHasPcFieldNumber = 2;
  inline bool haspc() const;
  inline void set_haspc(bool value);
  
  // optional bool hasSsn = 3;
  inline bool has_hasssn() const;
  inline void clear_hasssn();
  static const int kHasSsnFieldNumber = 3;
  inline bool hasssn() const;
  inline void set_hasssn(bool value);
  
  // optional bool routePCSSN = 4;
  inline bool has_routepcssn() const;
  inline void clear_routepcssn();
  static const int kRoutePCSSNFieldNumber = 4;
  inline bool routepcssn() const;
  inline void set_routepcssn(bool value);
  
  // optional bool internationalRoute = 5;
  inline bool has_internationalroute() const;
  inline void clear_internationalroute();
  static const int kInternationalRouteFieldNumber = 5;
  inline bool internationalroute() const;
  inline void set_internationalroute(bool value);
  
  // optional bool globalTitle = 6;
  inline bool has_globaltitle() const;
  inline void clear_globaltitle();
  static const int kGlobalTitleFieldNumber = 6;
  inline bool globaltitle() const;
  inline void set_globaltitle(bool value);
  
  // optional uint32 PointCode = 7;
  inline bool has_pointcode() const;
  inline void clear_pointcode();
  static const int kPointCodeFieldNumber = 7;
  inline ::google::protobuf::uint32 pointcode() const;
  inline void set_pointcode(::google::protobuf::uint32 value);
  
  // optional uint32 ssn = 8;
  inline bool has_ssn() const;
  inline void clear_ssn();
  static const int kSsnFieldNumber = 8;
  inline ::google::protobuf::uint32 ssn() const;
  inline void set_ssn(::google::protobuf::uint32 value);
  
  // optional uint32 gttlen = 9;
  inline bool has_gttlen() const;
  inline void clear_gttlen();
  static const int kGttlenFieldNumber = 9;
  inline ::google::protobuf::uint32 gttlen() const;
  inline void set_gttlen(::google::protobuf::uint32 value);
  
  // optional bytes globTitle = 10;
  inline bool has_globtitle() const;
  inline void clear_globtitle();
  static const int kGlobTitleFieldNumber = 10;
  inline const ::std::string& globtitle() const;
  inline void set_globtitle(const ::std::string& value);
  inline void set_globtitle(const char* value);
  inline void set_globtitle(const void* value, size_t size);
  inline ::std::string* mutable_globtitle();
  inline ::std::string* release_globtitle();
  
  // optional uint32 gttType = 11;
  inline bool has_gtttype() const;
  inline void clear_gtttype();
  static const int kGttTypeFieldNumber = 11;
  inline ::google::protobuf::uint32 gtttype() const;
  inline void set_gtttype(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:pbSccpAddress)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_haspc();
  inline void clear_has_haspc();
  inline void set_has_hasssn();
  inline void clear_has_hasssn();
  inline void set_has_routepcssn();
  inline void clear_has_routepcssn();
  inline void set_has_internationalroute();
  inline void clear_has_internationalroute();
  inline void set_has_globaltitle();
  inline void clear_has_globaltitle();
  inline void set_has_pointcode();
  inline void clear_has_pointcode();
  inline void set_has_ssn();
  inline void clear_has_ssn();
  inline void set_has_gttlen();
  inline void clear_has_gttlen();
  inline void set_has_globtitle();
  inline void clear_has_globtitle();
  inline void set_has_gtttype();
  inline void clear_has_gtttype();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* id_;
  bool haspc_;
  bool hasssn_;
  bool routepcssn_;
  bool internationalroute_;
  bool globaltitle_;
  ::google::protobuf::uint32 pointcode_;
  ::google::protobuf::uint32 ssn_;
  ::std::string* globtitle_;
  ::google::protobuf::uint32 gttlen_;
  ::google::protobuf::uint32 gtttype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  friend void  protobuf_AddDesc_iwf_2eproto();
  friend void protobuf_AssignDesc_iwf_2eproto();
  friend void protobuf_ShutdownFile_iwf_2eproto();
  
  void InitAsDefaultInstance();
  static pbSccpAddress* default_instance_;
};
// -------------------------------------------------------------------

class QualityOfService : public ::google::protobuf::Message {
 public:
  QualityOfService();
  virtual ~QualityOfService();
  
  QualityOfService(const QualityOfService& from);
  
  inline QualityOfService& operator=(const QualityOfService& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const QualityOfService& default_instance();
  
  void Swap(QualityOfService* other);
  
  // implements Message ----------------------------------------------
  
  QualityOfService* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QualityOfService& from);
  void MergeFrom(const QualityOfService& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 flags = 1;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 1;
  inline ::google::protobuf::uint32 flags() const;
  inline void set_flags(::google::protobuf::uint32 value);
  
  // optional uint32 slsKey = 2;
  inline bool has_slskey() const;
  inline void clear_slskey();
  static const int kSlsKeyFieldNumber = 2;
  inline ::google::protobuf::uint32 slskey() const;
  inline void set_slskey(::google::protobuf::uint32 value);
  
  // optional uint32 priority = 3;
  inline bool has_priority() const;
  inline void clear_priority();
  static const int kPriorityFieldNumber = 3;
  inline ::google::protobuf::uint32 priority() const;
  inline void set_priority(::google::protobuf::uint32 value);
  
  // optional uint32 networkInd = 4;
  inline bool has_networkind() const;
  inline void clear_networkind();
  static const int kNetworkIndFieldNumber = 4;
  inline ::google::protobuf::uint32 networkind() const;
  inline void set_networkind(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:QualityOfService)
 private:
  inline void set_has_flags();
  inline void clear_has_flags();
  inline void set_has_slskey();
  inline void clear_has_slskey();
  inline void set_has_priority();
  inline void clear_has_priority();
  inline void set_has_networkind();
  inline void clear_has_networkind();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 flags_;
  ::google::protobuf::uint32 slskey_;
  ::google::protobuf::uint32 priority_;
  ::google::protobuf::uint32 networkind_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_iwf_2eproto();
  friend void protobuf_AssignDesc_iwf_2eproto();
  friend void protobuf_ShutdownFile_iwf_2eproto();
  
  void InitAsDefaultInstance();
  static QualityOfService* default_instance_;
};
// -------------------------------------------------------------------

class pbTcapDialogue : public ::google::protobuf::Message {
 public:
  pbTcapDialogue();
  virtual ~pbTcapDialogue();
  
  pbTcapDialogue(const pbTcapDialogue& from);
  
  inline pbTcapDialogue& operator=(const pbTcapDialogue& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const pbTcapDialogue& default_instance();
  
  void Swap(pbTcapDialogue* other);
  
  // implements Message ----------------------------------------------
  
  pbTcapDialogue* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pbTcapDialogue& from);
  void MergeFrom(const pbTcapDialogue& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 DialogueId = 1;
  inline bool has_dialogueid() const;
  inline void clear_dialogueid();
  static const int kDialogueIdFieldNumber = 1;
  inline ::google::protobuf::uint32 dialogueid() const;
  inline void set_dialogueid(::google::protobuf::uint32 value);
  
  // optional uint32 DialogueType = 2;
  inline bool has_dialoguetype() const;
  inline void clear_dialoguetype();
  static const int kDialogueTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 dialoguetype() const;
  inline void set_dialoguetype(::google::protobuf::uint32 value);
  
  // optional string AbortReason = 3;
  inline bool has_abortreason() const;
  inline void clear_abortreason();
  static const int kAbortReasonFieldNumber = 3;
  inline const ::std::string& abortreason() const;
  inline void set_abortreason(const ::std::string& value);
  inline void set_abortreason(const char* value);
  inline void set_abortreason(const char* value, size_t size);
  inline ::std::string* mutable_abortreason();
  inline ::std::string* release_abortreason();
  
  // optional bytes ApplicationContext = 4;
  inline bool has_applicationcontext() const;
  inline void clear_applicationcontext();
  static const int kApplicationContextFieldNumber = 4;
  inline const ::std::string& applicationcontext() const;
  inline void set_applicationcontext(const ::std::string& value);
  inline void set_applicationcontext(const char* value);
  inline void set_applicationcontext(const void* value, size_t size);
  inline ::std::string* mutable_applicationcontext();
  inline ::std::string* release_applicationcontext();
  
  // optional .QualityOfService Qos = 5;
  inline bool has_qos() const;
  inline void clear_qos();
  static const int kQosFieldNumber = 5;
  inline const ::QualityOfService& qos() const;
  inline ::QualityOfService* mutable_qos();
  inline ::QualityOfService* release_qos();
  
  // @@protoc_insertion_point(class_scope:pbTcapDialogue)
 private:
  inline void set_has_dialogueid();
  inline void clear_has_dialogueid();
  inline void set_has_dialoguetype();
  inline void clear_has_dialoguetype();
  inline void set_has_abortreason();
  inline void clear_has_abortreason();
  inline void set_has_applicationcontext();
  inline void clear_has_applicationcontext();
  inline void set_has_qos();
  inline void clear_has_qos();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 dialogueid_;
  ::google::protobuf::uint32 dialoguetype_;
  ::std::string* abortreason_;
  ::std::string* applicationcontext_;
  ::QualityOfService* qos_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_iwf_2eproto();
  friend void protobuf_AssignDesc_iwf_2eproto();
  friend void protobuf_ShutdownFile_iwf_2eproto();
  
  void InitAsDefaultInstance();
  static pbTcapDialogue* default_instance_;
};
// -------------------------------------------------------------------

class pbSCCPParameters : public ::google::protobuf::Message {
 public:
  pbSCCPParameters();
  virtual ~pbSCCPParameters();
  
  pbSCCPParameters(const pbSCCPParameters& from);
  
  inline pbSCCPParameters& operator=(const pbSCCPParameters& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const pbSCCPParameters& default_instance();
  
  void Swap(pbSCCPParameters* other);
  
  // implements Message ----------------------------------------------
  
  pbSCCPParameters* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pbSCCPParameters& from);
  void MergeFrom(const pbSCCPParameters& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .pbSccpAddress SccpCallingPartyAddr = 1;
  inline bool has_sccpcallingpartyaddr() const;
  inline void clear_sccpcallingpartyaddr();
  static const int kSccpCallingPartyAddrFieldNumber = 1;
  inline const ::pbSccpAddress& sccpcallingpartyaddr() const;
  inline ::pbSccpAddress* mutable_sccpcallingpartyaddr();
  inline ::pbSccpAddress* release_sccpcallingpartyaddr();
  
  // optional .pbSccpAddress SccpCalledPartyAddr = 2;
  inline bool has_sccpcalledpartyaddr() const;
  inline void clear_sccpcalledpartyaddr();
  static const int kSccpCalledPartyAddrFieldNumber = 2;
  inline const ::pbSccpAddress& sccpcalledpartyaddr() const;
  inline ::pbSccpAddress* mutable_sccpcalledpartyaddr();
  inline ::pbSccpAddress* release_sccpcalledpartyaddr();
  
  // optional uint32 Opc = 3;
  inline bool has_opc() const;
  inline void clear_opc();
  static const int kOpcFieldNumber = 3;
  inline ::google::protobuf::uint32 opc() const;
  inline void set_opc(::google::protobuf::uint32 value);
  
  // optional uint32 Dpc = 4;
  inline bool has_dpc() const;
  inline void clear_dpc();
  static const int kDpcFieldNumber = 4;
  inline ::google::protobuf::uint32 dpc() const;
  inline void set_dpc(::google::protobuf::uint32 value);
  
  // optional bool isRouteByGt = 5;
  inline bool has_isroutebygt() const;
  inline void clear_isroutebygt();
  static const int kIsRouteByGtFieldNumber = 5;
  inline bool isroutebygt() const;
  inline void set_isroutebygt(bool value);
  
  // @@protoc_insertion_point(class_scope:pbSCCPParameters)
 private:
  inline void set_has_sccpcallingpartyaddr();
  inline void clear_has_sccpcallingpartyaddr();
  inline void set_has_sccpcalledpartyaddr();
  inline void clear_has_sccpcalledpartyaddr();
  inline void set_has_opc();
  inline void clear_has_opc();
  inline void set_has_dpc();
  inline void clear_has_dpc();
  inline void set_has_isroutebygt();
  inline void clear_has_isroutebygt();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::pbSccpAddress* sccpcallingpartyaddr_;
  ::pbSccpAddress* sccpcalledpartyaddr_;
  ::google::protobuf::uint32 opc_;
  ::google::protobuf::uint32 dpc_;
  bool isroutebygt_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_iwf_2eproto();
  friend void protobuf_AssignDesc_iwf_2eproto();
  friend void protobuf_ShutdownFile_iwf_2eproto();
  
  void InitAsDefaultInstance();
  static pbSCCPParameters* default_instance_;
};
// -------------------------------------------------------------------

class pbTcapComponent : public ::google::protobuf::Message {
 public:
  pbTcapComponent();
  virtual ~pbTcapComponent();
  
  pbTcapComponent(const pbTcapComponent& from);
  
  inline pbTcapComponent& operator=(const pbTcapComponent& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const pbTcapComponent& default_instance();
  
  void Swap(pbTcapComponent* other);
  
  // implements Message ----------------------------------------------
  
  pbTcapComponent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pbTcapComponent& from);
  void MergeFrom(const pbTcapComponent& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 lastComponent = 1;
  inline bool has_lastcomponent() const;
  inline void clear_lastcomponent();
  static const int kLastComponentFieldNumber = 1;
  inline ::google::protobuf::uint32 lastcomponent() const;
  inline void set_lastcomponent(::google::protobuf::uint32 value);
  
  // optional uint32 invokeId = 2;
  inline bool has_invokeid() const;
  inline void clear_invokeid();
  static const int kInvokeIdFieldNumber = 2;
  inline ::google::protobuf::uint32 invokeid() const;
  inline void set_invokeid(::google::protobuf::uint32 value);
  
  // optional uint32 componentType = 3;
  inline bool has_componenttype() const;
  inline void clear_componenttype();
  static const int kComponentTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 componenttype() const;
  inline void set_componenttype(::google::protobuf::uint32 value);
  
  // optional fixed32 opCode = 4;
  inline bool has_opcode() const;
  inline void clear_opcode();
  static const int kOpCodeFieldNumber = 4;
  inline ::google::protobuf::uint32 opcode() const;
  inline void set_opcode(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:pbTcapComponent)
 private:
  inline void set_has_lastcomponent();
  inline void clear_has_lastcomponent();
  inline void set_has_invokeid();
  inline void clear_has_invokeid();
  inline void set_has_componenttype();
  inline void clear_has_componenttype();
  inline void set_has_opcode();
  inline void clear_has_opcode();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 lastcomponent_;
  ::google::protobuf::uint32 invokeid_;
  ::google::protobuf::uint32 componenttype_;
  ::google::protobuf::uint32 opcode_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_iwf_2eproto();
  friend void protobuf_AssignDesc_iwf_2eproto();
  friend void protobuf_ShutdownFile_iwf_2eproto();
  
  void InitAsDefaultInstance();
  static pbTcapComponent* default_instance_;
};
// -------------------------------------------------------------------

class pbTcapBeginDialogue : public ::google::protobuf::Message {
 public:
  pbTcapBeginDialogue();
  virtual ~pbTcapBeginDialogue();
  
  pbTcapBeginDialogue(const pbTcapBeginDialogue& from);
  
  inline pbTcapBeginDialogue& operator=(const pbTcapBeginDialogue& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const pbTcapBeginDialogue& default_instance();
  
  void Swap(pbTcapBeginDialogue* other);
  
  // implements Message ----------------------------------------------
  
  pbTcapBeginDialogue* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pbTcapBeginDialogue& from);
  void MergeFrom(const pbTcapBeginDialogue& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 oPc = 1;
  inline bool has_opc() const;
  inline void clear_opc();
  static const int kOPcFieldNumber = 1;
  inline ::google::protobuf::uint32 opc() const;
  inline void set_opc(::google::protobuf::uint32 value);
  
  // optional .pbSccpAddress SccpCallingPartyAddr = 2;
  inline bool has_sccpcallingpartyaddr() const;
  inline void clear_sccpcallingpartyaddr();
  static const int kSccpCallingPartyAddrFieldNumber = 2;
  inline const ::pbSccpAddress& sccpcallingpartyaddr() const;
  inline ::pbSccpAddress* mutable_sccpcallingpartyaddr();
  inline ::pbSccpAddress* release_sccpcallingpartyaddr();
  
  // @@protoc_insertion_point(class_scope:pbTcapBeginDialogue)
 private:
  inline void set_has_opc();
  inline void clear_has_opc();
  inline void set_has_sccpcallingpartyaddr();
  inline void clear_has_sccpcallingpartyaddr();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::pbSccpAddress* sccpcallingpartyaddr_;
  ::google::protobuf::uint32 opc_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_iwf_2eproto();
  friend void protobuf_AssignDesc_iwf_2eproto();
  friend void protobuf_ShutdownFile_iwf_2eproto();
  
  void InitAsDefaultInstance();
  static pbTcapBeginDialogue* default_instance_;
};
// -------------------------------------------------------------------

class SubscriptionIdConfig : public ::google::protobuf::Message {
 public:
  SubscriptionIdConfig();
  virtual ~SubscriptionIdConfig();
  
  SubscriptionIdConfig(const SubscriptionIdConfig& from);
  
  inline SubscriptionIdConfig& operator=(const SubscriptionIdConfig& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SubscriptionIdConfig& default_instance();
  
  void Swap(SubscriptionIdConfig* other);
  
  // implements Message ----------------------------------------------
  
  SubscriptionIdConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SubscriptionIdConfig& from);
  void MergeFrom(const SubscriptionIdConfig& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 subIdType = 1;
  inline bool has_subidtype() const;
  inline void clear_subidtype();
  static const int kSubIdTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 subidtype() const;
  inline void set_subidtype(::google::protobuf::uint32 value);
  
  // optional string subIdData = 2 [default = ""];
  inline bool has_subiddata() const;
  inline void clear_subiddata();
  static const int kSubIdDataFieldNumber = 2;
  inline const ::std::string& subiddata() const;
  inline void set_subiddata(const ::std::string& value);
  inline void set_subiddata(const char* value);
  inline void set_subiddata(const char* value, size_t size);
  inline ::std::string* mutable_subiddata();
  inline ::std::string* release_subiddata();
  
  // @@protoc_insertion_point(class_scope:SubscriptionIdConfig)
 private:
  inline void set_has_subidtype();
  inline void clear_has_subidtype();
  inline void set_has_subiddata();
  inline void clear_has_subiddata();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* subiddata_;
  ::google::protobuf::uint32 subidtype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_iwf_2eproto();
  friend void protobuf_AssignDesc_iwf_2eproto();
  friend void protobuf_ShutdownFile_iwf_2eproto();
  
  void InitAsDefaultInstance();
  static SubscriptionIdConfig* default_instance_;
};
// -------------------------------------------------------------------

class StoredIDPSMSToCCRIData : public ::google::protobuf::Message {
 public:
  StoredIDPSMSToCCRIData();
  virtual ~StoredIDPSMSToCCRIData();
  
  StoredIDPSMSToCCRIData(const StoredIDPSMSToCCRIData& from);
  
  inline StoredIDPSMSToCCRIData& operator=(const StoredIDPSMSToCCRIData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StoredIDPSMSToCCRIData& default_instance();
  
  void Swap(StoredIDPSMSToCCRIData* other);
  
  // implements Message ----------------------------------------------
  
  StoredIDPSMSToCCRIData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StoredIDPSMSToCCRIData& from);
  void MergeFrom(const StoredIDPSMSToCCRIData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 callTypeVal = 1 [default = 0];
  inline bool has_calltypeval() const;
  inline void clear_calltypeval();
  static const int kCallTypeValFieldNumber = 1;
  inline ::google::protobuf::uint32 calltypeval() const;
  inline void set_calltypeval(::google::protobuf::uint32 value);
  
  // optional uint32 CAP_Service_Key = 2 [default = 0];
  inline bool has_cap_service_key() const;
  inline void clear_cap_service_key();
  static const int kCAPServiceKeyFieldNumber = 2;
  inline ::google::protobuf::uint32 cap_service_key() const;
  inline void set_cap_service_key(::google::protobuf::uint32 value);
  
  // optional string CAP_Dialed_Digits = 3 [default = ""];
  inline bool has_cap_dialed_digits() const;
  inline void clear_cap_dialed_digits();
  static const int kCAPDialedDigitsFieldNumber = 3;
  inline const ::std::string& cap_dialed_digits() const;
  inline void set_cap_dialed_digits(const ::std::string& value);
  inline void set_cap_dialed_digits(const char* value);
  inline void set_cap_dialed_digits(const char* value, size_t size);
  inline ::std::string* mutable_cap_dialed_digits();
  inline ::std::string* release_cap_dialed_digits();
  
  // optional uint32 CAP_Called_TON = 4 [default = 1000];
  inline bool has_cap_called_ton() const;
  inline void clear_cap_called_ton();
  static const int kCAPCalledTONFieldNumber = 4;
  inline ::google::protobuf::uint32 cap_called_ton() const;
  inline void set_cap_called_ton(::google::protobuf::uint32 value);
  
  // optional string CAP_CLI = 5 [default = ""];
  inline bool has_cap_cli() const;
  inline void clear_cap_cli();
  static const int kCAPCLIFieldNumber = 5;
  inline const ::std::string& cap_cli() const;
  inline void set_cap_cli(const ::std::string& value);
  inline void set_cap_cli(const char* value);
  inline void set_cap_cli(const char* value, size_t size);
  inline ::std::string* mutable_cap_cli();
  inline ::std::string* release_cap_cli();
  
  // optional string CAP_Location_Number = 6 [default = ""];
  inline bool has_cap_location_number() const;
  inline void clear_cap_location_number();
  static const int kCAPLocationNumberFieldNumber = 6;
  inline const ::std::string& cap_location_number() const;
  inline void set_cap_location_number(const ::std::string& value);
  inline void set_cap_location_number(const char* value);
  inline void set_cap_location_number(const char* value, size_t size);
  inline ::std::string* mutable_cap_location_number();
  inline ::std::string* release_cap_location_number();
  
  // optional string CAP_IMSI = 7 [default = ""];
  inline bool has_cap_imsi() const;
  inline void clear_cap_imsi();
  static const int kCAPIMSIFieldNumber = 7;
  inline const ::std::string& cap_imsi() const;
  inline void set_cap_imsi(const ::std::string& value);
  inline void set_cap_imsi(const char* value);
  inline void set_cap_imsi(const char* value, size_t size);
  inline ::std::string* mutable_cap_imsi();
  inline ::std::string* release_cap_imsi();
  
  // optional string CAP_VLR_Number = 8 [default = ""];
  inline bool has_cap_vlr_number() const;
  inline void clear_cap_vlr_number();
  static const int kCAPVLRNumberFieldNumber = 8;
  inline const ::std::string& cap_vlr_number() const;
  inline void set_cap_vlr_number(const ::std::string& value);
  inline void set_cap_vlr_number(const char* value);
  inline void set_cap_vlr_number(const char* value, size_t size);
  inline ::std::string* mutable_cap_vlr_number();
  inline ::std::string* release_cap_vlr_number();
  
  // optional string CAP_Call_Reference = 9 [default = ""];
  inline bool has_cap_call_reference() const;
  inline void clear_cap_call_reference();
  static const int kCAPCallReferenceFieldNumber = 9;
  inline const ::std::string& cap_call_reference() const;
  inline void set_cap_call_reference(const ::std::string& value);
  inline void set_cap_call_reference(const char* value);
  inline void set_cap_call_reference(const char* value, size_t size);
  inline ::std::string* mutable_cap_call_reference();
  inline ::std::string* release_cap_call_reference();
  
  // optional string CAP_MSC_Address = 10 [default = ""];
  inline bool has_cap_msc_address() const;
  inline void clear_cap_msc_address();
  static const int kCAPMSCAddressFieldNumber = 10;
  inline const ::std::string& cap_msc_address() const;
  inline void set_cap_msc_address(const ::std::string& value);
  inline void set_cap_msc_address(const char* value);
  inline void set_cap_msc_address(const char* value, size_t size);
  inline ::std::string* mutable_cap_msc_address();
  inline ::std::string* release_cap_msc_address();
  
  // optional uint32 CAP_Called_NPI = 11 [default = 1000];
  inline bool has_cap_called_npi() const;
  inline void clear_cap_called_npi();
  static const int kCAPCalledNPIFieldNumber = 11;
  inline ::google::protobuf::uint32 cap_called_npi() const;
  inline void set_cap_called_npi(::google::protobuf::uint32 value);
  
  // optional uint32 CAP_Calling_NOA = 12 [default = 1000];
  inline bool has_cap_calling_noa() const;
  inline void clear_cap_calling_noa();
  static const int kCAPCallingNOAFieldNumber = 12;
  inline ::google::protobuf::uint32 cap_calling_noa() const;
  inline void set_cap_calling_noa(::google::protobuf::uint32 value);
  
  // optional uint32 CAP_CLI_NPI = 13 [default = 1000];
  inline bool has_cap_cli_npi() const;
  inline void clear_cap_cli_npi();
  static const int kCAPCLINPIFieldNumber = 13;
  inline ::google::protobuf::uint32 cap_cli_npi() const;
  inline void set_cap_cli_npi(::google::protobuf::uint32 value);
  
  // optional uint32 CAP_Version = 14 [default = 1000];
  inline bool has_cap_version() const;
  inline void clear_cap_version();
  static const int kCAPVersionFieldNumber = 14;
  inline ::google::protobuf::uint32 cap_version() const;
  inline void set_cap_version(::google::protobuf::uint32 value);
  
  // optional string CAP_SMSC_Address = 15 [default = ""];
  inline bool has_cap_smsc_address() const;
  inline void clear_cap_smsc_address();
  static const int kCAPSMSCAddressFieldNumber = 15;
  inline const ::std::string& cap_smsc_address() const;
  inline void set_cap_smsc_address(const ::std::string& value);
  inline void set_cap_smsc_address(const char* value);
  inline void set_cap_smsc_address(const char* value, size_t size);
  inline ::std::string* mutable_cap_smsc_address();
  inline ::std::string* release_cap_smsc_address();
  
  // optional string CAP_SGSN_Address = 16 [default = ""];
  inline bool has_cap_sgsn_address() const;
  inline void clear_cap_sgsn_address();
  static const int kCAPSGSNAddressFieldNumber = 16;
  inline const ::std::string& cap_sgsn_address() const;
  inline void set_cap_sgsn_address(const ::std::string& value);
  inline void set_cap_sgsn_address(const char* value);
  inline void set_cap_sgsn_address(const char* value, size_t size);
  inline ::std::string* mutable_cap_sgsn_address();
  inline ::std::string* release_cap_sgsn_address();
  
  // optional string CAP_SM_IMEI = 17 [default = ""];
  inline bool has_cap_sm_imei() const;
  inline void clear_cap_sm_imei();
  static const int kCAPSMIMEIFieldNumber = 17;
  inline const ::std::string& cap_sm_imei() const;
  inline void set_cap_sm_imei(const ::std::string& value);
  inline void set_cap_sm_imei(const char* value);
  inline void set_cap_sm_imei(const char* value, size_t size);
  inline ::std::string* mutable_cap_sm_imei();
  inline ::std::string* release_cap_sm_imei();
  
  // optional string CAP_SM_StatusReportRequest = 18 [default = ""];
  inline bool has_cap_sm_statusreportrequest() const;
  inline void clear_cap_sm_statusreportrequest();
  static const int kCAPSMStatusReportRequestFieldNumber = 18;
  inline const ::std::string& cap_sm_statusreportrequest() const;
  inline void set_cap_sm_statusreportrequest(const ::std::string& value);
  inline void set_cap_sm_statusreportrequest(const char* value);
  inline void set_cap_sm_statusreportrequest(const char* value, size_t size);
  inline ::std::string* mutable_cap_sm_statusreportrequest();
  inline ::std::string* release_cap_sm_statusreportrequest();
  
  // optional string CAP_SM_UserDataHeaderIndicator = 19 [default = ""];
  inline bool has_cap_sm_userdataheaderindicator() const;
  inline void clear_cap_sm_userdataheaderindicator();
  static const int kCAPSMUserDataHeaderIndicatorFieldNumber = 19;
  inline const ::std::string& cap_sm_userdataheaderindicator() const;
  inline void set_cap_sm_userdataheaderindicator(const ::std::string& value);
  inline void set_cap_sm_userdataheaderindicator(const char* value);
  inline void set_cap_sm_userdataheaderindicator(const char* value, size_t size);
  inline ::std::string* mutable_cap_sm_userdataheaderindicator();
  inline ::std::string* release_cap_sm_userdataheaderindicator();
  
  // optional string CAP_SM_ReplyPath = 20 [default = ""];
  inline bool has_cap_sm_replypath() const;
  inline void clear_cap_sm_replypath();
  static const int kCAPSMReplyPathFieldNumber = 20;
  inline const ::std::string& cap_sm_replypath() const;
  inline void set_cap_sm_replypath(const ::std::string& value);
  inline void set_cap_sm_replypath(const char* value);
  inline void set_cap_sm_replypath(const char* value, size_t size);
  inline ::std::string* mutable_cap_sm_replypath();
  inline ::std::string* release_cap_sm_replypath();
  
  // optional string CAP_SM_VPFormat = 21 [default = ""];
  inline bool has_cap_sm_vpformat() const;
  inline void clear_cap_sm_vpformat();
  static const int kCAPSMVPFormatFieldNumber = 21;
  inline const ::std::string& cap_sm_vpformat() const;
  inline void set_cap_sm_vpformat(const ::std::string& value);
  inline void set_cap_sm_vpformat(const char* value);
  inline void set_cap_sm_vpformat(const char* value, size_t size);
  inline ::std::string* mutable_cap_sm_vpformat();
  inline ::std::string* release_cap_sm_vpformat();
  
  // optional string CAP_SM_MessageTypeIndicator = 22 [default = ""];
  inline bool has_cap_sm_messagetypeindicator() const;
  inline void clear_cap_sm_messagetypeindicator();
  static const int kCAPSMMessageTypeIndicatorFieldNumber = 22;
  inline const ::std::string& cap_sm_messagetypeindicator() const;
  inline void set_cap_sm_messagetypeindicator(const ::std::string& value);
  inline void set_cap_sm_messagetypeindicator(const char* value);
  inline void set_cap_sm_messagetypeindicator(const char* value, size_t size);
  inline ::std::string* mutable_cap_sm_messagetypeindicator();
  inline ::std::string* release_cap_sm_messagetypeindicator();
  
  // optional string CAP_SM_ProtocolID = 23 [default = ""];
  inline bool has_cap_sm_protocolid() const;
  inline void clear_cap_sm_protocolid();
  static const int kCAPSMProtocolIDFieldNumber = 23;
  inline const ::std::string& cap_sm_protocolid() const;
  inline void set_cap_sm_protocolid(const ::std::string& value);
  inline void set_cap_sm_protocolid(const char* value);
  inline void set_cap_sm_protocolid(const char* value, size_t size);
  inline ::std::string* mutable_cap_sm_protocolid();
  inline ::std::string* release_cap_sm_protocolid();
  
  // optional string CAP_SM_DCS = 24 [default = ""];
  inline bool has_cap_sm_dcs() const;
  inline void clear_cap_sm_dcs();
  static const int kCAPSMDCSFieldNumber = 24;
  inline const ::std::string& cap_sm_dcs() const;
  inline void set_cap_sm_dcs(const ::std::string& value);
  inline void set_cap_sm_dcs(const char* value);
  inline void set_cap_sm_dcs(const char* value, size_t size);
  inline ::std::string* mutable_cap_sm_dcs();
  inline ::std::string* release_cap_sm_dcs();
  
  // optional string CAP_SM_ValidityPeriod = 25 [default = ""];
  inline bool has_cap_sm_validityperiod() const;
  inline void clear_cap_sm_validityperiod();
  static const int kCAPSMValidityPeriodFieldNumber = 25;
  inline const ::std::string& cap_sm_validityperiod() const;
  inline void set_cap_sm_validityperiod(const ::std::string& value);
  inline void set_cap_sm_validityperiod(const char* value);
  inline void set_cap_sm_validityperiod(const char* value, size_t size);
  inline ::std::string* mutable_cap_sm_validityperiod();
  inline ::std::string* release_cap_sm_validityperiod();
  
  // optional string CAP_SM_RejectDuplicate = 26 [default = ""];
  inline bool has_cap_sm_rejectduplicate() const;
  inline void clear_cap_sm_rejectduplicate();
  static const int kCAPSMRejectDuplicateFieldNumber = 26;
  inline const ::std::string& cap_sm_rejectduplicate() const;
  inline void set_cap_sm_rejectduplicate(const ::std::string& value);
  inline void set_cap_sm_rejectduplicate(const char* value);
  inline void set_cap_sm_rejectduplicate(const char* value, size_t size);
  inline ::std::string* mutable_cap_sm_rejectduplicate();
  inline ::std::string* release_cap_sm_rejectduplicate();
  
  // optional string CAP_SCCP_CallingGT = 27 [default = ""];
  inline bool has_cap_sccp_callinggt() const;
  inline void clear_cap_sccp_callinggt();
  static const int kCAPSCCPCallingGTFieldNumber = 27;
  inline const ::std::string& cap_sccp_callinggt() const;
  inline void set_cap_sccp_callinggt(const ::std::string& value);
  inline void set_cap_sccp_callinggt(const char* value);
  inline void set_cap_sccp_callinggt(const char* value, size_t size);
  inline ::std::string* mutable_cap_sccp_callinggt();
  inline ::std::string* release_cap_sccp_callinggt();
  
  // optional string CAP_SCCP_CalledGT = 28 [default = ""];
  inline bool has_cap_sccp_calledgt() const;
  inline void clear_cap_sccp_calledgt();
  static const int kCAPSCCPCalledGTFieldNumber = 28;
  inline const ::std::string& cap_sccp_calledgt() const;
  inline void set_cap_sccp_calledgt(const ::std::string& value);
  inline void set_cap_sccp_calledgt(const char* value);
  inline void set_cap_sccp_calledgt(const char* value, size_t size);
  inline ::std::string* mutable_cap_sccp_calledgt();
  inline ::std::string* release_cap_sccp_calledgt();
  
  // optional string CAP_TCAP_Remote_Transaction_Id = 29 [default = ""];
  inline bool has_cap_tcap_remote_transaction_id() const;
  inline void clear_cap_tcap_remote_transaction_id();
  static const int kCAPTCAPRemoteTransactionIdFieldNumber = 29;
  inline const ::std::string& cap_tcap_remote_transaction_id() const;
  inline void set_cap_tcap_remote_transaction_id(const ::std::string& value);
  inline void set_cap_tcap_remote_transaction_id(const char* value);
  inline void set_cap_tcap_remote_transaction_id(const char* value, size_t size);
  inline ::std::string* mutable_cap_tcap_remote_transaction_id();
  inline ::std::string* release_cap_tcap_remote_transaction_id();
  
  // optional string CAP_TCAP_Local_Transaction_Id = 30 [default = ""];
  inline bool has_cap_tcap_local_transaction_id() const;
  inline void clear_cap_tcap_local_transaction_id();
  static const int kCAPTCAPLocalTransactionIdFieldNumber = 30;
  inline const ::std::string& cap_tcap_local_transaction_id() const;
  inline void set_cap_tcap_local_transaction_id(const ::std::string& value);
  inline void set_cap_tcap_local_transaction_id(const char* value);
  inline void set_cap_tcap_local_transaction_id(const char* value, size_t size);
  inline ::std::string* mutable_cap_tcap_local_transaction_id();
  inline ::std::string* release_cap_tcap_local_transaction_id();
  
  // optional string CAP_CellID_AreaID_LAI = 31 [default = ""];
  inline bool has_cap_cellid_areaid_lai() const;
  inline void clear_cap_cellid_areaid_lai();
  static const int kCAPCellIDAreaIDLAIFieldNumber = 31;
  inline const ::std::string& cap_cellid_areaid_lai() const;
  inline void set_cap_cellid_areaid_lai(const ::std::string& value);
  inline void set_cap_cellid_areaid_lai(const char* value);
  inline void set_cap_cellid_areaid_lai(const char* value, size_t size);
  inline ::std::string* mutable_cap_cellid_areaid_lai();
  inline ::std::string* release_cap_cellid_areaid_lai();
  
  // optional uint32 CAP_Event_Type_SMS = 32 [default = 1000];
  inline bool has_cap_event_type_sms() const;
  inline void clear_cap_event_type_sms();
  static const int kCAPEventTypeSMSFieldNumber = 32;
  inline ::google::protobuf::uint32 cap_event_type_sms() const;
  inline void set_cap_event_type_sms(::google::protobuf::uint32 value);
  
  // optional uint32 CAP_TCAP_Error_Cause = 33 [default = 500];
  inline bool has_cap_tcap_error_cause() const;
  inline void clear_cap_tcap_error_cause();
  static const int kCAPTCAPErrorCauseFieldNumber = 33;
  inline ::google::protobuf::uint32 cap_tcap_error_cause() const;
  inline void set_cap_tcap_error_cause(::google::protobuf::uint32 value);
  
  // optional uint32 CAP_SCCP_Error_Cause = 34 [default = 0];
  inline bool has_cap_sccp_error_cause() const;
  inline void clear_cap_sccp_error_cause();
  static const int kCAPSCCPErrorCauseFieldNumber = 34;
  inline ::google::protobuf::uint32 cap_sccp_error_cause() const;
  inline void set_cap_sccp_error_cause(::google::protobuf::uint32 value);
  
  // optional string CAP_SMSpecificInfo = 35 [default = ""];
  inline bool has_cap_smspecificinfo() const;
  inline void clear_cap_smspecificinfo();
  static const int kCAPSMSpecificInfoFieldNumber = 35;
  inline const ::std::string& cap_smspecificinfo() const;
  inline void set_cap_smspecificinfo(const ::std::string& value);
  inline void set_cap_smspecificinfo(const char* value);
  inline void set_cap_smspecificinfo(const char* value, size_t size);
  inline ::std::string* mutable_cap_smspecificinfo();
  inline ::std::string* release_cap_smspecificinfo();
  
  // optional uint32 m_totalGSUCCService = 36 [default = 0];
  inline bool has_m_totalgsuccservice() const;
  inline void clear_m_totalgsuccservice();
  static const int kMTotalGSUCCServiceFieldNumber = 36;
  inline ::google::protobuf::uint32 m_totalgsuccservice() const;
  inline void set_m_totalgsuccservice(::google::protobuf::uint32 value);
  
  // optional uint32 m_totalUSUCCService = 37 [default = 0];
  inline bool has_m_totalusuccservice() const;
  inline void clear_m_totalusuccservice();
  static const int kMTotalUSUCCServiceFieldNumber = 37;
  inline ::google::protobuf::uint32 m_totalusuccservice() const;
  inline void set_m_totalusuccservice(::google::protobuf::uint32 value);
  
  // optional .SubscriptionIdConfig subscriptionIdInfo = 38;
  inline bool has_subscriptionidinfo() const;
  inline void clear_subscriptionidinfo();
  static const int kSubscriptionIdInfoFieldNumber = 38;
  inline const ::SubscriptionIdConfig& subscriptionidinfo() const;
  inline ::SubscriptionIdConfig* mutable_subscriptionidinfo();
  inline ::SubscriptionIdConfig* release_subscriptionidinfo();
  
  // @@protoc_insertion_point(class_scope:StoredIDPSMSToCCRIData)
 private:
  inline void set_has_calltypeval();
  inline void clear_has_calltypeval();
  inline void set_has_cap_service_key();
  inline void clear_has_cap_service_key();
  inline void set_has_cap_dialed_digits();
  inline void clear_has_cap_dialed_digits();
  inline void set_has_cap_called_ton();
  inline void clear_has_cap_called_ton();
  inline void set_has_cap_cli();
  inline void clear_has_cap_cli();
  inline void set_has_cap_location_number();
  inline void clear_has_cap_location_number();
  inline void set_has_cap_imsi();
  inline void clear_has_cap_imsi();
  inline void set_has_cap_vlr_number();
  inline void clear_has_cap_vlr_number();
  inline void set_has_cap_call_reference();
  inline void clear_has_cap_call_reference();
  inline void set_has_cap_msc_address();
  inline void clear_has_cap_msc_address();
  inline void set_has_cap_called_npi();
  inline void clear_has_cap_called_npi();
  inline void set_has_cap_calling_noa();
  inline void clear_has_cap_calling_noa();
  inline void set_has_cap_cli_npi();
  inline void clear_has_cap_cli_npi();
  inline void set_has_cap_version();
  inline void clear_has_cap_version();
  inline void set_has_cap_smsc_address();
  inline void clear_has_cap_smsc_address();
  inline void set_has_cap_sgsn_address();
  inline void clear_has_cap_sgsn_address();
  inline void set_has_cap_sm_imei();
  inline void clear_has_cap_sm_imei();
  inline void set_has_cap_sm_statusreportrequest();
  inline void clear_has_cap_sm_statusreportrequest();
  inline void set_has_cap_sm_userdataheaderindicator();
  inline void clear_has_cap_sm_userdataheaderindicator();
  inline void set_has_cap_sm_replypath();
  inline void clear_has_cap_sm_replypath();
  inline void set_has_cap_sm_vpformat();
  inline void clear_has_cap_sm_vpformat();
  inline void set_has_cap_sm_messagetypeindicator();
  inline void clear_has_cap_sm_messagetypeindicator();
  inline void set_has_cap_sm_protocolid();
  inline void clear_has_cap_sm_protocolid();
  inline void set_has_cap_sm_dcs();
  inline void clear_has_cap_sm_dcs();
  inline void set_has_cap_sm_validityperiod();
  inline void clear_has_cap_sm_validityperiod();
  inline void set_has_cap_sm_rejectduplicate();
  inline void clear_has_cap_sm_rejectduplicate();
  inline void set_has_cap_sccp_callinggt();
  inline void clear_has_cap_sccp_callinggt();
  inline void set_has_cap_sccp_calledgt();
  inline void clear_has_cap_sccp_calledgt();
  inline void set_has_cap_tcap_remote_transaction_id();
  inline void clear_has_cap_tcap_remote_transaction_id();
  inline void set_has_cap_tcap_local_transaction_id();
  inline void clear_has_cap_tcap_local_transaction_id();
  inline void set_has_cap_cellid_areaid_lai();
  inline void clear_has_cap_cellid_areaid_lai();
  inline void set_has_cap_event_type_sms();
  inline void clear_has_cap_event_type_sms();
  inline void set_has_cap_tcap_error_cause();
  inline void clear_has_cap_tcap_error_cause();
  inline void set_has_cap_sccp_error_cause();
  inline void clear_has_cap_sccp_error_cause();
  inline void set_has_cap_smspecificinfo();
  inline void clear_has_cap_smspecificinfo();
  inline void set_has_m_totalgsuccservice();
  inline void clear_has_m_totalgsuccservice();
  inline void set_has_m_totalusuccservice();
  inline void clear_has_m_totalusuccservice();
  inline void set_has_subscriptionidinfo();
  inline void clear_has_subscriptionidinfo();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 calltypeval_;
  ::google::protobuf::uint32 cap_service_key_;
  ::std::string* cap_dialed_digits_;
  ::std::string* cap_cli_;
  ::std::string* cap_location_number_;
  ::std::string* cap_imsi_;
  ::google::protobuf::uint32 cap_called_ton_;
  ::google::protobuf::uint32 cap_called_npi_;
  ::std::string* cap_vlr_number_;
  ::std::string* cap_call_reference_;
  ::std::string* cap_msc_address_;
  ::google::protobuf::uint32 cap_calling_noa_;
  ::google::protobuf::uint32 cap_cli_npi_;
  ::std::string* cap_smsc_address_;
  ::std::string* cap_sgsn_address_;
  ::std::string* cap_sm_imei_;
  ::std::string* cap_sm_statusreportrequest_;
  ::std::string* cap_sm_userdataheaderindicator_;
  ::std::string* cap_sm_replypath_;
  ::std::string* cap_sm_vpformat_;
  ::std::string* cap_sm_messagetypeindicator_;
  ::std::string* cap_sm_protocolid_;
  ::google::protobuf::uint32 cap_version_;
  ::google::protobuf::uint32 cap_event_type_sms_;
  ::std::string* cap_sm_dcs_;
  ::std::string* cap_sm_validityperiod_;
  ::std::string* cap_sm_rejectduplicate_;
  ::std::string* cap_sccp_callinggt_;
  ::std::string* cap_sccp_calledgt_;
  ::std::string* cap_tcap_remote_transaction_id_;
  ::std::string* cap_tcap_local_transaction_id_;
  ::std::string* cap_cellid_areaid_lai_;
  ::google::protobuf::uint32 cap_tcap_error_cause_;
  ::google::protobuf::uint32 cap_sccp_error_cause_;
  ::std::string* cap_smspecificinfo_;
  ::google::protobuf::uint32 m_totalgsuccservice_;
  ::google::protobuf::uint32 m_totalusuccservice_;
  ::SubscriptionIdConfig* subscriptionidinfo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(38 + 31) / 32];
  
  friend void  protobuf_AddDesc_iwf_2eproto();
  friend void protobuf_AssignDesc_iwf_2eproto();
  friend void protobuf_ShutdownFile_iwf_2eproto();
  
  void InitAsDefaultInstance();
  static StoredIDPSMSToCCRIData* default_instance_;
};
// -------------------------------------------------------------------

class IDPToCCRIData : public ::google::protobuf::Message {
 public:
  IDPToCCRIData();
  virtual ~IDPToCCRIData();
  
  IDPToCCRIData(const IDPToCCRIData& from);
  
  inline IDPToCCRIData& operator=(const IDPToCCRIData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const IDPToCCRIData& default_instance();
  
  void Swap(IDPToCCRIData* other);
  
  // implements Message ----------------------------------------------
  
  IDPToCCRIData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IDPToCCRIData& from);
  void MergeFrom(const IDPToCCRIData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 callTypeVal = 1 [default = 0];
  inline bool has_calltypeval() const;
  inline void clear_calltypeval();
  static const int kCallTypeValFieldNumber = 1;
  inline ::google::protobuf::uint32 calltypeval() const;
  inline void set_calltypeval(::google::protobuf::uint32 value);
  
  // optional uint32 Service_Key = 2 [default = 0];
  inline bool has_service_key() const;
  inline void clear_service_key();
  static const int kServiceKeyFieldNumber = 2;
  inline ::google::protobuf::uint32 service_key() const;
  inline void set_service_key(::google::protobuf::uint32 value);
  
  // optional bytes Dialed_Digits = 3 [default = ""];
  inline bool has_dialed_digits() const;
  inline void clear_dialed_digits();
  static const int kDialedDigitsFieldNumber = 3;
  inline const ::std::string& dialed_digits() const;
  inline void set_dialed_digits(const ::std::string& value);
  inline void set_dialed_digits(const char* value);
  inline void set_dialed_digits(const void* value, size_t size);
  inline ::std::string* mutable_dialed_digits();
  inline ::std::string* release_dialed_digits();
  
  // optional uint32 Called_TON = 4 [default = 1000];
  inline bool has_called_ton() const;
  inline void clear_called_ton();
  static const int kCalledTONFieldNumber = 4;
  inline ::google::protobuf::uint32 called_ton() const;
  inline void set_called_ton(::google::protobuf::uint32 value);
  
  // optional bytes CLI = 5 [default = ""];
  inline bool has_cli() const;
  inline void clear_cli();
  static const int kCLIFieldNumber = 5;
  inline const ::std::string& cli() const;
  inline void set_cli(const ::std::string& value);
  inline void set_cli(const char* value);
  inline void set_cli(const void* value, size_t size);
  inline ::std::string* mutable_cli();
  inline ::std::string* release_cli();
  
  // optional uint32 Calling_Category = 6 [default = 1000];
  inline bool has_calling_category() const;
  inline void clear_calling_category();
  static const int kCallingCategoryFieldNumber = 6;
  inline ::google::protobuf::uint32 calling_category() const;
  inline void set_calling_category(::google::protobuf::uint32 value);
  
  // optional bytes Location_Number = 7 [default = ""];
  inline bool has_location_number() const;
  inline void clear_location_number();
  static const int kLocationNumberFieldNumber = 7;
  inline const ::std::string& location_number() const;
  inline void set_location_number(const ::std::string& value);
  inline void set_location_number(const char* value);
  inline void set_location_number(const void* value, size_t size);
  inline ::std::string* mutable_location_number();
  inline ::std::string* release_location_number();
  
  // optional bytes Redirecting_Number = 8 [default = ""];
  inline bool has_redirecting_number() const;
  inline void clear_redirecting_number();
  static const int kRedirectingNumberFieldNumber = 8;
  inline const ::std::string& redirecting_number() const;
  inline void set_redirecting_number(const ::std::string& value);
  inline void set_redirecting_number(const char* value);
  inline void set_redirecting_number(const void* value, size_t size);
  inline ::std::string* mutable_redirecting_number();
  inline ::std::string* release_redirecting_number();
  
  // optional uint32 Redirecting_Indicator = 9 [default = 1000];
  inline bool has_redirecting_indicator() const;
  inline void clear_redirecting_indicator();
  static const int kRedirectingIndicatorFieldNumber = 9;
  inline ::google::protobuf::uint32 redirecting_indicator() const;
  inline void set_redirecting_indicator(::google::protobuf::uint32 value);
  
  // optional uint32 Original_Redirecting_Reason = 10 [default = 1000];
  inline bool has_original_redirecting_reason() const;
  inline void clear_original_redirecting_reason();
  static const int kOriginalRedirectingReasonFieldNumber = 10;
  inline ::google::protobuf::uint32 original_redirecting_reason() const;
  inline void set_original_redirecting_reason(::google::protobuf::uint32 value);
  
  // optional uint32 Redirection_Counter = 11 [default = 1000];
  inline bool has_redirection_counter() const;
  inline void clear_redirection_counter();
  static const int kRedirectionCounterFieldNumber = 11;
  inline ::google::protobuf::uint32 redirection_counter() const;
  inline void set_redirection_counter(::google::protobuf::uint32 value);
  
  // optional uint32 Redirecting_Reason = 12 [default = 1000];
  inline bool has_redirecting_reason() const;
  inline void clear_redirecting_reason();
  static const int kRedirectingReasonFieldNumber = 12;
  inline ::google::protobuf::uint32 redirecting_reason() const;
  inline void set_redirecting_reason(::google::protobuf::uint32 value);
  
  // optional bytes IMSI = 13 [default = ""];
  inline bool has_imsi() const;
  inline void clear_imsi();
  static const int kIMSIFieldNumber = 13;
  inline const ::std::string& imsi() const;
  inline void set_imsi(const ::std::string& value);
  inline void set_imsi(const char* value);
  inline void set_imsi(const void* value, size_t size);
  inline ::std::string* mutable_imsi();
  inline ::std::string* release_imsi();
  
  // optional bytes VLR_Number = 14 [default = ""];
  inline bool has_vlr_number() const;
  inline void clear_vlr_number();
  static const int kVLRNumberFieldNumber = 14;
  inline const ::std::string& vlr_number() const;
  inline void set_vlr_number(const ::std::string& value);
  inline void set_vlr_number(const char* value);
  inline void set_vlr_number(const void* value, size_t size);
  inline ::std::string* mutable_vlr_number();
  inline ::std::string* release_vlr_number();
  
  // optional bytes Call_Reference = 15 [default = ""];
  inline bool has_call_reference() const;
  inline void clear_call_reference();
  static const int kCallReferenceFieldNumber = 15;
  inline const ::std::string& call_reference() const;
  inline void set_call_reference(const ::std::string& value);
  inline void set_call_reference(const char* value);
  inline void set_call_reference(const void* value, size_t size);
  inline ::std::string* mutable_call_reference();
  inline ::std::string* release_call_reference();
  
  // optional bytes MSC_Address = 16 [default = ""];
  inline bool has_msc_address() const;
  inline void clear_msc_address();
  static const int kMSCAddressFieldNumber = 16;
  inline const ::std::string& msc_address() const;
  inline void set_msc_address(const ::std::string& value);
  inline void set_msc_address(const char* value);
  inline void set_msc_address(const void* value, size_t size);
  inline ::std::string* mutable_msc_address();
  inline ::std::string* release_msc_address();
  
  // optional uint32 Called_NPI = 17 [default = 1000];
  inline bool has_called_npi() const;
  inline void clear_called_npi();
  static const int kCalledNPIFieldNumber = 17;
  inline ::google::protobuf::uint32 called_npi() const;
  inline void set_called_npi(::google::protobuf::uint32 value);
  
  // optional uint32 Calling_NOA = 18 [default = 1000];
  inline bool has_calling_noa() const;
  inline void clear_calling_noa();
  static const int kCallingNOAFieldNumber = 18;
  inline ::google::protobuf::uint32 calling_noa() const;
  inline void set_calling_noa(::google::protobuf::uint32 value);
  
  // optional uint32 CLI_NPI = 19 [default = 1000];
  inline bool has_cli_npi() const;
  inline void clear_cli_npi();
  static const int kCLINPIFieldNumber = 19;
  inline ::google::protobuf::uint32 cli_npi() const;
  inline void set_cli_npi(::google::protobuf::uint32 value);
  
  // optional uint32 CLIR = 20 [default = 1000];
  inline bool has_clir() const;
  inline void clear_clir();
  static const int kCLIRFieldNumber = 20;
  inline ::google::protobuf::uint32 clir() const;
  inline void set_clir(::google::protobuf::uint32 value);
  
  // optional uint32 Version = 21 [default = 1000];
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 21;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);
  
  // optional bytes SCCP_CallingGT = 22 [default = ""];
  inline bool has_sccp_callinggt() const;
  inline void clear_sccp_callinggt();
  static const int kSCCPCallingGTFieldNumber = 22;
  inline const ::std::string& sccp_callinggt() const;
  inline void set_sccp_callinggt(const ::std::string& value);
  inline void set_sccp_callinggt(const char* value);
  inline void set_sccp_callinggt(const void* value, size_t size);
  inline ::std::string* mutable_sccp_callinggt();
  inline ::std::string* release_sccp_callinggt();
  
  // optional bytes SCCP_CalledGT = 23 [default = ""];
  inline bool has_sccp_calledgt() const;
  inline void clear_sccp_calledgt();
  static const int kSCCPCalledGTFieldNumber = 23;
  inline const ::std::string& sccp_calledgt() const;
  inline void set_sccp_calledgt(const ::std::string& value);
  inline void set_sccp_calledgt(const char* value);
  inline void set_sccp_calledgt(const void* value, size_t size);
  inline ::std::string* mutable_sccp_calledgt();
  inline ::std::string* release_sccp_calledgt();
  
  // optional uint32 GSM_Forwarding_Pending = 24 [default = 1000];
  inline bool has_gsm_forwarding_pending() const;
  inline void clear_gsm_forwarding_pending();
  static const int kGSMForwardingPendingFieldNumber = 24;
  inline ::google::protobuf::uint32 gsm_forwarding_pending() const;
  inline void set_gsm_forwarding_pending(::google::protobuf::uint32 value);
  
  // optional bytes TCAP_Remote_Transaction_Id = 25 [default = ""];
  inline bool has_tcap_remote_transaction_id() const;
  inline void clear_tcap_remote_transaction_id();
  static const int kTCAPRemoteTransactionIdFieldNumber = 25;
  inline const ::std::string& tcap_remote_transaction_id() const;
  inline void set_tcap_remote_transaction_id(const ::std::string& value);
  inline void set_tcap_remote_transaction_id(const char* value);
  inline void set_tcap_remote_transaction_id(const void* value, size_t size);
  inline ::std::string* mutable_tcap_remote_transaction_id();
  inline ::std::string* release_tcap_remote_transaction_id();
  
  // optional bytes TCAP_Local_Transaction_Id = 26 [default = ""];
  inline bool has_tcap_local_transaction_id() const;
  inline void clear_tcap_local_transaction_id();
  static const int kTCAPLocalTransactionIdFieldNumber = 26;
  inline const ::std::string& tcap_local_transaction_id() const;
  inline void set_tcap_local_transaction_id(const ::std::string& value);
  inline void set_tcap_local_transaction_id(const char* value);
  inline void set_tcap_local_transaction_id(const void* value, size_t size);
  inline ::std::string* mutable_tcap_local_transaction_id();
  inline ::std::string* release_tcap_local_transaction_id();
  
  // optional bytes CellID_AreaID_LAI = 27 [default = ""];
  inline bool has_cellid_areaid_lai() const;
  inline void clear_cellid_areaid_lai();
  static const int kCellIDAreaIDLAIFieldNumber = 27;
  inline const ::std::string& cellid_areaid_lai() const;
  inline void set_cellid_areaid_lai(const ::std::string& value);
  inline void set_cellid_areaid_lai(const char* value);
  inline void set_cellid_areaid_lai(const void* value, size_t size);
  inline ::std::string* mutable_cellid_areaid_lai();
  inline ::std::string* release_cellid_areaid_lai();
  
  // optional uint32 Event_Type_BCSM = 28 [default = 1000];
  inline bool has_event_type_bcsm() const;
  inline void clear_event_type_bcsm();
  static const int kEventTypeBCSMFieldNumber = 28;
  inline ::google::protobuf::uint32 event_type_bcsm() const;
  inline void set_event_type_bcsm(::google::protobuf::uint32 value);
  
  // optional uint32 TCAP_Error_Cause = 29 [default = 500];
  inline bool has_tcap_error_cause() const;
  inline void clear_tcap_error_cause();
  static const int kTCAPErrorCauseFieldNumber = 29;
  inline ::google::protobuf::uint32 tcap_error_cause() const;
  inline void set_tcap_error_cause(::google::protobuf::uint32 value);
  
  // optional uint32 SCCP_Error_Cause = 30 [default = 0];
  inline bool has_sccp_error_cause() const;
  inline void clear_sccp_error_cause();
  static const int kSCCPErrorCauseFieldNumber = 30;
  inline ::google::protobuf::uint32 sccp_error_cause() const;
  inline void set_sccp_error_cause(::google::protobuf::uint32 value);
  
  // optional bytes GMSC = 31 [default = ""];
  inline bool has_gmsc() const;
  inline void clear_gmsc();
  static const int kGMSCFieldNumber = 31;
  inline const ::std::string& gmsc() const;
  inline void set_gmsc(const ::std::string& value);
  inline void set_gmsc(const char* value);
  inline void set_gmsc(const void* value, size_t size);
  inline ::std::string* mutable_gmsc();
  inline ::std::string* release_gmsc();
  
  // optional bytes Ext_Basic_Service_Code = 32 [default = ""];
  inline bool has_ext_basic_service_code() const;
  inline void clear_ext_basic_service_code();
  static const int kExtBasicServiceCodeFieldNumber = 32;
  inline const ::std::string& ext_basic_service_code() const;
  inline void set_ext_basic_service_code(const ::std::string& value);
  inline void set_ext_basic_service_code(const char* value);
  inline void set_ext_basic_service_code(const void* value, size_t size);
  inline ::std::string* mutable_ext_basic_service_code();
  inline ::std::string* release_ext_basic_service_code();
  
  // optional bytes Bearer_Capability = 33 [default = ""];
  inline bool has_bearer_capability() const;
  inline void clear_bearer_capability();
  static const int kBearerCapabilityFieldNumber = 33;
  inline const ::std::string& bearer_capability() const;
  inline void set_bearer_capability(const ::std::string& value);
  inline void set_bearer_capability(const char* value);
  inline void set_bearer_capability(const void* value, size_t size);
  inline ::std::string* mutable_bearer_capability();
  inline ::std::string* release_bearer_capability();
  
  // optional bytes Bearer_Capability_Transfer = 34 [default = ""];
  inline bool has_bearer_capability_transfer() const;
  inline void clear_bearer_capability_transfer();
  static const int kBearerCapabilityTransferFieldNumber = 34;
  inline const ::std::string& bearer_capability_transfer() const;
  inline void set_bearer_capability_transfer(const ::std::string& value);
  inline void set_bearer_capability_transfer(const char* value);
  inline void set_bearer_capability_transfer(const void* value, size_t size);
  inline ::std::string* mutable_bearer_capability_transfer();
  inline ::std::string* release_bearer_capability_transfer();
  
  // optional bytes Bearer_Capability_Transfer_Rate = 35 [default = ""];
  inline bool has_bearer_capability_transfer_rate() const;
  inline void clear_bearer_capability_transfer_rate();
  static const int kBearerCapabilityTransferRateFieldNumber = 35;
  inline const ::std::string& bearer_capability_transfer_rate() const;
  inline void set_bearer_capability_transfer_rate(const ::std::string& value);
  inline void set_bearer_capability_transfer_rate(const char* value);
  inline void set_bearer_capability_transfer_rate(const void* value, size_t size);
  inline ::std::string* mutable_bearer_capability_transfer_rate();
  inline ::std::string* release_bearer_capability_transfer_rate();
  
  // optional bytes Bearer_Capability_Transfer_Mode = 36 [default = ""];
  inline bool has_bearer_capability_transfer_mode() const;
  inline void clear_bearer_capability_transfer_mode();
  static const int kBearerCapabilityTransferModeFieldNumber = 36;
  inline const ::std::string& bearer_capability_transfer_mode() const;
  inline void set_bearer_capability_transfer_mode(const ::std::string& value);
  inline void set_bearer_capability_transfer_mode(const char* value);
  inline void set_bearer_capability_transfer_mode(const void* value, size_t size);
  inline ::std::string* mutable_bearer_capability_transfer_mode();
  inline ::std::string* release_bearer_capability_transfer_mode();
  
  // optional bytes Bearer_Capability_Cdr = 37 [default = ""];
  inline bool has_bearer_capability_cdr() const;
  inline void clear_bearer_capability_cdr();
  static const int kBearerCapabilityCdrFieldNumber = 37;
  inline const ::std::string& bearer_capability_cdr() const;
  inline void set_bearer_capability_cdr(const ::std::string& value);
  inline void set_bearer_capability_cdr(const char* value);
  inline void set_bearer_capability_cdr(const void* value, size_t size);
  inline ::std::string* mutable_bearer_capability_cdr();
  inline ::std::string* release_bearer_capability_cdr();
  
  // optional bool CAPIsFollowingOn = 38 [default = false];
  inline bool has_capisfollowingon() const;
  inline void clear_capisfollowingon();
  static const int kCAPIsFollowingOnFieldNumber = 38;
  inline bool capisfollowingon() const;
  inline void set_capisfollowingon(bool value);
  
  // optional .SubscriptionIdConfig subscriptionIdInfo = 39;
  inline bool has_subscriptionidinfo() const;
  inline void clear_subscriptionidinfo();
  static const int kSubscriptionIdInfoFieldNumber = 39;
  inline const ::SubscriptionIdConfig& subscriptionidinfo() const;
  inline ::SubscriptionIdConfig* mutable_subscriptionidinfo();
  inline ::SubscriptionIdConfig* release_subscriptionidinfo();
  
  // @@protoc_insertion_point(class_scope:IDPToCCRIData)
 private:
  inline void set_has_calltypeval();
  inline void clear_has_calltypeval();
  inline void set_has_service_key();
  inline void clear_has_service_key();
  inline void set_has_dialed_digits();
  inline void clear_has_dialed_digits();
  inline void set_has_called_ton();
  inline void clear_has_called_ton();
  inline void set_has_cli();
  inline void clear_has_cli();
  inline void set_has_calling_category();
  inline void clear_has_calling_category();
  inline void set_has_location_number();
  inline void clear_has_location_number();
  inline void set_has_redirecting_number();
  inline void clear_has_redirecting_number();
  inline void set_has_redirecting_indicator();
  inline void clear_has_redirecting_indicator();
  inline void set_has_original_redirecting_reason();
  inline void clear_has_original_redirecting_reason();
  inline void set_has_redirection_counter();
  inline void clear_has_redirection_counter();
  inline void set_has_redirecting_reason();
  inline void clear_has_redirecting_reason();
  inline void set_has_imsi();
  inline void clear_has_imsi();
  inline void set_has_vlr_number();
  inline void clear_has_vlr_number();
  inline void set_has_call_reference();
  inline void clear_has_call_reference();
  inline void set_has_msc_address();
  inline void clear_has_msc_address();
  inline void set_has_called_npi();
  inline void clear_has_called_npi();
  inline void set_has_calling_noa();
  inline void clear_has_calling_noa();
  inline void set_has_cli_npi();
  inline void clear_has_cli_npi();
  inline void set_has_clir();
  inline void clear_has_clir();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_sccp_callinggt();
  inline void clear_has_sccp_callinggt();
  inline void set_has_sccp_calledgt();
  inline void clear_has_sccp_calledgt();
  inline void set_has_gsm_forwarding_pending();
  inline void clear_has_gsm_forwarding_pending();
  inline void set_has_tcap_remote_transaction_id();
  inline void clear_has_tcap_remote_transaction_id();
  inline void set_has_tcap_local_transaction_id();
  inline void clear_has_tcap_local_transaction_id();
  inline void set_has_cellid_areaid_lai();
  inline void clear_has_cellid_areaid_lai();
  inline void set_has_event_type_bcsm();
  inline void clear_has_event_type_bcsm();
  inline void set_has_tcap_error_cause();
  inline void clear_has_tcap_error_cause();
  inline void set_has_sccp_error_cause();
  inline void clear_has_sccp_error_cause();
  inline void set_has_gmsc();
  inline void clear_has_gmsc();
  inline void set_has_ext_basic_service_code();
  inline void clear_has_ext_basic_service_code();
  inline void set_has_bearer_capability();
  inline void clear_has_bearer_capability();
  inline void set_has_bearer_capability_transfer();
  inline void clear_has_bearer_capability_transfer();
  inline void set_has_bearer_capability_transfer_rate();
  inline void clear_has_bearer_capability_transfer_rate();
  inline void set_has_bearer_capability_transfer_mode();
  inline void clear_has_bearer_capability_transfer_mode();
  inline void set_has_bearer_capability_cdr();
  inline void clear_has_bearer_capability_cdr();
  inline void set_has_capisfollowingon();
  inline void clear_has_capisfollowingon();
  inline void set_has_subscriptionidinfo();
  inline void clear_has_subscriptionidinfo();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 calltypeval_;
  ::google::protobuf::uint32 service_key_;
  ::std::string* dialed_digits_;
  ::std::string* cli_;
  ::google::protobuf::uint32 called_ton_;
  ::google::protobuf::uint32 calling_category_;
  ::std::string* location_number_;
  ::std::string* redirecting_number_;
  ::google::protobuf::uint32 redirecting_indicator_;
  ::google::protobuf::uint32 original_redirecting_reason_;
  ::google::protobuf::uint32 redirection_counter_;
  ::google::protobuf::uint32 redirecting_reason_;
  ::std::string* imsi_;
  ::std::string* vlr_number_;
  ::std::string* call_reference_;
  ::std::string* msc_address_;
  ::google::protobuf::uint32 called_npi_;
  ::google::protobuf::uint32 calling_noa_;
  ::google::protobuf::uint32 cli_npi_;
  ::google::protobuf::uint32 clir_;
  ::std::string* sccp_callinggt_;
  ::google::protobuf::uint32 version_;
  ::google::protobuf::uint32 gsm_forwarding_pending_;
  ::std::string* sccp_calledgt_;
  ::std::string* tcap_remote_transaction_id_;
  ::std::string* tcap_local_transaction_id_;
  ::std::string* cellid_areaid_lai_;
  ::google::protobuf::uint32 event_type_bcsm_;
  ::google::protobuf::uint32 tcap_error_cause_;
  ::std::string* gmsc_;
  ::std::string* ext_basic_service_code_;
  ::std::string* bearer_capability_;
  ::std::string* bearer_capability_transfer_;
  ::google::protobuf::uint32 sccp_error_cause_;
  bool capisfollowingon_;
  ::std::string* bearer_capability_transfer_rate_;
  ::std::string* bearer_capability_transfer_mode_;
  ::std::string* bearer_capability_cdr_;
  ::SubscriptionIdConfig* subscriptionidinfo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(39 + 31) / 32];
  
  friend void  protobuf_AddDesc_iwf_2eproto();
  friend void protobuf_AssignDesc_iwf_2eproto();
  friend void protobuf_ShutdownFile_iwf_2eproto();
  
  void InitAsDefaultInstance();
  static IDPToCCRIData* default_instance_;
};
// -------------------------------------------------------------------

class pbERBData : public ::google::protobuf::Message {
 public:
  pbERBData();
  virtual ~pbERBData();
  
  pbERBData(const pbERBData& from);
  
  inline pbERBData& operator=(const pbERBData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const pbERBData& default_instance();
  
  void Swap(pbERBData* other);
  
  // implements Message ----------------------------------------------
  
  pbERBData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pbERBData& from);
  void MergeFrom(const pbERBData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 erbRecvEvtType = 1 [default = 0];
  inline bool has_erbrecvevttype() const;
  inline void clear_erbrecvevttype();
  static const int kErbRecvEvtTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 erbrecvevttype() const;
  inline void set_erbrecvevttype(::google::protobuf::uint32 value);
  
  // optional string eventSpecInfo = 2 [default = ""];
  inline bool has_eventspecinfo() const;
  inline void clear_eventspecinfo();
  static const int kEventSpecInfoFieldNumber = 2;
  inline const ::std::string& eventspecinfo() const;
  inline void set_eventspecinfo(const ::std::string& value);
  inline void set_eventspecinfo(const char* value);
  inline void set_eventspecinfo(const char* value, size_t size);
  inline ::std::string* mutable_eventspecinfo();
  inline ::std::string* release_eventspecinfo();
  
  // optional uint32 recvlegId = 3 [default = 0];
  inline bool has_recvlegid() const;
  inline void clear_recvlegid();
  static const int kRecvlegIdFieldNumber = 3;
  inline ::google::protobuf::uint32 recvlegid() const;
  inline void set_recvlegid(::google::protobuf::uint32 value);
  
  // optional uint32 msgType = 4 [default = 0];
  inline bool has_msgtype() const;
  inline void clear_msgtype();
  static const int kMsgTypeFieldNumber = 4;
  inline ::google::protobuf::uint32 msgtype() const;
  inline void set_msgtype(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:pbERBData)
 private:
  inline void set_has_erbrecvevttype();
  inline void clear_has_erbrecvevttype();
  inline void set_has_eventspecinfo();
  inline void clear_has_eventspecinfo();
  inline void set_has_recvlegid();
  inline void clear_has_recvlegid();
  inline void set_has_msgtype();
  inline void clear_has_msgtype();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* eventspecinfo_;
  ::google::protobuf::uint32 erbrecvevttype_;
  ::google::protobuf::uint32 recvlegid_;
  ::google::protobuf::uint32 msgtype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_iwf_2eproto();
  friend void protobuf_AssignDesc_iwf_2eproto();
  friend void protobuf_ShutdownFile_iwf_2eproto();
  
  void InitAsDefaultInstance();
  static pbERBData* default_instance_;
};
// -------------------------------------------------------------------

class pbActivityTimerData : public ::google::protobuf::Message {
 public:
  pbActivityTimerData();
  virtual ~pbActivityTimerData();
  
  pbActivityTimerData(const pbActivityTimerData& from);
  
  inline pbActivityTimerData& operator=(const pbActivityTimerData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const pbActivityTimerData& default_instance();
  
  void Swap(pbActivityTimerData* other);
  
  // implements Message ----------------------------------------------
  
  pbActivityTimerData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pbActivityTimerData& from);
  void MergeFrom(const pbActivityTimerData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 atTimer = 1 [default = 0];
  inline bool has_attimer() const;
  inline void clear_attimer();
  static const int kAtTimerFieldNumber = 1;
  inline ::google::protobuf::uint32 attimer() const;
  inline void set_attimer(::google::protobuf::uint32 value);
  
  // optional uint32 responseTimeout = 2 [default = 0];
  inline bool has_responsetimeout() const;
  inline void clear_responsetimeout();
  static const int kResponseTimeoutFieldNumber = 2;
  inline ::google::protobuf::uint32 responsetimeout() const;
  inline void set_responsetimeout(::google::protobuf::uint32 value);
  
  // optional uint32 retryCount = 3 [default = 0];
  inline bool has_retrycount() const;
  inline void clear_retrycount();
  static const int kRetryCountFieldNumber = 3;
  inline ::google::protobuf::uint32 retrycount() const;
  inline void set_retrycount(::google::protobuf::uint32 value);
  
  // optional uint32 invokeId = 4 [default = 0];
  inline bool has_invokeid() const;
  inline void clear_invokeid();
  static const int kInvokeIdFieldNumber = 4;
  inline ::google::protobuf::uint32 invokeid() const;
  inline void set_invokeid(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:pbActivityTimerData)
 private:
  inline void set_has_attimer();
  inline void clear_has_attimer();
  inline void set_has_responsetimeout();
  inline void clear_has_responsetimeout();
  inline void set_has_retrycount();
  inline void clear_has_retrycount();
  inline void set_has_invokeid();
  inline void clear_has_invokeid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 attimer_;
  ::google::protobuf::uint32 responsetimeout_;
  ::google::protobuf::uint32 retrycount_;
  ::google::protobuf::uint32 invokeid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_iwf_2eproto();
  friend void protobuf_AssignDesc_iwf_2eproto();
  friend void protobuf_ShutdownFile_iwf_2eproto();
  
  void InitAsDefaultInstance();
  static pbActivityTimerData* default_instance_;
};
// -------------------------------------------------------------------

class pbIwfDccaSessionCtxt : public ::google::protobuf::Message {
 public:
  pbIwfDccaSessionCtxt();
  virtual ~pbIwfDccaSessionCtxt();
  
  pbIwfDccaSessionCtxt(const pbIwfDccaSessionCtxt& from);
  
  inline pbIwfDccaSessionCtxt& operator=(const pbIwfDccaSessionCtxt& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const pbIwfDccaSessionCtxt& default_instance();
  
  void Swap(pbIwfDccaSessionCtxt* other);
  
  // implements Message ----------------------------------------------
  
  pbIwfDccaSessionCtxt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pbIwfDccaSessionCtxt& from);
  void MergeFrom(const pbIwfDccaSessionCtxt& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 DccaState = 1 [default = 0];
  inline bool has_dccastate() const;
  inline void clear_dccastate();
  static const int kDccaStateFieldNumber = 1;
  inline ::google::protobuf::uint32 dccastate() const;
  inline void set_dccastate(::google::protobuf::uint32 value);
  
  // optional string destHost = 2;
  inline bool has_desthost() const;
  inline void clear_desthost();
  static const int kDestHostFieldNumber = 2;
  inline const ::std::string& desthost() const;
  inline void set_desthost(const ::std::string& value);
  inline void set_desthost(const char* value);
  inline void set_desthost(const char* value, size_t size);
  inline ::std::string* mutable_desthost();
  inline ::std::string* release_desthost();
  
  // optional string destRealm = 3;
  inline bool has_destrealm() const;
  inline void clear_destrealm();
  static const int kDestRealmFieldNumber = 3;
  inline const ::std::string& destrealm() const;
  inline void set_destrealm(const ::std::string& value);
  inline void set_destrealm(const char* value);
  inline void set_destrealm(const char* value, size_t size);
  inline ::std::string* mutable_destrealm();
  inline ::std::string* release_destrealm();
  
  // optional uint32 IwfCCFHAction = 4;
  inline bool has_iwfccfhaction() const;
  inline void clear_iwfccfhaction();
  static const int kIwfCCFHActionFieldNumber = 4;
  inline ::google::protobuf::uint32 iwfccfhaction() const;
  inline void set_iwfccfhaction(::google::protobuf::uint32 value);
  
  // optional bool isFailoverSupported = 5 [default = true];
  inline bool has_isfailoversupported() const;
  inline void clear_isfailoversupported();
  static const int kIsFailoverSupportedFieldNumber = 5;
  inline bool isfailoversupported() const;
  inline void set_isfailoversupported(bool value);
  
  // optional bool isDone = 6 [default = false];
  inline bool has_isdone() const;
  inline void clear_isdone();
  static const int kIsDoneFieldNumber = 6;
  inline bool isdone() const;
  inline void set_isdone(bool value);
  
  // optional uint32 retryCount = 7 [default = 0];
  inline bool has_retrycount() const;
  inline void clear_retrycount();
  static const int kRetryCountFieldNumber = 7;
  inline ::google::protobuf::uint32 retrycount() const;
  inline void set_retrycount(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:pbIwfDccaSessionCtxt)
 private:
  inline void set_has_dccastate();
  inline void clear_has_dccastate();
  inline void set_has_desthost();
  inline void clear_has_desthost();
  inline void set_has_destrealm();
  inline void clear_has_destrealm();
  inline void set_has_iwfccfhaction();
  inline void clear_has_iwfccfhaction();
  inline void set_has_isfailoversupported();
  inline void clear_has_isfailoversupported();
  inline void set_has_isdone();
  inline void clear_has_isdone();
  inline void set_has_retrycount();
  inline void clear_has_retrycount();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* desthost_;
  ::google::protobuf::uint32 dccastate_;
  ::google::protobuf::uint32 iwfccfhaction_;
  ::std::string* destrealm_;
  bool isfailoversupported_;
  bool isdone_;
  ::google::protobuf::uint32 retrycount_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_iwf_2eproto();
  friend void protobuf_AssignDesc_iwf_2eproto();
  friend void protobuf_ShutdownFile_iwf_2eproto();
  
  void InitAsDefaultInstance();
  static pbIwfDccaSessionCtxt* default_instance_;
};
// -------------------------------------------------------------------

class pbConnectArgData : public ::google::protobuf::Message {
 public:
  pbConnectArgData();
  virtual ~pbConnectArgData();
  
  pbConnectArgData(const pbConnectArgData& from);
  
  inline pbConnectArgData& operator=(const pbConnectArgData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const pbConnectArgData& default_instance();
  
  void Swap(pbConnectArgData* other);
  
  // implements Message ----------------------------------------------
  
  pbConnectArgData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pbConnectArgData& from);
  void MergeFrom(const pbConnectArgData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bool hasServiceControl = 1 [default = false];
  inline bool has_hasservicecontrol() const;
  inline void clear_hasservicecontrol();
  static const int kHasServiceControlFieldNumber = 1;
  inline bool hasservicecontrol() const;
  inline void set_hasservicecontrol(bool value);
  
  // optional bool hasCapInfo = 2 [default = false];
  inline bool has_hascapinfo() const;
  inline void clear_hascapinfo();
  static const int kHasCapInfoFieldNumber = 2;
  inline bool hascapinfo() const;
  inline void set_hascapinfo(bool value);
  
  // optional bool hasCapConnectInfo = 3 [default = false];
  inline bool has_hascapconnectinfo() const;
  inline void clear_hascapconnectinfo();
  static const int kHasCapConnectInfoFieldNumber = 3;
  inline bool hascapconnectinfo() const;
  inline void set_hascapconnectinfo(bool value);
  
  // optional string capAnncAccessNo = 4;
  inline bool has_capanncaccessno() const;
  inline void clear_capanncaccessno();
  static const int kCapAnncAccessNoFieldNumber = 4;
  inline const ::std::string& capanncaccessno() const;
  inline void set_capanncaccessno(const ::std::string& value);
  inline void set_capanncaccessno(const char* value);
  inline void set_capanncaccessno(const char* value, size_t size);
  inline ::std::string* mutable_capanncaccessno();
  inline ::std::string* release_capanncaccessno();
  
  // optional uint32 capConnAnncNoNatrue = 5;
  inline bool has_capconnanncnonatrue() const;
  inline void clear_capconnanncnonatrue();
  static const int kCapConnAnncNoNatrueFieldNumber = 5;
  inline ::google::protobuf::uint32 capconnanncnonatrue() const;
  inline void set_capconnanncnonatrue(::google::protobuf::uint32 value);
  
  // optional uint32 capConnAnncNoInn = 6;
  inline bool has_capconnanncnoinn() const;
  inline void clear_capconnanncnoinn();
  static const int kCapConnAnncNoInnFieldNumber = 6;
  inline ::google::protobuf::uint32 capconnanncnoinn() const;
  inline void set_capconnanncnoinn(::google::protobuf::uint32 value);
  
  // optional uint32 capConnAnncNoNPI = 7;
  inline bool has_capconnanncnonpi() const;
  inline void clear_capconnanncnonpi();
  static const int kCapConnAnncNoNPIFieldNumber = 7;
  inline ::google::protobuf::uint32 capconnanncnonpi() const;
  inline void set_capconnanncnonpi(::google::protobuf::uint32 value);
  
  // optional string capConnDestNo = 8;
  inline bool has_capconndestno() const;
  inline void clear_capconndestno();
  static const int kCapConnDestNoFieldNumber = 8;
  inline const ::std::string& capconndestno() const;
  inline void set_capconndestno(const ::std::string& value);
  inline void set_capconndestno(const char* value);
  inline void set_capconndestno(const char* value, size_t size);
  inline ::std::string* mutable_capconndestno();
  inline ::std::string* release_capconndestno();
  
  // optional uint32 capConnDestNoNature = 9;
  inline bool has_capconndestnonature() const;
  inline void clear_capconndestnonature();
  static const int kCapConnDestNoNatureFieldNumber = 9;
  inline ::google::protobuf::uint32 capconndestnonature() const;
  inline void set_capconndestnonature(::google::protobuf::uint32 value);
  
  // optional uint32 capConnDestNoNPI = 10;
  inline bool has_capconndestnonpi() const;
  inline void clear_capconndestnonpi();
  static const int kCapConnDestNoNPIFieldNumber = 10;
  inline ::google::protobuf::uint32 capconndestnonpi() const;
  inline void set_capconndestnonpi(::google::protobuf::uint32 value);
  
  // optional uint32 capConnDestINN = 11;
  inline bool has_capconndestinn() const;
  inline void clear_capconndestinn();
  static const int kCapConnDestINNFieldNumber = 11;
  inline ::google::protobuf::uint32 capconndestinn() const;
  inline void set_capconndestinn(::google::protobuf::uint32 value);
  
  // optional string genericNo = 12;
  inline bool has_genericno() const;
  inline void clear_genericno();
  static const int kGenericNoFieldNumber = 12;
  inline const ::std::string& genericno() const;
  inline void set_genericno(const ::std::string& value);
  inline void set_genericno(const char* value);
  inline void set_genericno(const char* value, size_t size);
  inline ::std::string* mutable_genericno();
  inline ::std::string* release_genericno();
  
  // optional uint32 genericNoNature = 13;
  inline bool has_genericnonature() const;
  inline void clear_genericnonature();
  static const int kGenericNoNatureFieldNumber = 13;
  inline ::google::protobuf::uint32 genericnonature() const;
  inline void set_genericnonature(::google::protobuf::uint32 value);
  
  // optional uint32 genericNoNPI = 14;
  inline bool has_genericnonpi() const;
  inline void clear_genericnonpi();
  static const int kGenericNoNPIFieldNumber = 14;
  inline ::google::protobuf::uint32 genericnonpi() const;
  inline void set_genericnonpi(::google::protobuf::uint32 value);
  
  // optional uint32 genericNoNII = 15;
  inline bool has_genericnonii() const;
  inline void clear_genericnonii();
  static const int kGenericNoNIIFieldNumber = 15;
  inline ::google::protobuf::uint32 genericnonii() const;
  inline void set_genericnonii(::google::protobuf::uint32 value);
  
  // optional uint32 genericNoARI = 16;
  inline bool has_genericnoari() const;
  inline void clear_genericnoari();
  static const int kGenericNoARIFieldNumber = 16;
  inline ::google::protobuf::uint32 genericnoari() const;
  inline void set_genericnoari(::google::protobuf::uint32 value);
  
  // optional uint32 genericNoSCI = 17;
  inline bool has_genericnosci() const;
  inline void clear_genericnosci();
  static const int kGenericNoSCIFieldNumber = 17;
  inline ::google::protobuf::uint32 genericnosci() const;
  inline void set_genericnosci(::google::protobuf::uint32 value);
  
  // optional uint32 genericNoNQI = 18;
  inline bool has_genericnonqi() const;
  inline void clear_genericnonqi();
  static const int kGenericNoNQIFieldNumber = 18;
  inline ::google::protobuf::uint32 genericnonqi() const;
  inline void set_genericnonqi(::google::protobuf::uint32 value);
  
  // optional string redirectingNum = 19;
  inline bool has_redirectingnum() const;
  inline void clear_redirectingnum();
  static const int kRedirectingNumFieldNumber = 19;
  inline const ::std::string& redirectingnum() const;
  inline void set_redirectingnum(const ::std::string& value);
  inline void set_redirectingnum(const char* value);
  inline void set_redirectingnum(const char* value, size_t size);
  inline ::std::string* mutable_redirectingnum();
  inline ::std::string* release_redirectingnum();
  
  // optional uint32 redirectNoNOA = 20;
  inline bool has_redirectnonoa() const;
  inline void clear_redirectnonoa();
  static const int kRedirectNoNOAFieldNumber = 20;
  inline ::google::protobuf::uint32 redirectnonoa() const;
  inline void set_redirectnonoa(::google::protobuf::uint32 value);
  
  // optional uint32 redirectNoNPI = 21;
  inline bool has_redirectnonpi() const;
  inline void clear_redirectnonpi();
  static const int kRedirectNoNPIFieldNumber = 21;
  inline ::google::protobuf::uint32 redirectnonpi() const;
  inline void set_redirectnonpi(::google::protobuf::uint32 value);
  
  // optional uint32 redirectNoARI = 22;
  inline bool has_redirectnoari() const;
  inline void clear_redirectnoari();
  static const int kRedirectNoARIFieldNumber = 22;
  inline ::google::protobuf::uint32 redirectnoari() const;
  inline void set_redirectnoari(::google::protobuf::uint32 value);
  
  // optional uint32 redirectInd = 23;
  inline bool has_redirectind() const;
  inline void clear_redirectind();
  static const int kRedirectIndFieldNumber = 23;
  inline ::google::protobuf::uint32 redirectind() const;
  inline void set_redirectind(::google::protobuf::uint32 value);
  
  // optional uint32 origRedirectReason = 24;
  inline bool has_origredirectreason() const;
  inline void clear_origredirectreason();
  static const int kOrigRedirectReasonFieldNumber = 24;
  inline ::google::protobuf::uint32 origredirectreason() const;
  inline void set_origredirectreason(::google::protobuf::uint32 value);
  
  // optional uint32 redirectionCount = 25;
  inline bool has_redirectioncount() const;
  inline void clear_redirectioncount();
  static const int kRedirectionCountFieldNumber = 25;
  inline ::google::protobuf::uint32 redirectioncount() const;
  inline void set_redirectioncount(::google::protobuf::uint32 value);
  
  // optional uint32 redirectReason = 26;
  inline bool has_redirectreason() const;
  inline void clear_redirectreason();
  static const int kRedirectReasonFieldNumber = 26;
  inline ::google::protobuf::uint32 redirectreason() const;
  inline void set_redirectreason(::google::protobuf::uint32 value);
  
  // optional string origCalledPartyId = 27;
  inline bool has_origcalledpartyid() const;
  inline void clear_origcalledpartyid();
  static const int kOrigCalledPartyIdFieldNumber = 27;
  inline const ::std::string& origcalledpartyid() const;
  inline void set_origcalledpartyid(const ::std::string& value);
  inline void set_origcalledpartyid(const char* value);
  inline void set_origcalledpartyid(const char* value, size_t size);
  inline ::std::string* mutable_origcalledpartyid();
  inline ::std::string* release_origcalledpartyid();
  
  // optional uint32 originalCalledNoNPI = 28;
  inline bool has_originalcallednonpi() const;
  inline void clear_originalcallednonpi();
  static const int kOriginalCalledNoNPIFieldNumber = 28;
  inline ::google::protobuf::uint32 originalcallednonpi() const;
  inline void set_originalcallednonpi(::google::protobuf::uint32 value);
  
  // optional uint32 originalCalledNoNOA = 29;
  inline bool has_originalcallednonoa() const;
  inline void clear_originalcallednonoa();
  static const int kOriginalCalledNoNOAFieldNumber = 29;
  inline ::google::protobuf::uint32 originalcallednonoa() const;
  inline void set_originalcallednonoa(::google::protobuf::uint32 value);
  
  // optional uint32 originalCalledNoARI = 30;
  inline bool has_originalcallednoari() const;
  inline void clear_originalcallednoari();
  static const int kOriginalCalledNoARIFieldNumber = 30;
  inline ::google::protobuf::uint32 originalcallednoari() const;
  inline void set_originalcallednoari(::google::protobuf::uint32 value);
  
  // optional uint32 capConnOCSIApplicable = 31;
  inline bool has_capconnocsiapplicable() const;
  inline void clear_capconnocsiapplicable();
  static const int kCapConnOCSIApplicableFieldNumber = 31;
  inline ::google::protobuf::uint32 capconnocsiapplicable() const;
  inline void set_capconnocsiapplicable(::google::protobuf::uint32 value);
  
  // optional uint32 capConnSuppressionOfAnnc = 32;
  inline bool has_capconnsuppressionofannc() const;
  inline void clear_capconnsuppressionofannc();
  static const int kCapConnSuppressionOfAnncFieldNumber = 32;
  inline ::google::protobuf::uint32 capconnsuppressionofannc() const;
  inline void set_capconnsuppressionofannc(::google::protobuf::uint32 value);
  
  // optional uint32 capConnCallingCategory = 33;
  inline bool has_capconncallingcategory() const;
  inline void clear_capconncallingcategory();
  static const int kCapConnCallingCategoryFieldNumber = 33;
  inline ::google::protobuf::uint32 capconncallingcategory() const;
  inline void set_capconncallingcategory(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:pbConnectArgData)
 private:
  inline void set_has_hasservicecontrol();
  inline void clear_has_hasservicecontrol();
  inline void set_has_hascapinfo();
  inline void clear_has_hascapinfo();
  inline void set_has_hascapconnectinfo();
  inline void clear_has_hascapconnectinfo();
  inline void set_has_capanncaccessno();
  inline void clear_has_capanncaccessno();
  inline void set_has_capconnanncnonatrue();
  inline void clear_has_capconnanncnonatrue();
  inline void set_has_capconnanncnoinn();
  inline void clear_has_capconnanncnoinn();
  inline void set_has_capconnanncnonpi();
  inline void clear_has_capconnanncnonpi();
  inline void set_has_capconndestno();
  inline void clear_has_capconndestno();
  inline void set_has_capconndestnonature();
  inline void clear_has_capconndestnonature();
  inline void set_has_capconndestnonpi();
  inline void clear_has_capconndestnonpi();
  inline void set_has_capconndestinn();
  inline void clear_has_capconndestinn();
  inline void set_has_genericno();
  inline void clear_has_genericno();
  inline void set_has_genericnonature();
  inline void clear_has_genericnonature();
  inline void set_has_genericnonpi();
  inline void clear_has_genericnonpi();
  inline void set_has_genericnonii();
  inline void clear_has_genericnonii();
  inline void set_has_genericnoari();
  inline void clear_has_genericnoari();
  inline void set_has_genericnosci();
  inline void clear_has_genericnosci();
  inline void set_has_genericnonqi();
  inline void clear_has_genericnonqi();
  inline void set_has_redirectingnum();
  inline void clear_has_redirectingnum();
  inline void set_has_redirectnonoa();
  inline void clear_has_redirectnonoa();
  inline void set_has_redirectnonpi();
  inline void clear_has_redirectnonpi();
  inline void set_has_redirectnoari();
  inline void clear_has_redirectnoari();
  inline void set_has_redirectind();
  inline void clear_has_redirectind();
  inline void set_has_origredirectreason();
  inline void clear_has_origredirectreason();
  inline void set_has_redirectioncount();
  inline void clear_has_redirectioncount();
  inline void set_has_redirectreason();
  inline void clear_has_redirectreason();
  inline void set_has_origcalledpartyid();
  inline void clear_has_origcalledpartyid();
  inline void set_has_originalcallednonpi();
  inline void clear_has_originalcallednonpi();
  inline void set_has_originalcallednonoa();
  inline void clear_has_originalcallednonoa();
  inline void set_has_originalcallednoari();
  inline void clear_has_originalcallednoari();
  inline void set_has_capconnocsiapplicable();
  inline void clear_has_capconnocsiapplicable();
  inline void set_has_capconnsuppressionofannc();
  inline void clear_has_capconnsuppressionofannc();
  inline void set_has_capconncallingcategory();
  inline void clear_has_capconncallingcategory();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  bool hasservicecontrol_;
  bool hascapinfo_;
  bool hascapconnectinfo_;
  ::google::protobuf::uint32 capconnanncnonatrue_;
  ::std::string* capanncaccessno_;
  ::google::protobuf::uint32 capconnanncnoinn_;
  ::google::protobuf::uint32 capconnanncnonpi_;
  ::std::string* capconndestno_;
  ::google::protobuf::uint32 capconndestnonature_;
  ::google::protobuf::uint32 capconndestnonpi_;
  ::std::string* genericno_;
  ::google::protobuf::uint32 capconndestinn_;
  ::google::protobuf::uint32 genericnonature_;
  ::google::protobuf::uint32 genericnonpi_;
  ::google::protobuf::uint32 genericnonii_;
  ::google::protobuf::uint32 genericnoari_;
  ::google::protobuf::uint32 genericnosci_;
  ::std::string* redirectingnum_;
  ::google::protobuf::uint32 genericnonqi_;
  ::google::protobuf::uint32 redirectnonoa_;
  ::google::protobuf::uint32 redirectnonpi_;
  ::google::protobuf::uint32 redirectnoari_;
  ::google::protobuf::uint32 redirectind_;
  ::google::protobuf::uint32 origredirectreason_;
  ::google::protobuf::uint32 redirectioncount_;
  ::google::protobuf::uint32 redirectreason_;
  ::std::string* origcalledpartyid_;
  ::google::protobuf::uint32 originalcallednonpi_;
  ::google::protobuf::uint32 originalcallednonoa_;
  ::google::protobuf::uint32 originalcallednoari_;
  ::google::protobuf::uint32 capconnocsiapplicable_;
  ::google::protobuf::uint32 capconnsuppressionofannc_;
  ::google::protobuf::uint32 capconncallingcategory_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(33 + 31) / 32];
  
  friend void  protobuf_AddDesc_iwf_2eproto();
  friend void protobuf_AssignDesc_iwf_2eproto();
  friend void protobuf_ShutdownFile_iwf_2eproto();
  
  void InitAsDefaultInstance();
  static pbConnectArgData* default_instance_;
};
// -------------------------------------------------------------------

class pbACHData : public ::google::protobuf::Message {
 public:
  pbACHData();
  virtual ~pbACHData();
  
  pbACHData(const pbACHData& from);
  
  inline pbACHData& operator=(const pbACHData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const pbACHData& default_instance();
  
  void Swap(pbACHData* other);
  
  // implements Message ----------------------------------------------
  
  pbACHData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pbACHData& from);
  void MergeFrom(const pbACHData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 FinalUnitIndication = 1;
  inline bool has_finalunitindication() const;
  inline void clear_finalunitindication();
  static const int kFinalUnitIndicationFieldNumber = 1;
  inline ::google::protobuf::uint32 finalunitindication() const;
  inline void set_finalunitindication(::google::protobuf::uint32 value);
  
  // optional uint32 BeepTone = 2;
  inline bool has_beeptone() const;
  inline void clear_beeptone();
  static const int kBeepToneFieldNumber = 2;
  inline ::google::protobuf::uint32 beeptone() const;
  inline void set_beeptone(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:pbACHData)
 private:
  inline void set_has_finalunitindication();
  inline void clear_has_finalunitindication();
  inline void set_has_beeptone();
  inline void clear_has_beeptone();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 finalunitindication_;
  ::google::protobuf::uint32 beeptone_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_iwf_2eproto();
  friend void protobuf_AssignDesc_iwf_2eproto();
  friend void protobuf_ShutdownFile_iwf_2eproto();
  
  void InitAsDefaultInstance();
  static pbACHData* default_instance_;
};
// -------------------------------------------------------------------

class pbCapRoTsl : public ::google::protobuf::Message {
 public:
  pbCapRoTsl();
  virtual ~pbCapRoTsl();
  
  pbCapRoTsl(const pbCapRoTsl& from);
  
  inline pbCapRoTsl& operator=(const pbCapRoTsl& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const pbCapRoTsl& default_instance();
  
  void Swap(pbCapRoTsl* other);
  
  // implements Message ----------------------------------------------
  
  pbCapRoTsl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pbCapRoTsl& from);
  void MergeFrom(const pbCapRoTsl& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bool bcsmEventFlag = 1;
  inline bool has_bcsmeventflag() const;
  inline void clear_bcsmeventflag();
  static const int kBcsmEventFlagFieldNumber = 1;
  inline bool bcsmeventflag() const;
  inline void set_bcsmeventflag(bool value);
  
  // optional string capCallingPartyNumber = 2;
  inline bool has_capcallingpartynumber() const;
  inline void clear_capcallingpartynumber();
  static const int kCapCallingPartyNumberFieldNumber = 2;
  inline const ::std::string& capcallingpartynumber() const;
  inline void set_capcallingpartynumber(const ::std::string& value);
  inline void set_capcallingpartynumber(const char* value);
  inline void set_capcallingpartynumber(const char* value, size_t size);
  inline ::std::string* mutable_capcallingpartynumber();
  inline ::std::string* release_capcallingpartynumber();
  
  // optional uint32 serviceIdentifier = 3;
  inline bool has_serviceidentifier() const;
  inline void clear_serviceidentifier();
  static const int kServiceIdentifierFieldNumber = 3;
  inline ::google::protobuf::uint32 serviceidentifier() const;
  inline void set_serviceidentifier(::google::protobuf::uint32 value);
  
  // optional bool receivedBasicService = 4;
  inline bool has_receivedbasicservice() const;
  inline void clear_receivedbasicservice();
  static const int kReceivedBasicServiceFieldNumber = 4;
  inline bool receivedbasicservice() const;
  inline void set_receivedbasicservice(bool value);
  
  // optional string roUserSessionId = 5;
  inline bool has_rousersessionid() const;
  inline void clear_rousersessionid();
  static const int kRoUserSessionIdFieldNumber = 5;
  inline const ::std::string& rousersessionid() const;
  inline void set_rousersessionid(const ::std::string& value);
  inline void set_rousersessionid(const char* value);
  inline void set_rousersessionid(const char* value, size_t size);
  inline ::std::string* mutable_rousersessionid();
  inline ::std::string* release_rousersessionid();
  
  // optional string imsiChargingIdentifier = 6;
  inline bool has_imsichargingidentifier() const;
  inline void clear_imsichargingidentifier();
  static const int kImsiChargingIdentifierFieldNumber = 6;
  inline const ::std::string& imsichargingidentifier() const;
  inline void set_imsichargingidentifier(const ::std::string& value);
  inline void set_imsichargingidentifier(const char* value);
  inline void set_imsichargingidentifier(const char* value, size_t size);
  inline ::std::string* mutable_imsichargingidentifier();
  inline ::std::string* release_imsichargingidentifier();
  
  // optional string roServiceContextId = 7;
  inline bool has_roservicecontextid() const;
  inline void clear_roservicecontextid();
  static const int kRoServiceContextIdFieldNumber = 7;
  inline const ::std::string& roservicecontextid() const;
  inline void set_roservicecontextid(const ::std::string& value);
  inline void set_roservicecontextid(const char* value);
  inline void set_roservicecontextid(const char* value, size_t size);
  inline ::std::string* mutable_roservicecontextid();
  inline ::std::string* release_roservicecontextid();
  
  // optional .SubscriptionIdConfig SubscriptionId = 8;
  inline bool has_subscriptionid() const;
  inline void clear_subscriptionid();
  static const int kSubscriptionIdFieldNumber = 8;
  inline const ::SubscriptionIdConfig& subscriptionid() const;
  inline ::SubscriptionIdConfig* mutable_subscriptionid();
  inline ::SubscriptionIdConfig* release_subscriptionid();
  
  // optional string roCugInformation = 9;
  inline bool has_rocuginformation() const;
  inline void clear_rocuginformation();
  static const int kRoCugInformationFieldNumber = 9;
  inline const ::std::string& rocuginformation() const;
  inline void set_rocuginformation(const ::std::string& value);
  inline void set_rocuginformation(const char* value);
  inline void set_rocuginformation(const char* value, size_t size);
  inline ::std::string* mutable_rocuginformation();
  inline ::std::string* release_rocuginformation();
  
  // optional string capMSCAddress = 10;
  inline bool has_capmscaddress() const;
  inline void clear_capmscaddress();
  static const int kCapMSCAddressFieldNumber = 10;
  inline const ::std::string& capmscaddress() const;
  inline void set_capmscaddress(const ::std::string& value);
  inline void set_capmscaddress(const char* value);
  inline void set_capmscaddress(const char* value, size_t size);
  inline ::std::string* mutable_capmscaddress();
  inline ::std::string* release_capmscaddress();
  
  // optional string capGMSCAddress = 11;
  inline bool has_capgmscaddress() const;
  inline void clear_capgmscaddress();
  static const int kCapGMSCAddressFieldNumber = 11;
  inline const ::std::string& capgmscaddress() const;
  inline void set_capgmscaddress(const ::std::string& value);
  inline void set_capgmscaddress(const char* value);
  inline void set_capgmscaddress(const char* value, size_t size);
  inline ::std::string* mutable_capgmscaddress();
  inline ::std::string* release_capgmscaddress();
  
  // optional uint32 ccaInitialResultCode = 12;
  inline bool has_ccainitialresultcode() const;
  inline void clear_ccainitialresultcode();
  static const int kCcaInitialResultCodeFieldNumber = 12;
  inline ::google::protobuf::uint32 ccainitialresultcode() const;
  inline void set_ccainitialresultcode(::google::protobuf::uint32 value);
  
  // optional uint32 ccaUpdateResultCode = 13;
  inline bool has_ccaupdateresultcode() const;
  inline void clear_ccaupdateresultcode();
  static const int kCcaUpdateResultCodeFieldNumber = 13;
  inline ::google::protobuf::uint32 ccaupdateresultcode() const;
  inline void set_ccaupdateresultcode(::google::protobuf::uint32 value);
  
  // optional uint32 ccaTerminateResultCode = 14;
  inline bool has_ccaterminateresultcode() const;
  inline void clear_ccaterminateresultcode();
  static const int kCcaTerminateResultCodeFieldNumber = 14;
  inline ::google::protobuf::uint32 ccaterminateresultcode() const;
  inline void set_ccaterminateresultcode(::google::protobuf::uint32 value);
  
  // optional bool receivedTcapContinue = 15 [default = false];
  inline bool has_receivedtcapcontinue() const;
  inline void clear_receivedtcapcontinue();
  static const int kReceivedTcapContinueFieldNumber = 15;
  inline bool receivedtcapcontinue() const;
  inline void set_receivedtcapcontinue(bool value);
  
  // optional bool receivedASR = 16 [default = false];
  inline bool has_receivedasr() const;
  inline void clear_receivedasr();
  static const int kReceivedASRFieldNumber = 16;
  inline bool receivedasr() const;
  inline void set_receivedasr(bool value);
  
  // optional bool receivedIdpSms = 17 [default = false];
  inline bool has_receivedidpsms() const;
  inline void clear_receivedidpsms();
  static const int kReceivedIdpSmsFieldNumber = 17;
  inline bool receivedidpsms() const;
  inline void set_receivedidpsms(bool value);
  
  // optional bool receivedIdp = 18 [default = false];
  inline bool has_receivedidp() const;
  inline void clear_receivedidp();
  static const int kReceivedIdpFieldNumber = 18;
  inline bool receivedidp() const;
  inline void set_receivedidp(bool value);
  
  // optional bool isTimeZoneSeconds = 19 [default = false];
  inline bool has_istimezoneseconds() const;
  inline void clear_istimezoneseconds();
  static const int kIsTimeZoneSecondsFieldNumber = 19;
  inline bool istimezoneseconds() const;
  inline void set_istimezoneseconds(bool value);
  
  // optional uint32 timeZoneSeconds = 20;
  inline bool has_timezoneseconds() const;
  inline void clear_timezoneseconds();
  static const int kTimeZoneSecondsFieldNumber = 20;
  inline ::google::protobuf::uint32 timezoneseconds() const;
  inline void set_timezoneseconds(::google::protobuf::uint32 value);
  
  // optional uint32 ccaUpdateMsccResultCode = 21;
  inline bool has_ccaupdatemsccresultcode() const;
  inline void clear_ccaupdatemsccresultcode();
  static const int kCcaUpdateMsccResultCodeFieldNumber = 21;
  inline ::google::protobuf::uint32 ccaupdatemsccresultcode() const;
  inline void set_ccaupdatemsccresultcode(::google::protobuf::uint32 value);
  
  // optional bool isccaMsccGrantedCCTimeZero = 22 [default = false];
  inline bool has_isccamsccgrantedcctimezero() const;
  inline void clear_isccamsccgrantedcctimezero();
  static const int kIsccaMsccGrantedCCTimeZeroFieldNumber = 22;
  inline bool isccamsccgrantedcctimezero() const;
  inline void set_isccamsccgrantedcctimezero(bool value);
  
  // optional bool isReleaseSent = 23;
  inline bool has_isreleasesent() const;
  inline void clear_isreleasesent();
  static const int kIsReleaseSentFieldNumber = 23;
  inline bool isreleasesent() const;
  inline void set_isreleasesent(bool value);
  
  // optional uint32 lastSentCCRequestType = 24;
  inline bool has_lastsentccrequesttype() const;
  inline void clear_lastsentccrequesttype();
  static const int kLastSentCCRequestTypeFieldNumber = 24;
  inline ::google::protobuf::uint32 lastsentccrequesttype() const;
  inline void set_lastsentccrequesttype(::google::protobuf::uint32 value);
  
  // optional uint32 ccRequestNumber = 25;
  inline bool has_ccrequestnumber() const;
  inline void clear_ccrequestnumber();
  static const int kCcRequestNumberFieldNumber = 25;
  inline ::google::protobuf::uint32 ccrequestnumber() const;
  inline void set_ccrequestnumber(::google::protobuf::uint32 value);
  
  // optional bool isFirstERBRcvd = 26;
  inline bool has_isfirsterbrcvd() const;
  inline void clear_isfirsterbrcvd();
  static const int kIsFirstERBRcvdFieldNumber = 26;
  inline bool isfirsterbrcvd() const;
  inline void set_isfirsterbrcvd(bool value);
  
  // optional uint32 CallType = 27;
  inline bool has_calltype() const;
  inline void clear_calltype();
  static const int kCallTypeFieldNumber = 27;
  inline ::google::protobuf::uint32 calltype() const;
  inline void set_calltype(::google::protobuf::uint32 value);
  
  // optional uint32 scpAction = 28 [default = 0];
  inline bool has_scpaction() const;
  inline void clear_scpaction();
  static const int kScpActionFieldNumber = 28;
  inline ::google::protobuf::uint32 scpaction() const;
  inline void set_scpaction(::google::protobuf::uint32 value);
  
  // optional uint32 orgScpAction = 29 [default = 0];
  inline bool has_orgscpaction() const;
  inline void clear_orgscpaction();
  static const int kOrgScpActionFieldNumber = 29;
  inline ::google::protobuf::uint32 orgscpaction() const;
  inline void set_orgscpaction(::google::protobuf::uint32 value);
  
  // optional int32 capControlMode = 30 [default = -1];
  inline bool has_capcontrolmode() const;
  inline void clear_capcontrolmode();
  static const int kCapControlModeFieldNumber = 30;
  inline ::google::protobuf::int32 capcontrolmode() const;
  inline void set_capcontrolmode(::google::protobuf::int32 value);
  
  // optional uint32 terminationCause = 31;
  inline bool has_terminationcause() const;
  inline void clear_terminationcause();
  static const int kTerminationCauseFieldNumber = 31;
  inline ::google::protobuf::uint32 terminationcause() const;
  inline void set_terminationcause(::google::protobuf::uint32 value);
  
  // optional .StoredIDPSMSToCCRIData mappedIDPToCCRIData = 32;
  inline bool has_mappedidptoccridata() const;
  inline void clear_mappedidptoccridata();
  static const int kMappedIDPToCCRIDataFieldNumber = 32;
  inline const ::StoredIDPSMSToCCRIData& mappedidptoccridata() const;
  inline ::StoredIDPSMSToCCRIData* mutable_mappedidptoccridata();
  inline ::StoredIDPSMSToCCRIData* release_mappedidptoccridata();
  
  // optional uint32 recvAppContextName = 33;
  inline bool has_recvappcontextname() const;
  inline void clear_recvappcontextname();
  static const int kRecvAppContextNameFieldNumber = 33;
  inline ::google::protobuf::uint32 recvappcontextname() const;
  inline void set_recvappcontextname(::google::protobuf::uint32 value);
  
  // optional .IDPToCCRIData IdpCCRIData = 34;
  inline bool has_idpccridata() const;
  inline void clear_idpccridata();
  static const int kIdpCCRIDataFieldNumber = 34;
  inline const ::IDPToCCRIData& idpccridata() const;
  inline ::IDPToCCRIData* mutable_idpccridata();
  inline ::IDPToCCRIData* release_idpccridata();
  
  // optional uint32 recvGSUCCTime = 35;
  inline bool has_recvgsucctime() const;
  inline void clear_recvgsucctime();
  static const int kRecvGSUCCTimeFieldNumber = 35;
  inline ::google::protobuf::uint32 recvgsucctime() const;
  inline void set_recvgsucctime(::google::protobuf::uint32 value);
  
  // optional uint32 recvNoAnsTime = 36;
  inline bool has_recvnoanstime() const;
  inline void clear_recvnoanstime();
  static const int kRecvNoAnsTimeFieldNumber = 36;
  inline ::google::protobuf::uint32 recvnoanstime() const;
  inline void set_recvnoanstime(::google::protobuf::uint32 value);
  
  // optional uint32 currUSUCCTime = 37;
  inline bool has_currusucctime() const;
  inline void clear_currusucctime();
  static const int kCurrUSUCCTimeFieldNumber = 37;
  inline ::google::protobuf::uint32 currusucctime() const;
  inline void set_currusucctime(::google::protobuf::uint32 value);
  
  // optional uint32 cumulativeGSUCCTime = 38;
  inline bool has_cumulativegsucctime() const;
  inline void clear_cumulativegsucctime();
  static const int kCumulativeGSUCCTimeFieldNumber = 38;
  inline ::google::protobuf::uint32 cumulativegsucctime() const;
  inline void set_cumulativegsucctime(::google::protobuf::uint32 value);
  
  // optional uint32 cumulativeUSUCCTime = 39;
  inline bool has_cumulativeusucctime() const;
  inline void clear_cumulativeusucctime();
  static const int kCumulativeUSUCCTimeFieldNumber = 39;
  inline ::google::protobuf::uint32 cumulativeusucctime() const;
  inline void set_cumulativeusucctime(::google::protobuf::uint32 value);
  
  // optional bool isFinalUnitReceived = 40 [default = false];
  inline bool has_isfinalunitreceived() const;
  inline void clear_isfinalunitreceived();
  static const int kIsFinalUnitReceivedFieldNumber = 40;
  inline bool isfinalunitreceived() const;
  inline void set_isfinalunitreceived(bool value);
  
  // optional .pbERBData recvFirstERBData = 41;
  inline bool has_recvfirsterbdata() const;
  inline void clear_recvfirsterbdata();
  static const int kRecvFirstERBDataFieldNumber = 41;
  inline const ::pbERBData& recvfirsterbdata() const;
  inline ::pbERBData* mutable_recvfirsterbdata();
  inline ::pbERBData* release_recvfirsterbdata();
  
  // optional .pbERBData recvERBData = 42;
  inline bool has_recverbdata() const;
  inline void clear_recverbdata();
  static const int kRecvERBDataFieldNumber = 42;
  inline const ::pbERBData& recverbdata() const;
  inline ::pbERBData* mutable_recverbdata();
  inline ::pbERBData* release_recverbdata();
  
  // optional uint32 callAnswerTimeStamp = 43;
  inline bool has_callanswertimestamp() const;
  inline void clear_callanswertimestamp();
  static const int kCallAnswerTimeStampFieldNumber = 43;
  inline ::google::protobuf::uint32 callanswertimestamp() const;
  inline void set_callanswertimestamp(::google::protobuf::uint32 value);
  
  // optional bool isFollowingOn = 44;
  inline bool has_isfollowingon() const;
  inline void clear_isfollowingon();
  static const int kIsFollowingOnFieldNumber = 44;
  inline bool isfollowingon() const;
  inline void set_isfollowingon(bool value);
  
  // optional .pbActivityTimerData activityTimerData = 45;
  inline bool has_activitytimerdata() const;
  inline void clear_activitytimerdata();
  static const int kActivityTimerDataFieldNumber = 45;
  inline const ::pbActivityTimerData& activitytimerdata() const;
  inline ::pbActivityTimerData* mutable_activitytimerdata();
  inline ::pbActivityTimerData* release_activitytimerdata();
  
  // optional string strRemoteTransIdForCDR = 46;
  inline bool has_strremotetransidforcdr() const;
  inline void clear_strremotetransidforcdr();
  static const int kStrRemoteTransIdForCDRFieldNumber = 46;
  inline const ::std::string& strremotetransidforcdr() const;
  inline void set_strremotetransidforcdr(const ::std::string& value);
  inline void set_strremotetransidforcdr(const char* value);
  inline void set_strremotetransidforcdr(const char* value, size_t size);
  inline ::std::string* mutable_strremotetransidforcdr();
  inline ::std::string* release_strremotetransidforcdr();
  
  // optional string strLocalTransIdForCDR = 47;
  inline bool has_strlocaltransidforcdr() const;
  inline void clear_strlocaltransidforcdr();
  static const int kStrLocalTransIdForCDRFieldNumber = 47;
  inline const ::std::string& strlocaltransidforcdr() const;
  inline void set_strlocaltransidforcdr(const ::std::string& value);
  inline void set_strlocaltransidforcdr(const char* value);
  inline void set_strlocaltransidforcdr(const char* value, size_t size);
  inline ::std::string* mutable_strlocaltransidforcdr();
  inline ::std::string* release_strlocaltransidforcdr();
  
  // optional bool bIsCallContinueSet = 48 [default = false];
  inline bool has_biscallcontinueset() const;
  inline void clear_biscallcontinueset();
  static const int kBIsCallContinueSetFieldNumber = 48;
  inline bool biscallcontinueset() const;
  inline void set_biscallcontinueset(bool value);
  
  // optional uint32 sessionStartTimeStamp = 49;
  inline bool has_sessionstarttimestamp() const;
  inline void clear_sessionstarttimestamp();
  static const int kSessionStartTimeStampFieldNumber = 49;
  inline ::google::protobuf::uint32 sessionstarttimestamp() const;
  inline void set_sessionstarttimestamp(::google::protobuf::uint32 value);
  
  // optional uint32 connectMaxDuration = 50;
  inline bool has_connectmaxduration() const;
  inline void clear_connectmaxduration();
  static const int kConnectMaxDurationFieldNumber = 50;
  inline ::google::protobuf::uint32 connectmaxduration() const;
  inline void set_connectmaxduration(::google::protobuf::uint32 value);
  
  // optional uint32 erbAnswerTimeStamp = 51;
  inline bool has_erbanswertimestamp() const;
  inline void clear_erbanswertimestamp();
  static const int kErbAnswerTimeStampFieldNumber = 51;
  inline ::google::protobuf::uint32 erbanswertimestamp() const;
  inline void set_erbanswertimestamp(::google::protobuf::uint32 value);
  
  // optional string erbSpecificInfo = 52;
  inline bool has_erbspecificinfo() const;
  inline void clear_erbspecificinfo();
  static const int kErbSpecificInfoFieldNumber = 52;
  inline const ::std::string& erbspecificinfo() const;
  inline void set_erbspecificinfo(const ::std::string& value);
  inline void set_erbspecificinfo(const char* value);
  inline void set_erbspecificinfo(const char* value, size_t size);
  inline ::std::string* mutable_erbspecificinfo();
  inline ::std::string* release_erbspecificinfo();
  
  // optional .pbIwfDccaSessionCtxt dccaCtxt = 53;
  inline bool has_dccactxt() const;
  inline void clear_dccactxt();
  static const int kDccaCtxtFieldNumber = 53;
  inline const ::pbIwfDccaSessionCtxt& dccactxt() const;
  inline ::pbIwfDccaSessionCtxt* mutable_dccactxt();
  inline ::pbIwfDccaSessionCtxt* release_dccactxt();
  
  // optional bool isFailedCDRLogged = 54 [default = false];
  inline bool has_isfailedcdrlogged() const;
  inline void clear_isfailedcdrlogged();
  static const int kIsFailedCDRLoggedFieldNumber = 54;
  inline bool isfailedcdrlogged() const;
  inline void set_isfailedcdrlogged(bool value);
  
  // optional uint32 releaseCause = 55;
  inline bool has_releasecause() const;
  inline void clear_releasecause();
  static const int kReleaseCauseFieldNumber = 55;
  inline ::google::protobuf::uint32 releasecause() const;
  inline void set_releasecause(::google::protobuf::uint32 value);
  
  // optional .TransState currState = 56;
  inline bool has_currstate() const;
  inline void clear_currstate();
  static const int kCurrStateFieldNumber = 56;
  inline TransState currstate() const;
  inline void set_currstate(TransState value);
  
  // optional .pbConnectArgData connectArg = 57;
  inline bool has_connectarg() const;
  inline void clear_connectarg();
  static const int kConnectArgFieldNumber = 57;
  inline const ::pbConnectArgData& connectarg() const;
  inline ::pbConnectArgData* mutable_connectarg();
  inline ::pbConnectArgData* release_connectarg();
  
  // optional .pbACHData achdata = 58;
  inline bool has_achdata() const;
  inline void clear_achdata();
  static const int kAchdataFieldNumber = 58;
  inline const ::pbACHData& achdata() const;
  inline ::pbACHData* mutable_achdata();
  inline ::pbACHData* release_achdata();
  
  // optional uint32 disconTriggerTimeStamp = 59;
  inline bool has_discontriggertimestamp() const;
  inline void clear_discontriggertimestamp();
  static const int kDisconTriggerTimeStampFieldNumber = 59;
  inline ::google::protobuf::uint32 discontriggertimestamp() const;
  inline void set_discontriggertimestamp(::google::protobuf::uint32 value);
  
  // optional fixed32 ccfhFailedoverReason = 60 [default = 0];
  inline bool has_ccfhfailedoverreason() const;
  inline void clear_ccfhfailedoverreason();
  static const int kCcfhFailedoverReasonFieldNumber = 60;
  inline ::google::protobuf::uint32 ccfhfailedoverreason() const;
  inline void set_ccfhfailedoverreason(::google::protobuf::uint32 value);
  
  // optional uint32 triggerFollowOnSession = 61 [default = 1];
  inline bool has_triggerfollowonsession() const;
  inline void clear_triggerfollowonsession();
  static const int kTriggerFollowOnSessionFieldNumber = 61;
  inline ::google::protobuf::uint32 triggerfollowonsession() const;
  inline void set_triggerfollowonsession(::google::protobuf::uint32 value);
  
  // optional uint32 updateTriggerTimeStamp = 62;
  inline bool has_updatetriggertimestamp() const;
  inline void clear_updatetriggertimestamp();
  static const int kUpdateTriggerTimeStampFieldNumber = 62;
  inline ::google::protobuf::uint32 updatetriggertimestamp() const;
  inline void set_updatetriggertimestamp(::google::protobuf::uint32 value);
  
  // optional bool IsCCRTBuiltForInvalidCCAI = 63 [default = false];
  inline bool has_isccrtbuiltforinvalidccai() const;
  inline void clear_isccrtbuiltforinvalidccai();
  static const int kIsCCRTBuiltForInvalidCCAIFieldNumber = 63;
  inline bool isccrtbuiltforinvalidccai() const;
  inline void set_isccrtbuiltforinvalidccai(bool value);
  
  // @@protoc_insertion_point(class_scope:pbCapRoTsl)
 private:
  inline void set_has_bcsmeventflag();
  inline void clear_has_bcsmeventflag();
  inline void set_has_capcallingpartynumber();
  inline void clear_has_capcallingpartynumber();
  inline void set_has_serviceidentifier();
  inline void clear_has_serviceidentifier();
  inline void set_has_receivedbasicservice();
  inline void clear_has_receivedbasicservice();
  inline void set_has_rousersessionid();
  inline void clear_has_rousersessionid();
  inline void set_has_imsichargingidentifier();
  inline void clear_has_imsichargingidentifier();
  inline void set_has_roservicecontextid();
  inline void clear_has_roservicecontextid();
  inline void set_has_subscriptionid();
  inline void clear_has_subscriptionid();
  inline void set_has_rocuginformation();
  inline void clear_has_rocuginformation();
  inline void set_has_capmscaddress();
  inline void clear_has_capmscaddress();
  inline void set_has_capgmscaddress();
  inline void clear_has_capgmscaddress();
  inline void set_has_ccainitialresultcode();
  inline void clear_has_ccainitialresultcode();
  inline void set_has_ccaupdateresultcode();
  inline void clear_has_ccaupdateresultcode();
  inline void set_has_ccaterminateresultcode();
  inline void clear_has_ccaterminateresultcode();
  inline void set_has_receivedtcapcontinue();
  inline void clear_has_receivedtcapcontinue();
  inline void set_has_receivedasr();
  inline void clear_has_receivedasr();
  inline void set_has_receivedidpsms();
  inline void clear_has_receivedidpsms();
  inline void set_has_receivedidp();
  inline void clear_has_receivedidp();
  inline void set_has_istimezoneseconds();
  inline void clear_has_istimezoneseconds();
  inline void set_has_timezoneseconds();
  inline void clear_has_timezoneseconds();
  inline void set_has_ccaupdatemsccresultcode();
  inline void clear_has_ccaupdatemsccresultcode();
  inline void set_has_isccamsccgrantedcctimezero();
  inline void clear_has_isccamsccgrantedcctimezero();
  inline void set_has_isreleasesent();
  inline void clear_has_isreleasesent();
  inline void set_has_lastsentccrequesttype();
  inline void clear_has_lastsentccrequesttype();
  inline void set_has_ccrequestnumber();
  inline void clear_has_ccrequestnumber();
  inline void set_has_isfirsterbrcvd();
  inline void clear_has_isfirsterbrcvd();
  inline void set_has_calltype();
  inline void clear_has_calltype();
  inline void set_has_scpaction();
  inline void clear_has_scpaction();
  inline void set_has_orgscpaction();
  inline void clear_has_orgscpaction();
  inline void set_has_capcontrolmode();
  inline void clear_has_capcontrolmode();
  inline void set_has_terminationcause();
  inline void clear_has_terminationcause();
  inline void set_has_mappedidptoccridata();
  inline void clear_has_mappedidptoccridata();
  inline void set_has_recvappcontextname();
  inline void clear_has_recvappcontextname();
  inline void set_has_idpccridata();
  inline void clear_has_idpccridata();
  inline void set_has_recvgsucctime();
  inline void clear_has_recvgsucctime();
  inline void set_has_recvnoanstime();
  inline void clear_has_recvnoanstime();
  inline void set_has_currusucctime();
  inline void clear_has_currusucctime();
  inline void set_has_cumulativegsucctime();
  inline void clear_has_cumulativegsucctime();
  inline void set_has_cumulativeusucctime();
  inline void clear_has_cumulativeusucctime();
  inline void set_has_isfinalunitreceived();
  inline void clear_has_isfinalunitreceived();
  inline void set_has_recvfirsterbdata();
  inline void clear_has_recvfirsterbdata();
  inline void set_has_recverbdata();
  inline void clear_has_recverbdata();
  inline void set_has_callanswertimestamp();
  inline void clear_has_callanswertimestamp();
  inline void set_has_isfollowingon();
  inline void clear_has_isfollowingon();
  inline void set_has_activitytimerdata();
  inline void clear_has_activitytimerdata();
  inline void set_has_strremotetransidforcdr();
  inline void clear_has_strremotetransidforcdr();
  inline void set_has_strlocaltransidforcdr();
  inline void clear_has_strlocaltransidforcdr();
  inline void set_has_biscallcontinueset();
  inline void clear_has_biscallcontinueset();
  inline void set_has_sessionstarttimestamp();
  inline void clear_has_sessionstarttimestamp();
  inline void set_has_connectmaxduration();
  inline void clear_has_connectmaxduration();
  inline void set_has_erbanswertimestamp();
  inline void clear_has_erbanswertimestamp();
  inline void set_has_erbspecificinfo();
  inline void clear_has_erbspecificinfo();
  inline void set_has_dccactxt();
  inline void clear_has_dccactxt();
  inline void set_has_isfailedcdrlogged();
  inline void clear_has_isfailedcdrlogged();
  inline void set_has_releasecause();
  inline void clear_has_releasecause();
  inline void set_has_currstate();
  inline void clear_has_currstate();
  inline void set_has_connectarg();
  inline void clear_has_connectarg();
  inline void set_has_achdata();
  inline void clear_has_achdata();
  inline void set_has_discontriggertimestamp();
  inline void clear_has_discontriggertimestamp();
  inline void set_has_ccfhfailedoverreason();
  inline void clear_has_ccfhfailedoverreason();
  inline void set_has_triggerfollowonsession();
  inline void clear_has_triggerfollowonsession();
  inline void set_has_updatetriggertimestamp();
  inline void clear_has_updatetriggertimestamp();
  inline void set_has_isccrtbuiltforinvalidccai();
  inline void clear_has_isccrtbuiltforinvalidccai();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* capcallingpartynumber_;
  ::std::string* rousersessionid_;
  ::std::string* imsichargingidentifier_;
  ::std::string* roservicecontextid_;
  ::google::protobuf::uint32 serviceidentifier_;
  bool bcsmeventflag_;
  bool receivedbasicservice_;
  bool receivedtcapcontinue_;
  bool receivedasr_;
  ::SubscriptionIdConfig* subscriptionid_;
  ::std::string* rocuginformation_;
  ::std::string* capmscaddress_;
  ::std::string* capgmscaddress_;
  ::google::protobuf::uint32 ccainitialresultcode_;
  ::google::protobuf::uint32 ccaupdateresultcode_;
  ::google::protobuf::uint32 ccaterminateresultcode_;
  bool receivedidpsms_;
  bool receivedidp_;
  bool istimezoneseconds_;
  bool isccamsccgrantedcctimezero_;
  ::google::protobuf::uint32 timezoneseconds_;
  ::google::protobuf::uint32 ccaupdatemsccresultcode_;
  ::google::protobuf::uint32 lastsentccrequesttype_;
  ::google::protobuf::uint32 ccrequestnumber_;
  ::google::protobuf::uint32 calltype_;
  ::google::protobuf::uint32 scpaction_;
  ::google::protobuf::uint32 orgscpaction_;
  ::google::protobuf::int32 capcontrolmode_;
  ::StoredIDPSMSToCCRIData* mappedidptoccridata_;
  ::google::protobuf::uint32 terminationcause_;
  ::google::protobuf::uint32 recvappcontextname_;
  bool isreleasesent_;
  bool isfirsterbrcvd_;
  bool isfinalunitreceived_;
  bool isfollowingon_;
  ::google::protobuf::uint32 recvgsucctime_;
  ::IDPToCCRIData* idpccridata_;
  ::google::protobuf::uint32 recvnoanstime_;
  ::google::protobuf::uint32 currusucctime_;
  ::google::protobuf::uint32 cumulativegsucctime_;
  ::google::protobuf::uint32 cumulativeusucctime_;
  ::pbERBData* recvfirsterbdata_;
  ::pbERBData* recverbdata_;
  ::pbActivityTimerData* activitytimerdata_;
  ::google::protobuf::uint32 callanswertimestamp_;
  ::google::protobuf::uint32 sessionstarttimestamp_;
  ::std::string* strremotetransidforcdr_;
  ::std::string* strlocaltransidforcdr_;
  ::google::protobuf::uint32 connectmaxduration_;
  ::google::protobuf::uint32 erbanswertimestamp_;
  ::std::string* erbspecificinfo_;
  ::pbIwfDccaSessionCtxt* dccactxt_;
  ::google::protobuf::uint32 releasecause_;
  bool biscallcontinueset_;
  bool isfailedcdrlogged_;
  bool isccrtbuiltforinvalidccai_;
  ::pbConnectArgData* connectarg_;
  int currstate_;
  ::google::protobuf::uint32 discontriggertimestamp_;
  ::pbACHData* achdata_;
  ::google::protobuf::uint32 ccfhfailedoverreason_;
  ::google::protobuf::uint32 triggerfollowonsession_;
  ::google::protobuf::uint32 updatetriggertimestamp_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(63 + 31) / 32];
  
  friend void  protobuf_AddDesc_iwf_2eproto();
  friend void protobuf_AssignDesc_iwf_2eproto();
  friend void protobuf_ShutdownFile_iwf_2eproto();
  
  void InitAsDefaultInstance();
  static pbCapRoTsl* default_instance_;
};
// -------------------------------------------------------------------

class pbStoredUserData : public ::google::protobuf::Message {
 public:
  pbStoredUserData();
  virtual ~pbStoredUserData();
  
  pbStoredUserData(const pbStoredUserData& from);
  
  inline pbStoredUserData& operator=(const pbStoredUserData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const pbStoredUserData& default_instance();
  
  void Swap(pbStoredUserData* other);
  
  // implements Message ----------------------------------------------
  
  pbStoredUserData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pbStoredUserData& from);
  void MergeFrom(const pbStoredUserData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .pbCapRoTsl caprotsl = 1;
  inline bool has_caprotsl() const;
  inline void clear_caprotsl();
  static const int kCaprotslFieldNumber = 1;
  inline const ::pbCapRoTsl& caprotsl() const;
  inline ::pbCapRoTsl* mutable_caprotsl();
  inline ::pbCapRoTsl* release_caprotsl();
  
  // @@protoc_insertion_point(class_scope:pbStoredUserData)
 private:
  inline void set_has_caprotsl();
  inline void clear_has_caprotsl();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::pbCapRoTsl* caprotsl_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_iwf_2eproto();
  friend void protobuf_AssignDesc_iwf_2eproto();
  friend void protobuf_ShutdownFile_iwf_2eproto();
  
  void InitAsDefaultInstance();
  static pbStoredUserData* default_instance_;
};
// -------------------------------------------------------------------

class pbIwfTimerData : public ::google::protobuf::Message {
 public:
  pbIwfTimerData();
  virtual ~pbIwfTimerData();
  
  pbIwfTimerData(const pbIwfTimerData& from);
  
  inline pbIwfTimerData& operator=(const pbIwfTimerData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const pbIwfTimerData& default_instance();
  
  void Swap(pbIwfTimerData* other);
  
  // implements Message ----------------------------------------------
  
  pbIwfTimerData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pbIwfTimerData& from);
  void MergeFrom(const pbIwfTimerData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef pbIwfTimerData_ETimerType ETimerType;
  static const ETimerType NO_EVENT_TIMER = pbIwfTimerData_ETimerType_NO_EVENT_TIMER;
  static const ETimerType FAKE_ACH_TIMER = pbIwfTimerData_ETimerType_FAKE_ACH_TIMER;
  static const ETimerType ACTIVITY_TIMER = pbIwfTimerData_ETimerType_ACTIVITY_TIMER;
  static const ETimerType ACH_DELTA_TIMER = pbIwfTimerData_ETimerType_ACH_DELTA_TIMER;
  static const ETimerType ACR_TIMER = pbIwfTimerData_ETimerType_ACR_TIMER;
  static const ETimerType CONNECT_MAX_CALL_DURATION = pbIwfTimerData_ETimerType_CONNECT_MAX_CALL_DURATION;
  static const ETimerType ACTIVITY_RESPONSE_TIMER = pbIwfTimerData_ETimerType_ACTIVITY_RESPONSE_TIMER;
  static const ETimerType IWF_SUBSCRIBER_AUDIT_TIMER = pbIwfTimerData_ETimerType_IWF_SUBSCRIBER_AUDIT_TIMER;
  static const ETimerType IWF_DCCA_TX_TIMER = pbIwfTimerData_ETimerType_IWF_DCCA_TX_TIMER;
  static const ETimerType IWF_ISFOLLOWN_TIMER = pbIwfTimerData_ETimerType_IWF_ISFOLLOWN_TIMER;
  static const ETimerType INVALID_TIMER = pbIwfTimerData_ETimerType_INVALID_TIMER;
  static inline bool ETimerType_IsValid(int value) {
    return pbIwfTimerData_ETimerType_IsValid(value);
  }
  static const ETimerType ETimerType_MIN =
    pbIwfTimerData_ETimerType_ETimerType_MIN;
  static const ETimerType ETimerType_MAX =
    pbIwfTimerData_ETimerType_ETimerType_MAX;
  static const int ETimerType_ARRAYSIZE =
    pbIwfTimerData_ETimerType_ETimerType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ETimerType_descriptor() {
    return pbIwfTimerData_ETimerType_descriptor();
  }
  static inline const ::std::string& ETimerType_Name(ETimerType value) {
    return pbIwfTimerData_ETimerType_Name(value);
  }
  static inline bool ETimerType_Parse(const ::std::string& name,
      ETimerType* value) {
    return pbIwfTimerData_ETimerType_Parse(name, value);
  }
  
  typedef pbIwfTimerData_EKeyType EKeyType;
  static const EKeyType INVLAID_KEY = pbIwfTimerData_EKeyType_INVLAID_KEY;
  static const EKeyType SESSION_ID = pbIwfTimerData_EKeyType_SESSION_ID;
  static const EKeyType DIALOG_ID = pbIwfTimerData_EKeyType_DIALOG_ID;
  static inline bool EKeyType_IsValid(int value) {
    return pbIwfTimerData_EKeyType_IsValid(value);
  }
  static const EKeyType EKeyType_MIN =
    pbIwfTimerData_EKeyType_EKeyType_MIN;
  static const EKeyType EKeyType_MAX =
    pbIwfTimerData_EKeyType_EKeyType_MAX;
  static const int EKeyType_ARRAYSIZE =
    pbIwfTimerData_EKeyType_EKeyType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EKeyType_descriptor() {
    return pbIwfTimerData_EKeyType_descriptor();
  }
  static inline const ::std::string& EKeyType_Name(EKeyType value) {
    return pbIwfTimerData_EKeyType_Name(value);
  }
  static inline bool EKeyType_Parse(const ::std::string& name,
      EKeyType* value) {
    return pbIwfTimerData_EKeyType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional .pbIwfTimerData.ETimerType m_eTimerType = 1;
  inline bool has_m_etimertype() const;
  inline void clear_m_etimertype();
  static const int kMETimerTypeFieldNumber = 1;
  inline ::pbIwfTimerData_ETimerType m_etimertype() const;
  inline void set_m_etimertype(::pbIwfTimerData_ETimerType value);
  
  // optional .pbIwfTimerData.EKeyType m_eKeyType = 2;
  inline bool has_m_ekeytype() const;
  inline void clear_m_ekeytype();
  static const int kMEKeyTypeFieldNumber = 2;
  inline ::pbIwfTimerData_EKeyType m_ekeytype() const;
  inline void set_m_ekeytype(::pbIwfTimerData_EKeyType value);
  
  // optional fixed32 m_tStartTime = 3;
  inline bool has_m_tstarttime() const;
  inline void clear_m_tstarttime();
  static const int kMTStartTimeFieldNumber = 3;
  inline ::google::protobuf::uint32 m_tstarttime() const;
  inline void set_m_tstarttime(::google::protobuf::uint32 value);
  
  // optional uint32 m_uiDuration = 4;
  inline bool has_m_uiduration() const;
  inline void clear_m_uiduration();
  static const int kMUiDurationFieldNumber = 4;
  inline ::google::protobuf::uint32 m_uiduration() const;
  inline void set_m_uiduration(::google::protobuf::uint32 value);
  
  // optional uint32 m_uiTimerId = 5;
  inline bool has_m_uitimerid() const;
  inline void clear_m_uitimerid();
  static const int kMUiTimerIdFieldNumber = 5;
  inline ::google::protobuf::uint32 m_uitimerid() const;
  inline void set_m_uitimerid(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:pbIwfTimerData)
 private:
  inline void set_has_m_etimertype();
  inline void clear_has_m_etimertype();
  inline void set_has_m_ekeytype();
  inline void clear_has_m_ekeytype();
  inline void set_has_m_tstarttime();
  inline void clear_has_m_tstarttime();
  inline void set_has_m_uiduration();
  inline void clear_has_m_uiduration();
  inline void set_has_m_uitimerid();
  inline void clear_has_m_uitimerid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int m_etimertype_;
  int m_ekeytype_;
  ::google::protobuf::uint32 m_tstarttime_;
  ::google::protobuf::uint32 m_uiduration_;
  ::google::protobuf::uint32 m_uitimerid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_iwf_2eproto();
  friend void protobuf_AssignDesc_iwf_2eproto();
  friend void protobuf_ShutdownFile_iwf_2eproto();
  
  void InitAsDefaultInstance();
  static pbIwfTimerData* default_instance_;
};
// -------------------------------------------------------------------

class pbSCCP_ADDR : public ::google::protobuf::Message {
 public:
  pbSCCP_ADDR();
  virtual ~pbSCCP_ADDR();
  
  pbSCCP_ADDR(const pbSCCP_ADDR& from);
  
  inline pbSCCP_ADDR& operator=(const pbSCCP_ADDR& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const pbSCCP_ADDR& default_instance();
  
  void Swap(pbSCCP_ADDR* other);
  
  // implements Message ----------------------------------------------
  
  pbSCCP_ADDR* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pbSCCP_ADDR& from);
  void MergeFrom(const pbSCCP_ADDR& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bytes addr = 1;
  inline bool has_addr() const;
  inline void clear_addr();
  static const int kAddrFieldNumber = 1;
  inline const ::std::string& addr() const;
  inline void set_addr(const ::std::string& value);
  inline void set_addr(const char* value);
  inline void set_addr(const void* value, size_t size);
  inline ::std::string* mutable_addr();
  inline ::std::string* release_addr();
  
  // optional uint32 length = 2;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 2;
  inline ::google::protobuf::uint32 length() const;
  inline void set_length(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:pbSCCP_ADDR)
 private:
  inline void set_has_addr();
  inline void clear_has_addr();
  inline void set_has_length();
  inline void clear_has_length();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* addr_;
  ::google::protobuf::uint32 length_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_iwf_2eproto();
  friend void protobuf_AssignDesc_iwf_2eproto();
  friend void protobuf_ShutdownFile_iwf_2eproto();
  
  void InitAsDefaultInstance();
  static pbSCCP_ADDR* default_instance_;
};
// -------------------------------------------------------------------

class pbMtp3_Header : public ::google::protobuf::Message {
 public:
  pbMtp3_Header();
  virtual ~pbMtp3_Header();
  
  pbMtp3_Header(const pbMtp3_Header& from);
  
  inline pbMtp3_Header& operator=(const pbMtp3_Header& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const pbMtp3_Header& default_instance();
  
  void Swap(pbMtp3_Header* other);
  
  // implements Message ----------------------------------------------
  
  pbMtp3_Header* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pbMtp3_Header& from);
  void MergeFrom(const pbMtp3_Header& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 sio = 1;
  inline bool has_sio() const;
  inline void clear_sio();
  static const int kSioFieldNumber = 1;
  inline ::google::protobuf::uint32 sio() const;
  inline void set_sio(::google::protobuf::uint32 value);
  
  // optional string label = 2;
  inline bool has_label() const;
  inline void clear_label();
  static const int kLabelFieldNumber = 2;
  inline const ::std::string& label() const;
  inline void set_label(const ::std::string& value);
  inline void set_label(const char* value);
  inline void set_label(const char* value, size_t size);
  inline ::std::string* mutable_label();
  inline ::std::string* release_label();
  
  // @@protoc_insertion_point(class_scope:pbMtp3_Header)
 private:
  inline void set_has_sio();
  inline void clear_has_sio();
  inline void set_has_label();
  inline void clear_has_label();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* label_;
  ::google::protobuf::uint32 sio_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_iwf_2eproto();
  friend void protobuf_AssignDesc_iwf_2eproto();
  friend void protobuf_ShutdownFile_iwf_2eproto();
  
  void InitAsDefaultInstance();
  static pbMtp3_Header* default_instance_;
};
// -------------------------------------------------------------------

class pbTcapTransactionData : public ::google::protobuf::Message {
 public:
  pbTcapTransactionData();
  virtual ~pbTcapTransactionData();
  
  pbTcapTransactionData(const pbTcapTransactionData& from);
  
  inline pbTcapTransactionData& operator=(const pbTcapTransactionData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const pbTcapTransactionData& default_instance();
  
  void Swap(pbTcapTransactionData* other);
  
  // implements Message ----------------------------------------------
  
  pbTcapTransactionData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pbTcapTransactionData& from);
  void MergeFrom(const pbTcapTransactionData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 lTid = 1;
  inline bool has_ltid() const;
  inline void clear_ltid();
  static const int kLTidFieldNumber = 1;
  inline ::google::protobuf::uint32 ltid() const;
  inline void set_ltid(::google::protobuf::uint32 value);
  
  // optional uint32 rTid = 2;
  inline bool has_rtid() const;
  inline void clear_rtid();
  static const int kRTidFieldNumber = 2;
  inline ::google::protobuf::uint32 rtid() const;
  inline void set_rtid(::google::protobuf::uint32 value);
  
  // optional .pbSCCP_ADDR oaddr = 3;
  inline bool has_oaddr() const;
  inline void clear_oaddr();
  static const int kOaddrFieldNumber = 3;
  inline const ::pbSCCP_ADDR& oaddr() const;
  inline ::pbSCCP_ADDR* mutable_oaddr();
  inline ::pbSCCP_ADDR* release_oaddr();
  
  // optional .pbSCCP_ADDR daddr = 4;
  inline bool has_daddr() const;
  inline void clear_daddr();
  static const int kDaddrFieldNumber = 4;
  inline const ::pbSCCP_ADDR& daddr() const;
  inline ::pbSCCP_ADDR* mutable_daddr();
  inline ::pbSCCP_ADDR* release_daddr();
  
  // optional .pbMtp3_Header label = 5;
  inline bool has_label() const;
  inline void clear_label();
  static const int kLabelFieldNumber = 5;
  inline const ::pbMtp3_Header& label() const;
  inline ::pbMtp3_Header* mutable_label();
  inline ::pbMtp3_Header* release_label();
  
  // optional .QualityOfService qos = 6;
  inline bool has_qos() const;
  inline void clear_qos();
  static const int kQosFieldNumber = 6;
  inline const ::QualityOfService& qos() const;
  inline ::QualityOfService* mutable_qos();
  inline ::QualityOfService* release_qos();
  
  // @@protoc_insertion_point(class_scope:pbTcapTransactionData)
 private:
  inline void set_has_ltid();
  inline void clear_has_ltid();
  inline void set_has_rtid();
  inline void clear_has_rtid();
  inline void set_has_oaddr();
  inline void clear_has_oaddr();
  inline void set_has_daddr();
  inline void clear_has_daddr();
  inline void set_has_label();
  inline void clear_has_label();
  inline void set_has_qos();
  inline void clear_has_qos();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 ltid_;
  ::google::protobuf::uint32 rtid_;
  ::pbSCCP_ADDR* oaddr_;
  ::pbSCCP_ADDR* daddr_;
  ::pbMtp3_Header* label_;
  ::QualityOfService* qos_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_iwf_2eproto();
  friend void protobuf_AssignDesc_iwf_2eproto();
  friend void protobuf_ShutdownFile_iwf_2eproto();
  
  void InitAsDefaultInstance();
  static pbTcapTransactionData* default_instance_;
};
// -------------------------------------------------------------------

class pbDiameterSessionData : public ::google::protobuf::Message {
 public:
  pbDiameterSessionData();
  virtual ~pbDiameterSessionData();
  
  pbDiameterSessionData(const pbDiameterSessionData& from);
  
  inline pbDiameterSessionData& operator=(const pbDiameterSessionData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const pbDiameterSessionData& default_instance();
  
  void Swap(pbDiameterSessionData* other);
  
  // implements Message ----------------------------------------------
  
  pbDiameterSessionData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pbDiameterSessionData& from);
  void MergeFrom(const pbDiameterSessionData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 peerInst = 1;
  inline bool has_peerinst() const;
  inline void clear_peerinst();
  static const int kPeerInstFieldNumber = 1;
  inline ::google::protobuf::uint32 peerinst() const;
  inline void set_peerinst(::google::protobuf::uint32 value);
  
  // optional uint32 timeout = 2;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 2;
  inline ::google::protobuf::uint32 timeout() const;
  inline void set_timeout(::google::protobuf::uint32 value);
  
  // optional uint32 lifetime = 3;
  inline bool has_lifetime() const;
  inline void clear_lifetime();
  static const int kLifetimeFieldNumber = 3;
  inline ::google::protobuf::uint32 lifetime() const;
  inline void set_lifetime(::google::protobuf::uint32 value);
  
  // optional uint32 gracePeriod = 4;
  inline bool has_graceperiod() const;
  inline void clear_graceperiod();
  static const int kGracePeriodFieldNumber = 4;
  inline ::google::protobuf::uint32 graceperiod() const;
  inline void set_graceperiod(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:pbDiameterSessionData)
 private:
  inline void set_has_peerinst();
  inline void clear_has_peerinst();
  inline void set_has_timeout();
  inline void clear_has_timeout();
  inline void set_has_lifetime();
  inline void clear_has_lifetime();
  inline void set_has_graceperiod();
  inline void clear_has_graceperiod();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 peerinst_;
  ::google::protobuf::uint32 timeout_;
  ::google::protobuf::uint32 lifetime_;
  ::google::protobuf::uint32 graceperiod_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_iwf_2eproto();
  friend void protobuf_AssignDesc_iwf_2eproto();
  friend void protobuf_ShutdownFile_iwf_2eproto();
  
  void InitAsDefaultInstance();
  static pbDiameterSessionData* default_instance_;
};
// -------------------------------------------------------------------

class pbIwfFsmInfo : public ::google::protobuf::Message {
 public:
  pbIwfFsmInfo();
  virtual ~pbIwfFsmInfo();
  
  pbIwfFsmInfo(const pbIwfFsmInfo& from);
  
  inline pbIwfFsmInfo& operator=(const pbIwfFsmInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const pbIwfFsmInfo& default_instance();
  
  void Swap(pbIwfFsmInfo* other);
  
  // implements Message ----------------------------------------------
  
  pbIwfFsmInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pbIwfFsmInfo& from);
  void MergeFrom(const pbIwfFsmInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .pbState current = 1;
  inline bool has_current() const;
  inline void clear_current();
  static const int kCurrentFieldNumber = 1;
  inline const ::pbState& current() const;
  inline ::pbState* mutable_current();
  inline ::pbState* release_current();
  
  // required .pbState prevState = 2;
  inline bool has_prevstate() const;
  inline void clear_prevstate();
  static const int kPrevStateFieldNumber = 2;
  inline const ::pbState& prevstate() const;
  inline ::pbState* mutable_prevstate();
  inline ::pbState* release_prevstate();
  
  // optional .pbProtocol UpstrmReqProtocol = 3 [default = DIAMETER_S6A];
  inline bool has_upstrmreqprotocol() const;
  inline void clear_upstrmreqprotocol();
  static const int kUpstrmReqProtocolFieldNumber = 3;
  inline pbProtocol upstrmreqprotocol() const;
  inline void set_upstrmreqprotocol(pbProtocol value);
  
  // optional .pbProtocol DnstrmReqProtocol = 4 [default = MAP_GR];
  inline bool has_dnstrmreqprotocol() const;
  inline void clear_dnstrmreqprotocol();
  static const int kDnstrmReqProtocolFieldNumber = 4;
  inline pbProtocol dnstrmreqprotocol() const;
  inline void set_dnstrmreqprotocol(pbProtocol value);
  
  // optional uint32 diasessionIdx = 5 [default = 0];
  inline bool has_diasessionidx() const;
  inline void clear_diasessionidx();
  static const int kDiasessionIdxFieldNumber = 5;
  inline ::google::protobuf::uint32 diasessionidx() const;
  inline void set_diasessionidx(::google::protobuf::uint32 value);
  
  // required string diaSessionId = 6 [default = ""];
  inline bool has_diasessionid() const;
  inline void clear_diasessionid();
  static const int kDiaSessionIdFieldNumber = 6;
  inline const ::std::string& diasessionid() const;
  inline void set_diasessionid(const ::std::string& value);
  inline void set_diasessionid(const char* value);
  inline void set_diasessionid(const char* value, size_t size);
  inline ::std::string* mutable_diasessionid();
  inline ::std::string* release_diasessionid();
  
  // required uint32 tcapDialogueId = 7 [default = 0];
  inline bool has_tcapdialogueid() const;
  inline void clear_tcapdialogueid();
  static const int kTcapDialogueIdFieldNumber = 7;
  inline ::google::protobuf::uint32 tcapdialogueid() const;
  inline void set_tcapdialogueid(::google::protobuf::uint32 value);
  
  // optional .pbDiaMsg currRcvdDiaMsg = 8;
  inline bool has_currrcvddiamsg() const;
  inline void clear_currrcvddiamsg();
  static const int kCurrRcvdDiaMsgFieldNumber = 8;
  inline const ::pbDiaMsg& currrcvddiamsg() const;
  inline ::pbDiaMsg* mutable_currrcvddiamsg();
  inline ::pbDiaMsg* release_currrcvddiamsg();
  
  // optional .pbTcapDialogue currRcvdTcapDlg = 9;
  inline bool has_currrcvdtcapdlg() const;
  inline void clear_currrcvdtcapdlg();
  static const int kCurrRcvdTcapDlgFieldNumber = 9;
  inline const ::pbTcapDialogue& currrcvdtcapdlg() const;
  inline ::pbTcapDialogue* mutable_currrcvdtcapdlg();
  inline ::pbTcapDialogue* release_currrcvdtcapdlg();
  
  // optional .pbTcapComponent currRcvdTcapCpt = 10;
  inline bool has_currrcvdtcapcpt() const;
  inline void clear_currrcvdtcapcpt();
  static const int kCurrRcvdTcapCptFieldNumber = 10;
  inline const ::pbTcapComponent& currrcvdtcapcpt() const;
  inline ::pbTcapComponent* mutable_currrcvdtcapcpt();
  inline ::pbTcapComponent* release_currrcvdtcapcpt();
  
  // optional .pbTcapBeginDialogue currTcapBeginDlg = 11;
  inline bool has_currtcapbegindlg() const;
  inline void clear_currtcapbegindlg();
  static const int kCurrTcapBeginDlgFieldNumber = 11;
  inline const ::pbTcapBeginDialogue& currtcapbegindlg() const;
  inline ::pbTcapBeginDialogue* mutable_currtcapbegindlg();
  inline ::pbTcapBeginDialogue* release_currtcapbegindlg();
  
  // optional bool isCurrSendErr = 12;
  inline bool has_iscurrsenderr() const;
  inline void clear_iscurrsenderr();
  static const int kIsCurrSendErrFieldNumber = 12;
  inline bool iscurrsenderr() const;
  inline void set_iscurrsenderr(bool value);
  
  // optional .pbStoredUserData userData = 13;
  inline bool has_userdata() const;
  inline void clear_userdata();
  static const int kUserDataFieldNumber = 13;
  inline const ::pbStoredUserData& userdata() const;
  inline ::pbStoredUserData* mutable_userdata();
  inline ::pbStoredUserData* release_userdata();
  
  // optional int32 errCode = 14 [default = 0];
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrCodeFieldNumber = 14;
  inline ::google::protobuf::int32 errcode() const;
  inline void set_errcode(::google::protobuf::int32 value);
  
  // optional string username = 15;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 15;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  
  // optional .pbSCCPParameters sccpParams = 16;
  inline bool has_sccpparams() const;
  inline void clear_sccpparams();
  static const int kSccpParamsFieldNumber = 16;
  inline const ::pbSCCPParameters& sccpparams() const;
  inline ::pbSCCPParameters* mutable_sccpparams();
  inline ::pbSCCPParameters* release_sccpparams();
  
  // optional string sgsnAddress = 17;
  inline bool has_sgsnaddress() const;
  inline void clear_sgsnaddress();
  static const int kSgsnAddressFieldNumber = 17;
  inline const ::std::string& sgsnaddress() const;
  inline void set_sgsnaddress(const ::std::string& value);
  inline void set_sgsnaddress(const char* value);
  inline void set_sgsnaddress(const char* value, size_t size);
  inline ::std::string* mutable_sgsnaddress();
  inline ::std::string* release_sgsnaddress();
  
  // optional bool IsDiaRespSent = 18;
  inline bool has_isdiarespsent() const;
  inline void clear_isdiarespsent();
  static const int kIsDiaRespSentFieldNumber = 18;
  inline bool isdiarespsent() const;
  inline void set_isdiarespsent(bool value);
  
  // optional bool isrouteByGT = 19 [default = false];
  inline bool has_isroutebygt() const;
  inline void clear_isroutebygt();
  static const int kIsrouteByGTFieldNumber = 19;
  inline bool isroutebygt() const;
  inline void set_isroutebygt(bool value);
  
  // optional .pbIwfTranslator translator = 20;
  inline bool has_translator() const;
  inline void clear_translator();
  static const int kTranslatorFieldNumber = 20;
  inline const ::pbIwfTranslator& translator() const;
  inline ::pbIwfTranslator* mutable_translator();
  inline ::pbIwfTranslator* release_translator();
  
  // optional .pbRoutingLabel routingLabel = 21;
  inline bool has_routinglabel() const;
  inline void clear_routinglabel();
  static const int kRoutingLabelFieldNumber = 21;
  inline const ::pbRoutingLabel& routinglabel() const;
  inline ::pbRoutingLabel* mutable_routinglabel();
  inline ::pbRoutingLabel* release_routinglabel();
  
  // optional uint32 invokeId = 22 [default = 0];
  inline bool has_invokeid() const;
  inline void clear_invokeid();
  static const int kInvokeIdFieldNumber = 22;
  inline ::google::protobuf::uint32 invokeid() const;
  inline void set_invokeid(::google::protobuf::uint32 value);
  
  // optional .pbSccpAddress selfSccpAddr = 23;
  inline bool has_selfsccpaddr() const;
  inline void clear_selfsccpaddr();
  static const int kSelfSccpAddrFieldNumber = 23;
  inline const ::pbSccpAddress& selfsccpaddr() const;
  inline ::pbSccpAddress* mutable_selfsccpaddr();
  inline ::pbSccpAddress* release_selfsccpaddr();
  
  // optional bool isTcapEnd = 24 [default = false];
  inline bool has_istcapend() const;
  inline void clear_istcapend();
  static const int kIsTcapEndFieldNumber = 24;
  inline bool istcapend() const;
  inline void set_istcapend(bool value);
  
  // optional bool startNoEventTimer = 25 [default = false];
  inline bool has_startnoeventtimer() const;
  inline void clear_startnoeventtimer();
  static const int kStartNoEventTimerFieldNumber = 25;
  inline bool startnoeventtimer() const;
  inline void set_startnoeventtimer(bool value);
  
  // optional bool isFinalUpstrmReqSent = 26;
  inline bool has_isfinalupstrmreqsent() const;
  inline void clear_isfinalupstrmreqsent();
  static const int kIsFinalUpstrmReqSentFieldNumber = 26;
  inline bool isfinalupstrmreqsent() const;
  inline void set_isfinalupstrmreqsent(bool value);
  
  // optional bool markForRollback = 27 [default = false];
  inline bool has_markforrollback() const;
  inline void clear_markforrollback();
  static const int kMarkForRollbackFieldNumber = 27;
  inline bool markforrollback() const;
  inline void set_markforrollback(bool value);
  
  // optional bool flowFailure = 28 [default = false];
  inline bool has_flowfailure() const;
  inline void clear_flowfailure();
  static const int kFlowFailureFieldNumber = 28;
  inline bool flowfailure() const;
  inline void set_flowfailure(bool value);
  
  // optional bool isCloseState = 29 [default = false];
  inline bool has_isclosestate() const;
  inline void clear_isclosestate();
  static const int kIsCloseStateFieldNumber = 29;
  inline bool isclosestate() const;
  inline void set_isclosestate(bool value);
  
  // repeated .pbIwfTimerData timerInfo = 30;
  inline int timerinfo_size() const;
  inline void clear_timerinfo();
  static const int kTimerInfoFieldNumber = 30;
  inline const ::pbIwfTimerData& timerinfo(int index) const;
  inline ::pbIwfTimerData* mutable_timerinfo(int index);
  inline ::pbIwfTimerData* add_timerinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::pbIwfTimerData >&
      timerinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::pbIwfTimerData >*
      mutable_timerinfo();
  
  // optional .pbTcapTransactionData tcapInfo = 31;
  inline bool has_tcapinfo() const;
  inline void clear_tcapinfo();
  static const int kTcapInfoFieldNumber = 31;
  inline const ::pbTcapTransactionData& tcapinfo() const;
  inline ::pbTcapTransactionData* mutable_tcapinfo();
  inline ::pbTcapTransactionData* release_tcapinfo();
  
  // optional .pbDiameterSessionData diameterInfo = 32;
  inline bool has_diameterinfo() const;
  inline void clear_diameterinfo();
  static const int kDiameterInfoFieldNumber = 32;
  inline const ::pbDiameterSessionData& diameterinfo() const;
  inline ::pbDiameterSessionData* mutable_diameterinfo();
  inline ::pbDiameterSessionData* release_diameterinfo();
  
  // optional fixed32 freeListKey = 33;
  inline bool has_freelistkey() const;
  inline void clear_freelistkey();
  static const int kFreeListKeyFieldNumber = 33;
  inline ::google::protobuf::uint32 freelistkey() const;
  inline void set_freelistkey(::google::protobuf::uint32 value);
  
  // optional string actionRuleName = 34 [default = ""];
  inline bool has_actionrulename() const;
  inline void clear_actionrulename();
  static const int kActionRuleNameFieldNumber = 34;
  inline const ::std::string& actionrulename() const;
  inline void set_actionrulename(const ::std::string& value);
  inline void set_actionrulename(const char* value);
  inline void set_actionrulename(const char* value, size_t size);
  inline ::std::string* mutable_actionrulename();
  inline ::std::string* release_actionrulename();
  
  // optional .pbSccpAddress callingSccpAddr = 35;
  inline bool has_callingsccpaddr() const;
  inline void clear_callingsccpaddr();
  static const int kCallingSccpAddrFieldNumber = 35;
  inline const ::pbSccpAddress& callingsccpaddr() const;
  inline ::pbSccpAddress* mutable_callingsccpaddr();
  inline ::pbSccpAddress* release_callingsccpaddr();
  
  // optional fixed32 lastSentTcapCptopcode = 36;
  inline bool has_lastsenttcapcptopcode() const;
  inline void clear_lastsenttcapcptopcode();
  static const int kLastSentTcapCptopcodeFieldNumber = 36;
  inline ::google::protobuf::uint32 lastsenttcapcptopcode() const;
  inline void set_lastsenttcapcptopcode(::google::protobuf::uint32 value);
  
  // optional bool isCCFHActionTaken = 37 [default = false];
  inline bool has_isccfhactiontaken() const;
  inline void clear_isccfhactiontaken();
  static const int kIsCCFHActionTakenFieldNumber = 37;
  inline bool isccfhactiontaken() const;
  inline void set_isccfhactiontaken(bool value);
  
  // optional bool dontTriggerFollowOnSessionforCCAUError = 38 [default = false];
  inline bool has_donttriggerfollowonsessionforccauerror() const;
  inline void clear_donttriggerfollowonsessionforccauerror();
  static const int kDontTriggerFollowOnSessionforCCAUErrorFieldNumber = 38;
  inline bool donttriggerfollowonsessionforccauerror() const;
  inline void set_donttriggerfollowonsessionforccauerror(bool value);
  
  // @@protoc_insertion_point(class_scope:pbIwfFsmInfo)
 private:
  inline void set_has_current();
  inline void clear_has_current();
  inline void set_has_prevstate();
  inline void clear_has_prevstate();
  inline void set_has_upstrmreqprotocol();
  inline void clear_has_upstrmreqprotocol();
  inline void set_has_dnstrmreqprotocol();
  inline void clear_has_dnstrmreqprotocol();
  inline void set_has_diasessionidx();
  inline void clear_has_diasessionidx();
  inline void set_has_diasessionid();
  inline void clear_has_diasessionid();
  inline void set_has_tcapdialogueid();
  inline void clear_has_tcapdialogueid();
  inline void set_has_currrcvddiamsg();
  inline void clear_has_currrcvddiamsg();
  inline void set_has_currrcvdtcapdlg();
  inline void clear_has_currrcvdtcapdlg();
  inline void set_has_currrcvdtcapcpt();
  inline void clear_has_currrcvdtcapcpt();
  inline void set_has_currtcapbegindlg();
  inline void clear_has_currtcapbegindlg();
  inline void set_has_iscurrsenderr();
  inline void clear_has_iscurrsenderr();
  inline void set_has_userdata();
  inline void clear_has_userdata();
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_sccpparams();
  inline void clear_has_sccpparams();
  inline void set_has_sgsnaddress();
  inline void clear_has_sgsnaddress();
  inline void set_has_isdiarespsent();
  inline void clear_has_isdiarespsent();
  inline void set_has_isroutebygt();
  inline void clear_has_isroutebygt();
  inline void set_has_translator();
  inline void clear_has_translator();
  inline void set_has_routinglabel();
  inline void clear_has_routinglabel();
  inline void set_has_invokeid();
  inline void clear_has_invokeid();
  inline void set_has_selfsccpaddr();
  inline void clear_has_selfsccpaddr();
  inline void set_has_istcapend();
  inline void clear_has_istcapend();
  inline void set_has_startnoeventtimer();
  inline void clear_has_startnoeventtimer();
  inline void set_has_isfinalupstrmreqsent();
  inline void clear_has_isfinalupstrmreqsent();
  inline void set_has_markforrollback();
  inline void clear_has_markforrollback();
  inline void set_has_flowfailure();
  inline void clear_has_flowfailure();
  inline void set_has_isclosestate();
  inline void clear_has_isclosestate();
  inline void set_has_tcapinfo();
  inline void clear_has_tcapinfo();
  inline void set_has_diameterinfo();
  inline void clear_has_diameterinfo();
  inline void set_has_freelistkey();
  inline void clear_has_freelistkey();
  inline void set_has_actionrulename();
  inline void clear_has_actionrulename();
  inline void set_has_callingsccpaddr();
  inline void clear_has_callingsccpaddr();
  inline void set_has_lastsenttcapcptopcode();
  inline void clear_has_lastsenttcapcptopcode();
  inline void set_has_isccfhactiontaken();
  inline void clear_has_isccfhactiontaken();
  inline void set_has_donttriggerfollowonsessionforccauerror();
  inline void clear_has_donttriggerfollowonsessionforccauerror();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::pbState* current_;
  ::pbState* prevstate_;
  int upstrmreqprotocol_;
  int dnstrmreqprotocol_;
  ::std::string* diasessionid_;
  ::google::protobuf::uint32 diasessionidx_;
  ::google::protobuf::uint32 tcapdialogueid_;
  ::pbDiaMsg* currrcvddiamsg_;
  ::pbTcapDialogue* currrcvdtcapdlg_;
  ::pbTcapComponent* currrcvdtcapcpt_;
  ::pbTcapBeginDialogue* currtcapbegindlg_;
  ::pbStoredUserData* userdata_;
  ::std::string* username_;
  ::pbSCCPParameters* sccpparams_;
  ::std::string* sgsnaddress_;
  ::google::protobuf::int32 errcode_;
  bool iscurrsenderr_;
  bool isdiarespsent_;
  bool isroutebygt_;
  bool istcapend_;
  ::pbIwfTranslator* translator_;
  ::pbRoutingLabel* routinglabel_;
  ::pbSccpAddress* selfsccpaddr_;
  ::google::protobuf::uint32 invokeid_;
  bool startnoeventtimer_;
  bool isfinalupstrmreqsent_;
  bool markforrollback_;
  bool flowfailure_;
  ::google::protobuf::RepeatedPtrField< ::pbIwfTimerData > timerinfo_;
  ::pbTcapTransactionData* tcapinfo_;
  ::pbDiameterSessionData* diameterinfo_;
  ::std::string* actionrulename_;
  ::google::protobuf::uint32 freelistkey_;
  bool isclosestate_;
  bool isccfhactiontaken_;
  bool donttriggerfollowonsessionforccauerror_;
  ::pbSccpAddress* callingsccpaddr_;
  ::google::protobuf::uint32 lastsenttcapcptopcode_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(38 + 31) / 32];
  
  friend void  protobuf_AddDesc_iwf_2eproto();
  friend void protobuf_AssignDesc_iwf_2eproto();
  friend void protobuf_ShutdownFile_iwf_2eproto();
  
  void InitAsDefaultInstance();
  static pbIwfFsmInfo* default_instance_;
};
// -------------------------------------------------------------------

class pbIwfSessionContextData : public ::google::protobuf::Message {
 public:
  pbIwfSessionContextData();
  virtual ~pbIwfSessionContextData();
  
  pbIwfSessionContextData(const pbIwfSessionContextData& from);
  
  inline pbIwfSessionContextData& operator=(const pbIwfSessionContextData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const pbIwfSessionContextData& default_instance();
  
  void Swap(pbIwfSessionContextData* other);
  
  // implements Message ----------------------------------------------
  
  pbIwfSessionContextData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pbIwfSessionContextData& from);
  void MergeFrom(const pbIwfSessionContextData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string originHost = 1;
  inline bool has_originhost() const;
  inline void clear_originhost();
  static const int kOriginHostFieldNumber = 1;
  inline const ::std::string& originhost() const;
  inline void set_originhost(const ::std::string& value);
  inline void set_originhost(const char* value);
  inline void set_originhost(const char* value, size_t size);
  inline ::std::string* mutable_originhost();
  inline ::std::string* release_originhost();
  
  // optional string originRealm = 2;
  inline bool has_originrealm() const;
  inline void clear_originrealm();
  static const int kOriginRealmFieldNumber = 2;
  inline const ::std::string& originrealm() const;
  inline void set_originrealm(const ::std::string& value);
  inline void set_originrealm(const char* value);
  inline void set_originrealm(const char* value, size_t size);
  inline ::std::string* mutable_originrealm();
  inline ::std::string* release_originrealm();
  
  // optional string oldHost = 3;
  inline bool has_oldhost() const;
  inline void clear_oldhost();
  static const int kOldHostFieldNumber = 3;
  inline const ::std::string& oldhost() const;
  inline void set_oldhost(const ::std::string& value);
  inline void set_oldhost(const char* value);
  inline void set_oldhost(const char* value, size_t size);
  inline ::std::string* mutable_oldhost();
  inline ::std::string* release_oldhost();
  
  // optional string oldRealm = 4;
  inline bool has_oldrealm() const;
  inline void clear_oldrealm();
  static const int kOldRealmFieldNumber = 4;
  inline const ::std::string& oldrealm() const;
  inline void set_oldrealm(const ::std::string& value);
  inline void set_oldrealm(const char* value);
  inline void set_oldrealm(const char* value, size_t size);
  inline ::std::string* mutable_oldrealm();
  inline ::std::string* release_oldrealm();
  
  // optional .pbSCCPParameters sccpParameters = 5;
  inline bool has_sccpparameters() const;
  inline void clear_sccpparameters();
  static const int kSccpParametersFieldNumber = 5;
  inline const ::pbSCCPParameters& sccpparameters() const;
  inline ::pbSCCPParameters* mutable_sccpparameters();
  inline ::pbSCCPParameters* release_sccpparameters();
  
  // optional .pbSccpAddress oldcpaitu = 6;
  inline bool has_oldcpaitu() const;
  inline void clear_oldcpaitu();
  static const int kOldcpaituFieldNumber = 6;
  inline const ::pbSccpAddress& oldcpaitu() const;
  inline ::pbSccpAddress* mutable_oldcpaitu();
  inline ::pbSccpAddress* release_oldcpaitu();
  
  // optional bool OldCallingPartyAddrpresent = 7;
  inline bool has_oldcallingpartyaddrpresent() const;
  inline void clear_oldcallingpartyaddrpresent();
  static const int kOldCallingPartyAddrpresentFieldNumber = 7;
  inline bool oldcallingpartyaddrpresent() const;
  inline void set_oldcallingpartyaddrpresent(bool value);
  
  // optional fixed32 oldopc = 8;
  inline bool has_oldopc() const;
  inline void clear_oldopc();
  static const int kOldopcFieldNumber = 8;
  inline ::google::protobuf::uint32 oldopc() const;
  inline void set_oldopc(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:pbIwfSessionContextData)
 private:
  inline void set_has_originhost();
  inline void clear_has_originhost();
  inline void set_has_originrealm();
  inline void clear_has_originrealm();
  inline void set_has_oldhost();
  inline void clear_has_oldhost();
  inline void set_has_oldrealm();
  inline void clear_has_oldrealm();
  inline void set_has_sccpparameters();
  inline void clear_has_sccpparameters();
  inline void set_has_oldcpaitu();
  inline void clear_has_oldcpaitu();
  inline void set_has_oldcallingpartyaddrpresent();
  inline void clear_has_oldcallingpartyaddrpresent();
  inline void set_has_oldopc();
  inline void clear_has_oldopc();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* originhost_;
  ::std::string* originrealm_;
  ::std::string* oldhost_;
  ::std::string* oldrealm_;
  ::pbSCCPParameters* sccpparameters_;
  ::pbSccpAddress* oldcpaitu_;
  bool oldcallingpartyaddrpresent_;
  ::google::protobuf::uint32 oldopc_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_iwf_2eproto();
  friend void protobuf_AssignDesc_iwf_2eproto();
  friend void protobuf_ShutdownFile_iwf_2eproto();
  
  void InitAsDefaultInstance();
  static pbIwfSessionContextData* default_instance_;
};
// ===================================================================


// ===================================================================

// pbState

// optional uint32 Id = 1;
inline bool pbState::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pbState::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pbState::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pbState::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 pbState::id() const {
  return id_;
}
inline void pbState::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional string Name = 2;
inline bool pbState::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pbState::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pbState::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pbState::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& pbState::name() const {
  return *name_;
}
inline void pbState::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void pbState::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void pbState::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbState::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* pbState::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// pbIwfTranslator

// optional string Name = 1;
inline bool pbIwfTranslator::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pbIwfTranslator::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pbIwfTranslator::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pbIwfTranslator::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& pbIwfTranslator::name() const {
  return *name_;
}
inline void pbIwfTranslator::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void pbIwfTranslator::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void pbIwfTranslator::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbIwfTranslator::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* pbIwfTranslator::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 Id = 2;
inline bool pbIwfTranslator::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pbIwfTranslator::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pbIwfTranslator::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pbIwfTranslator::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 pbIwfTranslator::id() const {
  return id_;
}
inline void pbIwfTranslator::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// pbRoutingLabel

// optional uint32 oPc = 1;
inline bool pbRoutingLabel::has_opc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pbRoutingLabel::set_has_opc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pbRoutingLabel::clear_has_opc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pbRoutingLabel::clear_opc() {
  opc_ = 0u;
  clear_has_opc();
}
inline ::google::protobuf::uint32 pbRoutingLabel::opc() const {
  return opc_;
}
inline void pbRoutingLabel::set_opc(::google::protobuf::uint32 value) {
  set_has_opc();
  opc_ = value;
}

// optional bool isNational = 2;
inline bool pbRoutingLabel::has_isnational() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pbRoutingLabel::set_has_isnational() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pbRoutingLabel::clear_has_isnational() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pbRoutingLabel::clear_isnational() {
  isnational_ = false;
  clear_has_isnational();
}
inline bool pbRoutingLabel::isnational() const {
  return isnational_;
}
inline void pbRoutingLabel::set_isnational(bool value) {
  set_has_isnational();
  isnational_ = value;
}

// optional uint32 oSsn = 3;
inline bool pbRoutingLabel::has_ossn() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void pbRoutingLabel::set_has_ossn() {
  _has_bits_[0] |= 0x00000004u;
}
inline void pbRoutingLabel::clear_has_ossn() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void pbRoutingLabel::clear_ossn() {
  ossn_ = 0u;
  clear_has_ossn();
}
inline ::google::protobuf::uint32 pbRoutingLabel::ossn() const {
  return ossn_;
}
inline void pbRoutingLabel::set_ossn(::google::protobuf::uint32 value) {
  set_has_ossn();
  ossn_ = value;
}

// optional bool useSccpCdPAFromInMsg = 4;
inline bool pbRoutingLabel::has_usesccpcdpafrominmsg() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void pbRoutingLabel::set_has_usesccpcdpafrominmsg() {
  _has_bits_[0] |= 0x00000008u;
}
inline void pbRoutingLabel::clear_has_usesccpcdpafrominmsg() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void pbRoutingLabel::clear_usesccpcdpafrominmsg() {
  usesccpcdpafrominmsg_ = false;
  clear_has_usesccpcdpafrominmsg();
}
inline bool pbRoutingLabel::usesccpcdpafrominmsg() const {
  return usesccpcdpafrominmsg_;
}
inline void pbRoutingLabel::set_usesccpcdpafrominmsg(bool value) {
  set_has_usesccpcdpafrominmsg();
  usesccpcdpafrominmsg_ = value;
}

// -------------------------------------------------------------------

// pbDiaMsg

// optional uint32 CommandCode = 1;
inline bool pbDiaMsg::has_commandcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pbDiaMsg::set_has_commandcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pbDiaMsg::clear_has_commandcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pbDiaMsg::clear_commandcode() {
  commandcode_ = 0u;
  clear_has_commandcode();
}
inline ::google::protobuf::uint32 pbDiaMsg::commandcode() const {
  return commandcode_;
}
inline void pbDiaMsg::set_commandcode(::google::protobuf::uint32 value) {
  set_has_commandcode();
  commandcode_ = value;
}

// optional bool RequestBit = 2;
inline bool pbDiaMsg::has_requestbit() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pbDiaMsg::set_has_requestbit() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pbDiaMsg::clear_has_requestbit() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pbDiaMsg::clear_requestbit() {
  requestbit_ = false;
  clear_has_requestbit();
}
inline bool pbDiaMsg::requestbit() const {
  return requestbit_;
}
inline void pbDiaMsg::set_requestbit(bool value) {
  set_has_requestbit();
  requestbit_ = value;
}

// optional string username = 3;
inline bool pbDiaMsg::has_username() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void pbDiaMsg::set_has_username() {
  _has_bits_[0] |= 0x00000004u;
}
inline void pbDiaMsg::clear_has_username() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void pbDiaMsg::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& pbDiaMsg::username() const {
  return *username_;
}
inline void pbDiaMsg::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void pbDiaMsg::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void pbDiaMsg::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbDiaMsg::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* pbDiaMsg::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string SessionId = 4;
inline bool pbDiaMsg::has_sessionid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void pbDiaMsg::set_has_sessionid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void pbDiaMsg::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void pbDiaMsg::clear_sessionid() {
  if (sessionid_ != &::google::protobuf::internal::kEmptyString) {
    sessionid_->clear();
  }
  clear_has_sessionid();
}
inline const ::std::string& pbDiaMsg::sessionid() const {
  return *sessionid_;
}
inline void pbDiaMsg::set_sessionid(const ::std::string& value) {
  set_has_sessionid();
  if (sessionid_ == &::google::protobuf::internal::kEmptyString) {
    sessionid_ = new ::std::string;
  }
  sessionid_->assign(value);
}
inline void pbDiaMsg::set_sessionid(const char* value) {
  set_has_sessionid();
  if (sessionid_ == &::google::protobuf::internal::kEmptyString) {
    sessionid_ = new ::std::string;
  }
  sessionid_->assign(value);
}
inline void pbDiaMsg::set_sessionid(const char* value, size_t size) {
  set_has_sessionid();
  if (sessionid_ == &::google::protobuf::internal::kEmptyString) {
    sessionid_ = new ::std::string;
  }
  sessionid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbDiaMsg::mutable_sessionid() {
  set_has_sessionid();
  if (sessionid_ == &::google::protobuf::internal::kEmptyString) {
    sessionid_ = new ::std::string;
  }
  return sessionid_;
}
inline ::std::string* pbDiaMsg::release_sessionid() {
  clear_has_sessionid();
  if (sessionid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sessionid_;
    sessionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// pbSccpAddress

// optional string id = 1;
inline bool pbSccpAddress::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pbSccpAddress::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pbSccpAddress::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pbSccpAddress::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& pbSccpAddress::id() const {
  return *id_;
}
inline void pbSccpAddress::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void pbSccpAddress::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void pbSccpAddress::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbSccpAddress::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* pbSccpAddress::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool hasPc = 2;
inline bool pbSccpAddress::has_haspc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pbSccpAddress::set_has_haspc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pbSccpAddress::clear_has_haspc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pbSccpAddress::clear_haspc() {
  haspc_ = false;
  clear_has_haspc();
}
inline bool pbSccpAddress::haspc() const {
  return haspc_;
}
inline void pbSccpAddress::set_haspc(bool value) {
  set_has_haspc();
  haspc_ = value;
}

// optional bool hasSsn = 3;
inline bool pbSccpAddress::has_hasssn() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void pbSccpAddress::set_has_hasssn() {
  _has_bits_[0] |= 0x00000004u;
}
inline void pbSccpAddress::clear_has_hasssn() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void pbSccpAddress::clear_hasssn() {
  hasssn_ = false;
  clear_has_hasssn();
}
inline bool pbSccpAddress::hasssn() const {
  return hasssn_;
}
inline void pbSccpAddress::set_hasssn(bool value) {
  set_has_hasssn();
  hasssn_ = value;
}

// optional bool routePCSSN = 4;
inline bool pbSccpAddress::has_routepcssn() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void pbSccpAddress::set_has_routepcssn() {
  _has_bits_[0] |= 0x00000008u;
}
inline void pbSccpAddress::clear_has_routepcssn() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void pbSccpAddress::clear_routepcssn() {
  routepcssn_ = false;
  clear_has_routepcssn();
}
inline bool pbSccpAddress::routepcssn() const {
  return routepcssn_;
}
inline void pbSccpAddress::set_routepcssn(bool value) {
  set_has_routepcssn();
  routepcssn_ = value;
}

// optional bool internationalRoute = 5;
inline bool pbSccpAddress::has_internationalroute() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void pbSccpAddress::set_has_internationalroute() {
  _has_bits_[0] |= 0x00000010u;
}
inline void pbSccpAddress::clear_has_internationalroute() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void pbSccpAddress::clear_internationalroute() {
  internationalroute_ = false;
  clear_has_internationalroute();
}
inline bool pbSccpAddress::internationalroute() const {
  return internationalroute_;
}
inline void pbSccpAddress::set_internationalroute(bool value) {
  set_has_internationalroute();
  internationalroute_ = value;
}

// optional bool globalTitle = 6;
inline bool pbSccpAddress::has_globaltitle() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void pbSccpAddress::set_has_globaltitle() {
  _has_bits_[0] |= 0x00000020u;
}
inline void pbSccpAddress::clear_has_globaltitle() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void pbSccpAddress::clear_globaltitle() {
  globaltitle_ = false;
  clear_has_globaltitle();
}
inline bool pbSccpAddress::globaltitle() const {
  return globaltitle_;
}
inline void pbSccpAddress::set_globaltitle(bool value) {
  set_has_globaltitle();
  globaltitle_ = value;
}

// optional uint32 PointCode = 7;
inline bool pbSccpAddress::has_pointcode() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void pbSccpAddress::set_has_pointcode() {
  _has_bits_[0] |= 0x00000040u;
}
inline void pbSccpAddress::clear_has_pointcode() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void pbSccpAddress::clear_pointcode() {
  pointcode_ = 0u;
  clear_has_pointcode();
}
inline ::google::protobuf::uint32 pbSccpAddress::pointcode() const {
  return pointcode_;
}
inline void pbSccpAddress::set_pointcode(::google::protobuf::uint32 value) {
  set_has_pointcode();
  pointcode_ = value;
}

// optional uint32 ssn = 8;
inline bool pbSccpAddress::has_ssn() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void pbSccpAddress::set_has_ssn() {
  _has_bits_[0] |= 0x00000080u;
}
inline void pbSccpAddress::clear_has_ssn() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void pbSccpAddress::clear_ssn() {
  ssn_ = 0u;
  clear_has_ssn();
}
inline ::google::protobuf::uint32 pbSccpAddress::ssn() const {
  return ssn_;
}
inline void pbSccpAddress::set_ssn(::google::protobuf::uint32 value) {
  set_has_ssn();
  ssn_ = value;
}

// optional uint32 gttlen = 9;
inline bool pbSccpAddress::has_gttlen() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void pbSccpAddress::set_has_gttlen() {
  _has_bits_[0] |= 0x00000100u;
}
inline void pbSccpAddress::clear_has_gttlen() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void pbSccpAddress::clear_gttlen() {
  gttlen_ = 0u;
  clear_has_gttlen();
}
inline ::google::protobuf::uint32 pbSccpAddress::gttlen() const {
  return gttlen_;
}
inline void pbSccpAddress::set_gttlen(::google::protobuf::uint32 value) {
  set_has_gttlen();
  gttlen_ = value;
}

// optional bytes globTitle = 10;
inline bool pbSccpAddress::has_globtitle() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void pbSccpAddress::set_has_globtitle() {
  _has_bits_[0] |= 0x00000200u;
}
inline void pbSccpAddress::clear_has_globtitle() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void pbSccpAddress::clear_globtitle() {
  if (globtitle_ != &::google::protobuf::internal::kEmptyString) {
    globtitle_->clear();
  }
  clear_has_globtitle();
}
inline const ::std::string& pbSccpAddress::globtitle() const {
  return *globtitle_;
}
inline void pbSccpAddress::set_globtitle(const ::std::string& value) {
  set_has_globtitle();
  if (globtitle_ == &::google::protobuf::internal::kEmptyString) {
    globtitle_ = new ::std::string;
  }
  globtitle_->assign(value);
}
inline void pbSccpAddress::set_globtitle(const char* value) {
  set_has_globtitle();
  if (globtitle_ == &::google::protobuf::internal::kEmptyString) {
    globtitle_ = new ::std::string;
  }
  globtitle_->assign(value);
}
inline void pbSccpAddress::set_globtitle(const void* value, size_t size) {
  set_has_globtitle();
  if (globtitle_ == &::google::protobuf::internal::kEmptyString) {
    globtitle_ = new ::std::string;
  }
  globtitle_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbSccpAddress::mutable_globtitle() {
  set_has_globtitle();
  if (globtitle_ == &::google::protobuf::internal::kEmptyString) {
    globtitle_ = new ::std::string;
  }
  return globtitle_;
}
inline ::std::string* pbSccpAddress::release_globtitle() {
  clear_has_globtitle();
  if (globtitle_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = globtitle_;
    globtitle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 gttType = 11;
inline bool pbSccpAddress::has_gtttype() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void pbSccpAddress::set_has_gtttype() {
  _has_bits_[0] |= 0x00000400u;
}
inline void pbSccpAddress::clear_has_gtttype() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void pbSccpAddress::clear_gtttype() {
  gtttype_ = 0u;
  clear_has_gtttype();
}
inline ::google::protobuf::uint32 pbSccpAddress::gtttype() const {
  return gtttype_;
}
inline void pbSccpAddress::set_gtttype(::google::protobuf::uint32 value) {
  set_has_gtttype();
  gtttype_ = value;
}

// -------------------------------------------------------------------

// QualityOfService

// optional uint32 flags = 1;
inline bool QualityOfService::has_flags() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QualityOfService::set_has_flags() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QualityOfService::clear_has_flags() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QualityOfService::clear_flags() {
  flags_ = 0u;
  clear_has_flags();
}
inline ::google::protobuf::uint32 QualityOfService::flags() const {
  return flags_;
}
inline void QualityOfService::set_flags(::google::protobuf::uint32 value) {
  set_has_flags();
  flags_ = value;
}

// optional uint32 slsKey = 2;
inline bool QualityOfService::has_slskey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QualityOfService::set_has_slskey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QualityOfService::clear_has_slskey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QualityOfService::clear_slskey() {
  slskey_ = 0u;
  clear_has_slskey();
}
inline ::google::protobuf::uint32 QualityOfService::slskey() const {
  return slskey_;
}
inline void QualityOfService::set_slskey(::google::protobuf::uint32 value) {
  set_has_slskey();
  slskey_ = value;
}

// optional uint32 priority = 3;
inline bool QualityOfService::has_priority() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void QualityOfService::set_has_priority() {
  _has_bits_[0] |= 0x00000004u;
}
inline void QualityOfService::clear_has_priority() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void QualityOfService::clear_priority() {
  priority_ = 0u;
  clear_has_priority();
}
inline ::google::protobuf::uint32 QualityOfService::priority() const {
  return priority_;
}
inline void QualityOfService::set_priority(::google::protobuf::uint32 value) {
  set_has_priority();
  priority_ = value;
}

// optional uint32 networkInd = 4;
inline bool QualityOfService::has_networkind() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void QualityOfService::set_has_networkind() {
  _has_bits_[0] |= 0x00000008u;
}
inline void QualityOfService::clear_has_networkind() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void QualityOfService::clear_networkind() {
  networkind_ = 0u;
  clear_has_networkind();
}
inline ::google::protobuf::uint32 QualityOfService::networkind() const {
  return networkind_;
}
inline void QualityOfService::set_networkind(::google::protobuf::uint32 value) {
  set_has_networkind();
  networkind_ = value;
}

// -------------------------------------------------------------------

// pbTcapDialogue

// optional uint32 DialogueId = 1;
inline bool pbTcapDialogue::has_dialogueid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pbTcapDialogue::set_has_dialogueid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pbTcapDialogue::clear_has_dialogueid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pbTcapDialogue::clear_dialogueid() {
  dialogueid_ = 0u;
  clear_has_dialogueid();
}
inline ::google::protobuf::uint32 pbTcapDialogue::dialogueid() const {
  return dialogueid_;
}
inline void pbTcapDialogue::set_dialogueid(::google::protobuf::uint32 value) {
  set_has_dialogueid();
  dialogueid_ = value;
}

// optional uint32 DialogueType = 2;
inline bool pbTcapDialogue::has_dialoguetype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pbTcapDialogue::set_has_dialoguetype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pbTcapDialogue::clear_has_dialoguetype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pbTcapDialogue::clear_dialoguetype() {
  dialoguetype_ = 0u;
  clear_has_dialoguetype();
}
inline ::google::protobuf::uint32 pbTcapDialogue::dialoguetype() const {
  return dialoguetype_;
}
inline void pbTcapDialogue::set_dialoguetype(::google::protobuf::uint32 value) {
  set_has_dialoguetype();
  dialoguetype_ = value;
}

// optional string AbortReason = 3;
inline bool pbTcapDialogue::has_abortreason() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void pbTcapDialogue::set_has_abortreason() {
  _has_bits_[0] |= 0x00000004u;
}
inline void pbTcapDialogue::clear_has_abortreason() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void pbTcapDialogue::clear_abortreason() {
  if (abortreason_ != &::google::protobuf::internal::kEmptyString) {
    abortreason_->clear();
  }
  clear_has_abortreason();
}
inline const ::std::string& pbTcapDialogue::abortreason() const {
  return *abortreason_;
}
inline void pbTcapDialogue::set_abortreason(const ::std::string& value) {
  set_has_abortreason();
  if (abortreason_ == &::google::protobuf::internal::kEmptyString) {
    abortreason_ = new ::std::string;
  }
  abortreason_->assign(value);
}
inline void pbTcapDialogue::set_abortreason(const char* value) {
  set_has_abortreason();
  if (abortreason_ == &::google::protobuf::internal::kEmptyString) {
    abortreason_ = new ::std::string;
  }
  abortreason_->assign(value);
}
inline void pbTcapDialogue::set_abortreason(const char* value, size_t size) {
  set_has_abortreason();
  if (abortreason_ == &::google::protobuf::internal::kEmptyString) {
    abortreason_ = new ::std::string;
  }
  abortreason_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbTcapDialogue::mutable_abortreason() {
  set_has_abortreason();
  if (abortreason_ == &::google::protobuf::internal::kEmptyString) {
    abortreason_ = new ::std::string;
  }
  return abortreason_;
}
inline ::std::string* pbTcapDialogue::release_abortreason() {
  clear_has_abortreason();
  if (abortreason_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = abortreason_;
    abortreason_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes ApplicationContext = 4;
inline bool pbTcapDialogue::has_applicationcontext() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void pbTcapDialogue::set_has_applicationcontext() {
  _has_bits_[0] |= 0x00000008u;
}
inline void pbTcapDialogue::clear_has_applicationcontext() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void pbTcapDialogue::clear_applicationcontext() {
  if (applicationcontext_ != &::google::protobuf::internal::kEmptyString) {
    applicationcontext_->clear();
  }
  clear_has_applicationcontext();
}
inline const ::std::string& pbTcapDialogue::applicationcontext() const {
  return *applicationcontext_;
}
inline void pbTcapDialogue::set_applicationcontext(const ::std::string& value) {
  set_has_applicationcontext();
  if (applicationcontext_ == &::google::protobuf::internal::kEmptyString) {
    applicationcontext_ = new ::std::string;
  }
  applicationcontext_->assign(value);
}
inline void pbTcapDialogue::set_applicationcontext(const char* value) {
  set_has_applicationcontext();
  if (applicationcontext_ == &::google::protobuf::internal::kEmptyString) {
    applicationcontext_ = new ::std::string;
  }
  applicationcontext_->assign(value);
}
inline void pbTcapDialogue::set_applicationcontext(const void* value, size_t size) {
  set_has_applicationcontext();
  if (applicationcontext_ == &::google::protobuf::internal::kEmptyString) {
    applicationcontext_ = new ::std::string;
  }
  applicationcontext_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbTcapDialogue::mutable_applicationcontext() {
  set_has_applicationcontext();
  if (applicationcontext_ == &::google::protobuf::internal::kEmptyString) {
    applicationcontext_ = new ::std::string;
  }
  return applicationcontext_;
}
inline ::std::string* pbTcapDialogue::release_applicationcontext() {
  clear_has_applicationcontext();
  if (applicationcontext_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = applicationcontext_;
    applicationcontext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .QualityOfService Qos = 5;
inline bool pbTcapDialogue::has_qos() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void pbTcapDialogue::set_has_qos() {
  _has_bits_[0] |= 0x00000010u;
}
inline void pbTcapDialogue::clear_has_qos() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void pbTcapDialogue::clear_qos() {
  if (qos_ != NULL) qos_->::QualityOfService::Clear();
  clear_has_qos();
}
inline const ::QualityOfService& pbTcapDialogue::qos() const {
  return qos_ != NULL ? *qos_ : *default_instance_->qos_;
}
inline ::QualityOfService* pbTcapDialogue::mutable_qos() {
  set_has_qos();
  if (qos_ == NULL) qos_ = new ::QualityOfService;
  return qos_;
}
inline ::QualityOfService* pbTcapDialogue::release_qos() {
  clear_has_qos();
  ::QualityOfService* temp = qos_;
  qos_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// pbSCCPParameters

// optional .pbSccpAddress SccpCallingPartyAddr = 1;
inline bool pbSCCPParameters::has_sccpcallingpartyaddr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pbSCCPParameters::set_has_sccpcallingpartyaddr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pbSCCPParameters::clear_has_sccpcallingpartyaddr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pbSCCPParameters::clear_sccpcallingpartyaddr() {
  if (sccpcallingpartyaddr_ != NULL) sccpcallingpartyaddr_->::pbSccpAddress::Clear();
  clear_has_sccpcallingpartyaddr();
}
inline const ::pbSccpAddress& pbSCCPParameters::sccpcallingpartyaddr() const {
  return sccpcallingpartyaddr_ != NULL ? *sccpcallingpartyaddr_ : *default_instance_->sccpcallingpartyaddr_;
}
inline ::pbSccpAddress* pbSCCPParameters::mutable_sccpcallingpartyaddr() {
  set_has_sccpcallingpartyaddr();
  if (sccpcallingpartyaddr_ == NULL) sccpcallingpartyaddr_ = new ::pbSccpAddress;
  return sccpcallingpartyaddr_;
}
inline ::pbSccpAddress* pbSCCPParameters::release_sccpcallingpartyaddr() {
  clear_has_sccpcallingpartyaddr();
  ::pbSccpAddress* temp = sccpcallingpartyaddr_;
  sccpcallingpartyaddr_ = NULL;
  return temp;
}

// optional .pbSccpAddress SccpCalledPartyAddr = 2;
inline bool pbSCCPParameters::has_sccpcalledpartyaddr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pbSCCPParameters::set_has_sccpcalledpartyaddr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pbSCCPParameters::clear_has_sccpcalledpartyaddr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pbSCCPParameters::clear_sccpcalledpartyaddr() {
  if (sccpcalledpartyaddr_ != NULL) sccpcalledpartyaddr_->::pbSccpAddress::Clear();
  clear_has_sccpcalledpartyaddr();
}
inline const ::pbSccpAddress& pbSCCPParameters::sccpcalledpartyaddr() const {
  return sccpcalledpartyaddr_ != NULL ? *sccpcalledpartyaddr_ : *default_instance_->sccpcalledpartyaddr_;
}
inline ::pbSccpAddress* pbSCCPParameters::mutable_sccpcalledpartyaddr() {
  set_has_sccpcalledpartyaddr();
  if (sccpcalledpartyaddr_ == NULL) sccpcalledpartyaddr_ = new ::pbSccpAddress;
  return sccpcalledpartyaddr_;
}
inline ::pbSccpAddress* pbSCCPParameters::release_sccpcalledpartyaddr() {
  clear_has_sccpcalledpartyaddr();
  ::pbSccpAddress* temp = sccpcalledpartyaddr_;
  sccpcalledpartyaddr_ = NULL;
  return temp;
}

// optional uint32 Opc = 3;
inline bool pbSCCPParameters::has_opc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void pbSCCPParameters::set_has_opc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void pbSCCPParameters::clear_has_opc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void pbSCCPParameters::clear_opc() {
  opc_ = 0u;
  clear_has_opc();
}
inline ::google::protobuf::uint32 pbSCCPParameters::opc() const {
  return opc_;
}
inline void pbSCCPParameters::set_opc(::google::protobuf::uint32 value) {
  set_has_opc();
  opc_ = value;
}

// optional uint32 Dpc = 4;
inline bool pbSCCPParameters::has_dpc() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void pbSCCPParameters::set_has_dpc() {
  _has_bits_[0] |= 0x00000008u;
}
inline void pbSCCPParameters::clear_has_dpc() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void pbSCCPParameters::clear_dpc() {
  dpc_ = 0u;
  clear_has_dpc();
}
inline ::google::protobuf::uint32 pbSCCPParameters::dpc() const {
  return dpc_;
}
inline void pbSCCPParameters::set_dpc(::google::protobuf::uint32 value) {
  set_has_dpc();
  dpc_ = value;
}

// optional bool isRouteByGt = 5;
inline bool pbSCCPParameters::has_isroutebygt() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void pbSCCPParameters::set_has_isroutebygt() {
  _has_bits_[0] |= 0x00000010u;
}
inline void pbSCCPParameters::clear_has_isroutebygt() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void pbSCCPParameters::clear_isroutebygt() {
  isroutebygt_ = false;
  clear_has_isroutebygt();
}
inline bool pbSCCPParameters::isroutebygt() const {
  return isroutebygt_;
}
inline void pbSCCPParameters::set_isroutebygt(bool value) {
  set_has_isroutebygt();
  isroutebygt_ = value;
}

// -------------------------------------------------------------------

// pbTcapComponent

// optional uint32 lastComponent = 1;
inline bool pbTcapComponent::has_lastcomponent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pbTcapComponent::set_has_lastcomponent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pbTcapComponent::clear_has_lastcomponent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pbTcapComponent::clear_lastcomponent() {
  lastcomponent_ = 0u;
  clear_has_lastcomponent();
}
inline ::google::protobuf::uint32 pbTcapComponent::lastcomponent() const {
  return lastcomponent_;
}
inline void pbTcapComponent::set_lastcomponent(::google::protobuf::uint32 value) {
  set_has_lastcomponent();
  lastcomponent_ = value;
}

// optional uint32 invokeId = 2;
inline bool pbTcapComponent::has_invokeid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pbTcapComponent::set_has_invokeid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pbTcapComponent::clear_has_invokeid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pbTcapComponent::clear_invokeid() {
  invokeid_ = 0u;
  clear_has_invokeid();
}
inline ::google::protobuf::uint32 pbTcapComponent::invokeid() const {
  return invokeid_;
}
inline void pbTcapComponent::set_invokeid(::google::protobuf::uint32 value) {
  set_has_invokeid();
  invokeid_ = value;
}

// optional uint32 componentType = 3;
inline bool pbTcapComponent::has_componenttype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void pbTcapComponent::set_has_componenttype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void pbTcapComponent::clear_has_componenttype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void pbTcapComponent::clear_componenttype() {
  componenttype_ = 0u;
  clear_has_componenttype();
}
inline ::google::protobuf::uint32 pbTcapComponent::componenttype() const {
  return componenttype_;
}
inline void pbTcapComponent::set_componenttype(::google::protobuf::uint32 value) {
  set_has_componenttype();
  componenttype_ = value;
}

// optional fixed32 opCode = 4;
inline bool pbTcapComponent::has_opcode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void pbTcapComponent::set_has_opcode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void pbTcapComponent::clear_has_opcode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void pbTcapComponent::clear_opcode() {
  opcode_ = 0u;
  clear_has_opcode();
}
inline ::google::protobuf::uint32 pbTcapComponent::opcode() const {
  return opcode_;
}
inline void pbTcapComponent::set_opcode(::google::protobuf::uint32 value) {
  set_has_opcode();
  opcode_ = value;
}

// -------------------------------------------------------------------

// pbTcapBeginDialogue

// optional uint32 oPc = 1;
inline bool pbTcapBeginDialogue::has_opc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pbTcapBeginDialogue::set_has_opc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pbTcapBeginDialogue::clear_has_opc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pbTcapBeginDialogue::clear_opc() {
  opc_ = 0u;
  clear_has_opc();
}
inline ::google::protobuf::uint32 pbTcapBeginDialogue::opc() const {
  return opc_;
}
inline void pbTcapBeginDialogue::set_opc(::google::protobuf::uint32 value) {
  set_has_opc();
  opc_ = value;
}

// optional .pbSccpAddress SccpCallingPartyAddr = 2;
inline bool pbTcapBeginDialogue::has_sccpcallingpartyaddr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pbTcapBeginDialogue::set_has_sccpcallingpartyaddr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pbTcapBeginDialogue::clear_has_sccpcallingpartyaddr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pbTcapBeginDialogue::clear_sccpcallingpartyaddr() {
  if (sccpcallingpartyaddr_ != NULL) sccpcallingpartyaddr_->::pbSccpAddress::Clear();
  clear_has_sccpcallingpartyaddr();
}
inline const ::pbSccpAddress& pbTcapBeginDialogue::sccpcallingpartyaddr() const {
  return sccpcallingpartyaddr_ != NULL ? *sccpcallingpartyaddr_ : *default_instance_->sccpcallingpartyaddr_;
}
inline ::pbSccpAddress* pbTcapBeginDialogue::mutable_sccpcallingpartyaddr() {
  set_has_sccpcallingpartyaddr();
  if (sccpcallingpartyaddr_ == NULL) sccpcallingpartyaddr_ = new ::pbSccpAddress;
  return sccpcallingpartyaddr_;
}
inline ::pbSccpAddress* pbTcapBeginDialogue::release_sccpcallingpartyaddr() {
  clear_has_sccpcallingpartyaddr();
  ::pbSccpAddress* temp = sccpcallingpartyaddr_;
  sccpcallingpartyaddr_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// SubscriptionIdConfig

// optional uint32 subIdType = 1;
inline bool SubscriptionIdConfig::has_subidtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubscriptionIdConfig::set_has_subidtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SubscriptionIdConfig::clear_has_subidtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SubscriptionIdConfig::clear_subidtype() {
  subidtype_ = 0u;
  clear_has_subidtype();
}
inline ::google::protobuf::uint32 SubscriptionIdConfig::subidtype() const {
  return subidtype_;
}
inline void SubscriptionIdConfig::set_subidtype(::google::protobuf::uint32 value) {
  set_has_subidtype();
  subidtype_ = value;
}

// optional string subIdData = 2 [default = ""];
inline bool SubscriptionIdConfig::has_subiddata() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SubscriptionIdConfig::set_has_subiddata() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SubscriptionIdConfig::clear_has_subiddata() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SubscriptionIdConfig::clear_subiddata() {
  if (subiddata_ != &::google::protobuf::internal::kEmptyString) {
    subiddata_->clear();
  }
  clear_has_subiddata();
}
inline const ::std::string& SubscriptionIdConfig::subiddata() const {
  return *subiddata_;
}
inline void SubscriptionIdConfig::set_subiddata(const ::std::string& value) {
  set_has_subiddata();
  if (subiddata_ == &::google::protobuf::internal::kEmptyString) {
    subiddata_ = new ::std::string;
  }
  subiddata_->assign(value);
}
inline void SubscriptionIdConfig::set_subiddata(const char* value) {
  set_has_subiddata();
  if (subiddata_ == &::google::protobuf::internal::kEmptyString) {
    subiddata_ = new ::std::string;
  }
  subiddata_->assign(value);
}
inline void SubscriptionIdConfig::set_subiddata(const char* value, size_t size) {
  set_has_subiddata();
  if (subiddata_ == &::google::protobuf::internal::kEmptyString) {
    subiddata_ = new ::std::string;
  }
  subiddata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SubscriptionIdConfig::mutable_subiddata() {
  set_has_subiddata();
  if (subiddata_ == &::google::protobuf::internal::kEmptyString) {
    subiddata_ = new ::std::string;
  }
  return subiddata_;
}
inline ::std::string* SubscriptionIdConfig::release_subiddata() {
  clear_has_subiddata();
  if (subiddata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = subiddata_;
    subiddata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// StoredIDPSMSToCCRIData

// optional uint32 callTypeVal = 1 [default = 0];
inline bool StoredIDPSMSToCCRIData::has_calltypeval() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StoredIDPSMSToCCRIData::set_has_calltypeval() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StoredIDPSMSToCCRIData::clear_has_calltypeval() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StoredIDPSMSToCCRIData::clear_calltypeval() {
  calltypeval_ = 0u;
  clear_has_calltypeval();
}
inline ::google::protobuf::uint32 StoredIDPSMSToCCRIData::calltypeval() const {
  return calltypeval_;
}
inline void StoredIDPSMSToCCRIData::set_calltypeval(::google::protobuf::uint32 value) {
  set_has_calltypeval();
  calltypeval_ = value;
}

// optional uint32 CAP_Service_Key = 2 [default = 0];
inline bool StoredIDPSMSToCCRIData::has_cap_service_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StoredIDPSMSToCCRIData::set_has_cap_service_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StoredIDPSMSToCCRIData::clear_has_cap_service_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StoredIDPSMSToCCRIData::clear_cap_service_key() {
  cap_service_key_ = 0u;
  clear_has_cap_service_key();
}
inline ::google::protobuf::uint32 StoredIDPSMSToCCRIData::cap_service_key() const {
  return cap_service_key_;
}
inline void StoredIDPSMSToCCRIData::set_cap_service_key(::google::protobuf::uint32 value) {
  set_has_cap_service_key();
  cap_service_key_ = value;
}

// optional string CAP_Dialed_Digits = 3 [default = ""];
inline bool StoredIDPSMSToCCRIData::has_cap_dialed_digits() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StoredIDPSMSToCCRIData::set_has_cap_dialed_digits() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StoredIDPSMSToCCRIData::clear_has_cap_dialed_digits() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StoredIDPSMSToCCRIData::clear_cap_dialed_digits() {
  if (cap_dialed_digits_ != &::google::protobuf::internal::kEmptyString) {
    cap_dialed_digits_->clear();
  }
  clear_has_cap_dialed_digits();
}
inline const ::std::string& StoredIDPSMSToCCRIData::cap_dialed_digits() const {
  return *cap_dialed_digits_;
}
inline void StoredIDPSMSToCCRIData::set_cap_dialed_digits(const ::std::string& value) {
  set_has_cap_dialed_digits();
  if (cap_dialed_digits_ == &::google::protobuf::internal::kEmptyString) {
    cap_dialed_digits_ = new ::std::string;
  }
  cap_dialed_digits_->assign(value);
}
inline void StoredIDPSMSToCCRIData::set_cap_dialed_digits(const char* value) {
  set_has_cap_dialed_digits();
  if (cap_dialed_digits_ == &::google::protobuf::internal::kEmptyString) {
    cap_dialed_digits_ = new ::std::string;
  }
  cap_dialed_digits_->assign(value);
}
inline void StoredIDPSMSToCCRIData::set_cap_dialed_digits(const char* value, size_t size) {
  set_has_cap_dialed_digits();
  if (cap_dialed_digits_ == &::google::protobuf::internal::kEmptyString) {
    cap_dialed_digits_ = new ::std::string;
  }
  cap_dialed_digits_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoredIDPSMSToCCRIData::mutable_cap_dialed_digits() {
  set_has_cap_dialed_digits();
  if (cap_dialed_digits_ == &::google::protobuf::internal::kEmptyString) {
    cap_dialed_digits_ = new ::std::string;
  }
  return cap_dialed_digits_;
}
inline ::std::string* StoredIDPSMSToCCRIData::release_cap_dialed_digits() {
  clear_has_cap_dialed_digits();
  if (cap_dialed_digits_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cap_dialed_digits_;
    cap_dialed_digits_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 CAP_Called_TON = 4 [default = 1000];
inline bool StoredIDPSMSToCCRIData::has_cap_called_ton() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StoredIDPSMSToCCRIData::set_has_cap_called_ton() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StoredIDPSMSToCCRIData::clear_has_cap_called_ton() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StoredIDPSMSToCCRIData::clear_cap_called_ton() {
  cap_called_ton_ = 1000u;
  clear_has_cap_called_ton();
}
inline ::google::protobuf::uint32 StoredIDPSMSToCCRIData::cap_called_ton() const {
  return cap_called_ton_;
}
inline void StoredIDPSMSToCCRIData::set_cap_called_ton(::google::protobuf::uint32 value) {
  set_has_cap_called_ton();
  cap_called_ton_ = value;
}

// optional string CAP_CLI = 5 [default = ""];
inline bool StoredIDPSMSToCCRIData::has_cap_cli() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StoredIDPSMSToCCRIData::set_has_cap_cli() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StoredIDPSMSToCCRIData::clear_has_cap_cli() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StoredIDPSMSToCCRIData::clear_cap_cli() {
  if (cap_cli_ != &::google::protobuf::internal::kEmptyString) {
    cap_cli_->clear();
  }
  clear_has_cap_cli();
}
inline const ::std::string& StoredIDPSMSToCCRIData::cap_cli() const {
  return *cap_cli_;
}
inline void StoredIDPSMSToCCRIData::set_cap_cli(const ::std::string& value) {
  set_has_cap_cli();
  if (cap_cli_ == &::google::protobuf::internal::kEmptyString) {
    cap_cli_ = new ::std::string;
  }
  cap_cli_->assign(value);
}
inline void StoredIDPSMSToCCRIData::set_cap_cli(const char* value) {
  set_has_cap_cli();
  if (cap_cli_ == &::google::protobuf::internal::kEmptyString) {
    cap_cli_ = new ::std::string;
  }
  cap_cli_->assign(value);
}
inline void StoredIDPSMSToCCRIData::set_cap_cli(const char* value, size_t size) {
  set_has_cap_cli();
  if (cap_cli_ == &::google::protobuf::internal::kEmptyString) {
    cap_cli_ = new ::std::string;
  }
  cap_cli_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoredIDPSMSToCCRIData::mutable_cap_cli() {
  set_has_cap_cli();
  if (cap_cli_ == &::google::protobuf::internal::kEmptyString) {
    cap_cli_ = new ::std::string;
  }
  return cap_cli_;
}
inline ::std::string* StoredIDPSMSToCCRIData::release_cap_cli() {
  clear_has_cap_cli();
  if (cap_cli_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cap_cli_;
    cap_cli_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CAP_Location_Number = 6 [default = ""];
inline bool StoredIDPSMSToCCRIData::has_cap_location_number() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void StoredIDPSMSToCCRIData::set_has_cap_location_number() {
  _has_bits_[0] |= 0x00000020u;
}
inline void StoredIDPSMSToCCRIData::clear_has_cap_location_number() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void StoredIDPSMSToCCRIData::clear_cap_location_number() {
  if (cap_location_number_ != &::google::protobuf::internal::kEmptyString) {
    cap_location_number_->clear();
  }
  clear_has_cap_location_number();
}
inline const ::std::string& StoredIDPSMSToCCRIData::cap_location_number() const {
  return *cap_location_number_;
}
inline void StoredIDPSMSToCCRIData::set_cap_location_number(const ::std::string& value) {
  set_has_cap_location_number();
  if (cap_location_number_ == &::google::protobuf::internal::kEmptyString) {
    cap_location_number_ = new ::std::string;
  }
  cap_location_number_->assign(value);
}
inline void StoredIDPSMSToCCRIData::set_cap_location_number(const char* value) {
  set_has_cap_location_number();
  if (cap_location_number_ == &::google::protobuf::internal::kEmptyString) {
    cap_location_number_ = new ::std::string;
  }
  cap_location_number_->assign(value);
}
inline void StoredIDPSMSToCCRIData::set_cap_location_number(const char* value, size_t size) {
  set_has_cap_location_number();
  if (cap_location_number_ == &::google::protobuf::internal::kEmptyString) {
    cap_location_number_ = new ::std::string;
  }
  cap_location_number_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoredIDPSMSToCCRIData::mutable_cap_location_number() {
  set_has_cap_location_number();
  if (cap_location_number_ == &::google::protobuf::internal::kEmptyString) {
    cap_location_number_ = new ::std::string;
  }
  return cap_location_number_;
}
inline ::std::string* StoredIDPSMSToCCRIData::release_cap_location_number() {
  clear_has_cap_location_number();
  if (cap_location_number_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cap_location_number_;
    cap_location_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CAP_IMSI = 7 [default = ""];
inline bool StoredIDPSMSToCCRIData::has_cap_imsi() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void StoredIDPSMSToCCRIData::set_has_cap_imsi() {
  _has_bits_[0] |= 0x00000040u;
}
inline void StoredIDPSMSToCCRIData::clear_has_cap_imsi() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void StoredIDPSMSToCCRIData::clear_cap_imsi() {
  if (cap_imsi_ != &::google::protobuf::internal::kEmptyString) {
    cap_imsi_->clear();
  }
  clear_has_cap_imsi();
}
inline const ::std::string& StoredIDPSMSToCCRIData::cap_imsi() const {
  return *cap_imsi_;
}
inline void StoredIDPSMSToCCRIData::set_cap_imsi(const ::std::string& value) {
  set_has_cap_imsi();
  if (cap_imsi_ == &::google::protobuf::internal::kEmptyString) {
    cap_imsi_ = new ::std::string;
  }
  cap_imsi_->assign(value);
}
inline void StoredIDPSMSToCCRIData::set_cap_imsi(const char* value) {
  set_has_cap_imsi();
  if (cap_imsi_ == &::google::protobuf::internal::kEmptyString) {
    cap_imsi_ = new ::std::string;
  }
  cap_imsi_->assign(value);
}
inline void StoredIDPSMSToCCRIData::set_cap_imsi(const char* value, size_t size) {
  set_has_cap_imsi();
  if (cap_imsi_ == &::google::protobuf::internal::kEmptyString) {
    cap_imsi_ = new ::std::string;
  }
  cap_imsi_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoredIDPSMSToCCRIData::mutable_cap_imsi() {
  set_has_cap_imsi();
  if (cap_imsi_ == &::google::protobuf::internal::kEmptyString) {
    cap_imsi_ = new ::std::string;
  }
  return cap_imsi_;
}
inline ::std::string* StoredIDPSMSToCCRIData::release_cap_imsi() {
  clear_has_cap_imsi();
  if (cap_imsi_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cap_imsi_;
    cap_imsi_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CAP_VLR_Number = 8 [default = ""];
inline bool StoredIDPSMSToCCRIData::has_cap_vlr_number() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void StoredIDPSMSToCCRIData::set_has_cap_vlr_number() {
  _has_bits_[0] |= 0x00000080u;
}
inline void StoredIDPSMSToCCRIData::clear_has_cap_vlr_number() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void StoredIDPSMSToCCRIData::clear_cap_vlr_number() {
  if (cap_vlr_number_ != &::google::protobuf::internal::kEmptyString) {
    cap_vlr_number_->clear();
  }
  clear_has_cap_vlr_number();
}
inline const ::std::string& StoredIDPSMSToCCRIData::cap_vlr_number() const {
  return *cap_vlr_number_;
}
inline void StoredIDPSMSToCCRIData::set_cap_vlr_number(const ::std::string& value) {
  set_has_cap_vlr_number();
  if (cap_vlr_number_ == &::google::protobuf::internal::kEmptyString) {
    cap_vlr_number_ = new ::std::string;
  }
  cap_vlr_number_->assign(value);
}
inline void StoredIDPSMSToCCRIData::set_cap_vlr_number(const char* value) {
  set_has_cap_vlr_number();
  if (cap_vlr_number_ == &::google::protobuf::internal::kEmptyString) {
    cap_vlr_number_ = new ::std::string;
  }
  cap_vlr_number_->assign(value);
}
inline void StoredIDPSMSToCCRIData::set_cap_vlr_number(const char* value, size_t size) {
  set_has_cap_vlr_number();
  if (cap_vlr_number_ == &::google::protobuf::internal::kEmptyString) {
    cap_vlr_number_ = new ::std::string;
  }
  cap_vlr_number_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoredIDPSMSToCCRIData::mutable_cap_vlr_number() {
  set_has_cap_vlr_number();
  if (cap_vlr_number_ == &::google::protobuf::internal::kEmptyString) {
    cap_vlr_number_ = new ::std::string;
  }
  return cap_vlr_number_;
}
inline ::std::string* StoredIDPSMSToCCRIData::release_cap_vlr_number() {
  clear_has_cap_vlr_number();
  if (cap_vlr_number_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cap_vlr_number_;
    cap_vlr_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CAP_Call_Reference = 9 [default = ""];
inline bool StoredIDPSMSToCCRIData::has_cap_call_reference() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void StoredIDPSMSToCCRIData::set_has_cap_call_reference() {
  _has_bits_[0] |= 0x00000100u;
}
inline void StoredIDPSMSToCCRIData::clear_has_cap_call_reference() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void StoredIDPSMSToCCRIData::clear_cap_call_reference() {
  if (cap_call_reference_ != &::google::protobuf::internal::kEmptyString) {
    cap_call_reference_->clear();
  }
  clear_has_cap_call_reference();
}
inline const ::std::string& StoredIDPSMSToCCRIData::cap_call_reference() const {
  return *cap_call_reference_;
}
inline void StoredIDPSMSToCCRIData::set_cap_call_reference(const ::std::string& value) {
  set_has_cap_call_reference();
  if (cap_call_reference_ == &::google::protobuf::internal::kEmptyString) {
    cap_call_reference_ = new ::std::string;
  }
  cap_call_reference_->assign(value);
}
inline void StoredIDPSMSToCCRIData::set_cap_call_reference(const char* value) {
  set_has_cap_call_reference();
  if (cap_call_reference_ == &::google::protobuf::internal::kEmptyString) {
    cap_call_reference_ = new ::std::string;
  }
  cap_call_reference_->assign(value);
}
inline void StoredIDPSMSToCCRIData::set_cap_call_reference(const char* value, size_t size) {
  set_has_cap_call_reference();
  if (cap_call_reference_ == &::google::protobuf::internal::kEmptyString) {
    cap_call_reference_ = new ::std::string;
  }
  cap_call_reference_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoredIDPSMSToCCRIData::mutable_cap_call_reference() {
  set_has_cap_call_reference();
  if (cap_call_reference_ == &::google::protobuf::internal::kEmptyString) {
    cap_call_reference_ = new ::std::string;
  }
  return cap_call_reference_;
}
inline ::std::string* StoredIDPSMSToCCRIData::release_cap_call_reference() {
  clear_has_cap_call_reference();
  if (cap_call_reference_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cap_call_reference_;
    cap_call_reference_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CAP_MSC_Address = 10 [default = ""];
inline bool StoredIDPSMSToCCRIData::has_cap_msc_address() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void StoredIDPSMSToCCRIData::set_has_cap_msc_address() {
  _has_bits_[0] |= 0x00000200u;
}
inline void StoredIDPSMSToCCRIData::clear_has_cap_msc_address() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void StoredIDPSMSToCCRIData::clear_cap_msc_address() {
  if (cap_msc_address_ != &::google::protobuf::internal::kEmptyString) {
    cap_msc_address_->clear();
  }
  clear_has_cap_msc_address();
}
inline const ::std::string& StoredIDPSMSToCCRIData::cap_msc_address() const {
  return *cap_msc_address_;
}
inline void StoredIDPSMSToCCRIData::set_cap_msc_address(const ::std::string& value) {
  set_has_cap_msc_address();
  if (cap_msc_address_ == &::google::protobuf::internal::kEmptyString) {
    cap_msc_address_ = new ::std::string;
  }
  cap_msc_address_->assign(value);
}
inline void StoredIDPSMSToCCRIData::set_cap_msc_address(const char* value) {
  set_has_cap_msc_address();
  if (cap_msc_address_ == &::google::protobuf::internal::kEmptyString) {
    cap_msc_address_ = new ::std::string;
  }
  cap_msc_address_->assign(value);
}
inline void StoredIDPSMSToCCRIData::set_cap_msc_address(const char* value, size_t size) {
  set_has_cap_msc_address();
  if (cap_msc_address_ == &::google::protobuf::internal::kEmptyString) {
    cap_msc_address_ = new ::std::string;
  }
  cap_msc_address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoredIDPSMSToCCRIData::mutable_cap_msc_address() {
  set_has_cap_msc_address();
  if (cap_msc_address_ == &::google::protobuf::internal::kEmptyString) {
    cap_msc_address_ = new ::std::string;
  }
  return cap_msc_address_;
}
inline ::std::string* StoredIDPSMSToCCRIData::release_cap_msc_address() {
  clear_has_cap_msc_address();
  if (cap_msc_address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cap_msc_address_;
    cap_msc_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 CAP_Called_NPI = 11 [default = 1000];
inline bool StoredIDPSMSToCCRIData::has_cap_called_npi() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void StoredIDPSMSToCCRIData::set_has_cap_called_npi() {
  _has_bits_[0] |= 0x00000400u;
}
inline void StoredIDPSMSToCCRIData::clear_has_cap_called_npi() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void StoredIDPSMSToCCRIData::clear_cap_called_npi() {
  cap_called_npi_ = 1000u;
  clear_has_cap_called_npi();
}
inline ::google::protobuf::uint32 StoredIDPSMSToCCRIData::cap_called_npi() const {
  return cap_called_npi_;
}
inline void StoredIDPSMSToCCRIData::set_cap_called_npi(::google::protobuf::uint32 value) {
  set_has_cap_called_npi();
  cap_called_npi_ = value;
}

// optional uint32 CAP_Calling_NOA = 12 [default = 1000];
inline bool StoredIDPSMSToCCRIData::has_cap_calling_noa() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void StoredIDPSMSToCCRIData::set_has_cap_calling_noa() {
  _has_bits_[0] |= 0x00000800u;
}
inline void StoredIDPSMSToCCRIData::clear_has_cap_calling_noa() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void StoredIDPSMSToCCRIData::clear_cap_calling_noa() {
  cap_calling_noa_ = 1000u;
  clear_has_cap_calling_noa();
}
inline ::google::protobuf::uint32 StoredIDPSMSToCCRIData::cap_calling_noa() const {
  return cap_calling_noa_;
}
inline void StoredIDPSMSToCCRIData::set_cap_calling_noa(::google::protobuf::uint32 value) {
  set_has_cap_calling_noa();
  cap_calling_noa_ = value;
}

// optional uint32 CAP_CLI_NPI = 13 [default = 1000];
inline bool StoredIDPSMSToCCRIData::has_cap_cli_npi() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void StoredIDPSMSToCCRIData::set_has_cap_cli_npi() {
  _has_bits_[0] |= 0x00001000u;
}
inline void StoredIDPSMSToCCRIData::clear_has_cap_cli_npi() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void StoredIDPSMSToCCRIData::clear_cap_cli_npi() {
  cap_cli_npi_ = 1000u;
  clear_has_cap_cli_npi();
}
inline ::google::protobuf::uint32 StoredIDPSMSToCCRIData::cap_cli_npi() const {
  return cap_cli_npi_;
}
inline void StoredIDPSMSToCCRIData::set_cap_cli_npi(::google::protobuf::uint32 value) {
  set_has_cap_cli_npi();
  cap_cli_npi_ = value;
}

// optional uint32 CAP_Version = 14 [default = 1000];
inline bool StoredIDPSMSToCCRIData::has_cap_version() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void StoredIDPSMSToCCRIData::set_has_cap_version() {
  _has_bits_[0] |= 0x00002000u;
}
inline void StoredIDPSMSToCCRIData::clear_has_cap_version() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void StoredIDPSMSToCCRIData::clear_cap_version() {
  cap_version_ = 1000u;
  clear_has_cap_version();
}
inline ::google::protobuf::uint32 StoredIDPSMSToCCRIData::cap_version() const {
  return cap_version_;
}
inline void StoredIDPSMSToCCRIData::set_cap_version(::google::protobuf::uint32 value) {
  set_has_cap_version();
  cap_version_ = value;
}

// optional string CAP_SMSC_Address = 15 [default = ""];
inline bool StoredIDPSMSToCCRIData::has_cap_smsc_address() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void StoredIDPSMSToCCRIData::set_has_cap_smsc_address() {
  _has_bits_[0] |= 0x00004000u;
}
inline void StoredIDPSMSToCCRIData::clear_has_cap_smsc_address() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void StoredIDPSMSToCCRIData::clear_cap_smsc_address() {
  if (cap_smsc_address_ != &::google::protobuf::internal::kEmptyString) {
    cap_smsc_address_->clear();
  }
  clear_has_cap_smsc_address();
}
inline const ::std::string& StoredIDPSMSToCCRIData::cap_smsc_address() const {
  return *cap_smsc_address_;
}
inline void StoredIDPSMSToCCRIData::set_cap_smsc_address(const ::std::string& value) {
  set_has_cap_smsc_address();
  if (cap_smsc_address_ == &::google::protobuf::internal::kEmptyString) {
    cap_smsc_address_ = new ::std::string;
  }
  cap_smsc_address_->assign(value);
}
inline void StoredIDPSMSToCCRIData::set_cap_smsc_address(const char* value) {
  set_has_cap_smsc_address();
  if (cap_smsc_address_ == &::google::protobuf::internal::kEmptyString) {
    cap_smsc_address_ = new ::std::string;
  }
  cap_smsc_address_->assign(value);
}
inline void StoredIDPSMSToCCRIData::set_cap_smsc_address(const char* value, size_t size) {
  set_has_cap_smsc_address();
  if (cap_smsc_address_ == &::google::protobuf::internal::kEmptyString) {
    cap_smsc_address_ = new ::std::string;
  }
  cap_smsc_address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoredIDPSMSToCCRIData::mutable_cap_smsc_address() {
  set_has_cap_smsc_address();
  if (cap_smsc_address_ == &::google::protobuf::internal::kEmptyString) {
    cap_smsc_address_ = new ::std::string;
  }
  return cap_smsc_address_;
}
inline ::std::string* StoredIDPSMSToCCRIData::release_cap_smsc_address() {
  clear_has_cap_smsc_address();
  if (cap_smsc_address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cap_smsc_address_;
    cap_smsc_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CAP_SGSN_Address = 16 [default = ""];
inline bool StoredIDPSMSToCCRIData::has_cap_sgsn_address() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void StoredIDPSMSToCCRIData::set_has_cap_sgsn_address() {
  _has_bits_[0] |= 0x00008000u;
}
inline void StoredIDPSMSToCCRIData::clear_has_cap_sgsn_address() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void StoredIDPSMSToCCRIData::clear_cap_sgsn_address() {
  if (cap_sgsn_address_ != &::google::protobuf::internal::kEmptyString) {
    cap_sgsn_address_->clear();
  }
  clear_has_cap_sgsn_address();
}
inline const ::std::string& StoredIDPSMSToCCRIData::cap_sgsn_address() const {
  return *cap_sgsn_address_;
}
inline void StoredIDPSMSToCCRIData::set_cap_sgsn_address(const ::std::string& value) {
  set_has_cap_sgsn_address();
  if (cap_sgsn_address_ == &::google::protobuf::internal::kEmptyString) {
    cap_sgsn_address_ = new ::std::string;
  }
  cap_sgsn_address_->assign(value);
}
inline void StoredIDPSMSToCCRIData::set_cap_sgsn_address(const char* value) {
  set_has_cap_sgsn_address();
  if (cap_sgsn_address_ == &::google::protobuf::internal::kEmptyString) {
    cap_sgsn_address_ = new ::std::string;
  }
  cap_sgsn_address_->assign(value);
}
inline void StoredIDPSMSToCCRIData::set_cap_sgsn_address(const char* value, size_t size) {
  set_has_cap_sgsn_address();
  if (cap_sgsn_address_ == &::google::protobuf::internal::kEmptyString) {
    cap_sgsn_address_ = new ::std::string;
  }
  cap_sgsn_address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoredIDPSMSToCCRIData::mutable_cap_sgsn_address() {
  set_has_cap_sgsn_address();
  if (cap_sgsn_address_ == &::google::protobuf::internal::kEmptyString) {
    cap_sgsn_address_ = new ::std::string;
  }
  return cap_sgsn_address_;
}
inline ::std::string* StoredIDPSMSToCCRIData::release_cap_sgsn_address() {
  clear_has_cap_sgsn_address();
  if (cap_sgsn_address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cap_sgsn_address_;
    cap_sgsn_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CAP_SM_IMEI = 17 [default = ""];
inline bool StoredIDPSMSToCCRIData::has_cap_sm_imei() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void StoredIDPSMSToCCRIData::set_has_cap_sm_imei() {
  _has_bits_[0] |= 0x00010000u;
}
inline void StoredIDPSMSToCCRIData::clear_has_cap_sm_imei() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void StoredIDPSMSToCCRIData::clear_cap_sm_imei() {
  if (cap_sm_imei_ != &::google::protobuf::internal::kEmptyString) {
    cap_sm_imei_->clear();
  }
  clear_has_cap_sm_imei();
}
inline const ::std::string& StoredIDPSMSToCCRIData::cap_sm_imei() const {
  return *cap_sm_imei_;
}
inline void StoredIDPSMSToCCRIData::set_cap_sm_imei(const ::std::string& value) {
  set_has_cap_sm_imei();
  if (cap_sm_imei_ == &::google::protobuf::internal::kEmptyString) {
    cap_sm_imei_ = new ::std::string;
  }
  cap_sm_imei_->assign(value);
}
inline void StoredIDPSMSToCCRIData::set_cap_sm_imei(const char* value) {
  set_has_cap_sm_imei();
  if (cap_sm_imei_ == &::google::protobuf::internal::kEmptyString) {
    cap_sm_imei_ = new ::std::string;
  }
  cap_sm_imei_->assign(value);
}
inline void StoredIDPSMSToCCRIData::set_cap_sm_imei(const char* value, size_t size) {
  set_has_cap_sm_imei();
  if (cap_sm_imei_ == &::google::protobuf::internal::kEmptyString) {
    cap_sm_imei_ = new ::std::string;
  }
  cap_sm_imei_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoredIDPSMSToCCRIData::mutable_cap_sm_imei() {
  set_has_cap_sm_imei();
  if (cap_sm_imei_ == &::google::protobuf::internal::kEmptyString) {
    cap_sm_imei_ = new ::std::string;
  }
  return cap_sm_imei_;
}
inline ::std::string* StoredIDPSMSToCCRIData::release_cap_sm_imei() {
  clear_has_cap_sm_imei();
  if (cap_sm_imei_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cap_sm_imei_;
    cap_sm_imei_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CAP_SM_StatusReportRequest = 18 [default = ""];
inline bool StoredIDPSMSToCCRIData::has_cap_sm_statusreportrequest() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void StoredIDPSMSToCCRIData::set_has_cap_sm_statusreportrequest() {
  _has_bits_[0] |= 0x00020000u;
}
inline void StoredIDPSMSToCCRIData::clear_has_cap_sm_statusreportrequest() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void StoredIDPSMSToCCRIData::clear_cap_sm_statusreportrequest() {
  if (cap_sm_statusreportrequest_ != &::google::protobuf::internal::kEmptyString) {
    cap_sm_statusreportrequest_->clear();
  }
  clear_has_cap_sm_statusreportrequest();
}
inline const ::std::string& StoredIDPSMSToCCRIData::cap_sm_statusreportrequest() const {
  return *cap_sm_statusreportrequest_;
}
inline void StoredIDPSMSToCCRIData::set_cap_sm_statusreportrequest(const ::std::string& value) {
  set_has_cap_sm_statusreportrequest();
  if (cap_sm_statusreportrequest_ == &::google::protobuf::internal::kEmptyString) {
    cap_sm_statusreportrequest_ = new ::std::string;
  }
  cap_sm_statusreportrequest_->assign(value);
}
inline void StoredIDPSMSToCCRIData::set_cap_sm_statusreportrequest(const char* value) {
  set_has_cap_sm_statusreportrequest();
  if (cap_sm_statusreportrequest_ == &::google::protobuf::internal::kEmptyString) {
    cap_sm_statusreportrequest_ = new ::std::string;
  }
  cap_sm_statusreportrequest_->assign(value);
}
inline void StoredIDPSMSToCCRIData::set_cap_sm_statusreportrequest(const char* value, size_t size) {
  set_has_cap_sm_statusreportrequest();
  if (cap_sm_statusreportrequest_ == &::google::protobuf::internal::kEmptyString) {
    cap_sm_statusreportrequest_ = new ::std::string;
  }
  cap_sm_statusreportrequest_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoredIDPSMSToCCRIData::mutable_cap_sm_statusreportrequest() {
  set_has_cap_sm_statusreportrequest();
  if (cap_sm_statusreportrequest_ == &::google::protobuf::internal::kEmptyString) {
    cap_sm_statusreportrequest_ = new ::std::string;
  }
  return cap_sm_statusreportrequest_;
}
inline ::std::string* StoredIDPSMSToCCRIData::release_cap_sm_statusreportrequest() {
  clear_has_cap_sm_statusreportrequest();
  if (cap_sm_statusreportrequest_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cap_sm_statusreportrequest_;
    cap_sm_statusreportrequest_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CAP_SM_UserDataHeaderIndicator = 19 [default = ""];
inline bool StoredIDPSMSToCCRIData::has_cap_sm_userdataheaderindicator() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void StoredIDPSMSToCCRIData::set_has_cap_sm_userdataheaderindicator() {
  _has_bits_[0] |= 0x00040000u;
}
inline void StoredIDPSMSToCCRIData::clear_has_cap_sm_userdataheaderindicator() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void StoredIDPSMSToCCRIData::clear_cap_sm_userdataheaderindicator() {
  if (cap_sm_userdataheaderindicator_ != &::google::protobuf::internal::kEmptyString) {
    cap_sm_userdataheaderindicator_->clear();
  }
  clear_has_cap_sm_userdataheaderindicator();
}
inline const ::std::string& StoredIDPSMSToCCRIData::cap_sm_userdataheaderindicator() const {
  return *cap_sm_userdataheaderindicator_;
}
inline void StoredIDPSMSToCCRIData::set_cap_sm_userdataheaderindicator(const ::std::string& value) {
  set_has_cap_sm_userdataheaderindicator();
  if (cap_sm_userdataheaderindicator_ == &::google::protobuf::internal::kEmptyString) {
    cap_sm_userdataheaderindicator_ = new ::std::string;
  }
  cap_sm_userdataheaderindicator_->assign(value);
}
inline void StoredIDPSMSToCCRIData::set_cap_sm_userdataheaderindicator(const char* value) {
  set_has_cap_sm_userdataheaderindicator();
  if (cap_sm_userdataheaderindicator_ == &::google::protobuf::internal::kEmptyString) {
    cap_sm_userdataheaderindicator_ = new ::std::string;
  }
  cap_sm_userdataheaderindicator_->assign(value);
}
inline void StoredIDPSMSToCCRIData::set_cap_sm_userdataheaderindicator(const char* value, size_t size) {
  set_has_cap_sm_userdataheaderindicator();
  if (cap_sm_userdataheaderindicator_ == &::google::protobuf::internal::kEmptyString) {
    cap_sm_userdataheaderindicator_ = new ::std::string;
  }
  cap_sm_userdataheaderindicator_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoredIDPSMSToCCRIData::mutable_cap_sm_userdataheaderindicator() {
  set_has_cap_sm_userdataheaderindicator();
  if (cap_sm_userdataheaderindicator_ == &::google::protobuf::internal::kEmptyString) {
    cap_sm_userdataheaderindicator_ = new ::std::string;
  }
  return cap_sm_userdataheaderindicator_;
}
inline ::std::string* StoredIDPSMSToCCRIData::release_cap_sm_userdataheaderindicator() {
  clear_has_cap_sm_userdataheaderindicator();
  if (cap_sm_userdataheaderindicator_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cap_sm_userdataheaderindicator_;
    cap_sm_userdataheaderindicator_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CAP_SM_ReplyPath = 20 [default = ""];
inline bool StoredIDPSMSToCCRIData::has_cap_sm_replypath() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void StoredIDPSMSToCCRIData::set_has_cap_sm_replypath() {
  _has_bits_[0] |= 0x00080000u;
}
inline void StoredIDPSMSToCCRIData::clear_has_cap_sm_replypath() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void StoredIDPSMSToCCRIData::clear_cap_sm_replypath() {
  if (cap_sm_replypath_ != &::google::protobuf::internal::kEmptyString) {
    cap_sm_replypath_->clear();
  }
  clear_has_cap_sm_replypath();
}
inline const ::std::string& StoredIDPSMSToCCRIData::cap_sm_replypath() const {
  return *cap_sm_replypath_;
}
inline void StoredIDPSMSToCCRIData::set_cap_sm_replypath(const ::std::string& value) {
  set_has_cap_sm_replypath();
  if (cap_sm_replypath_ == &::google::protobuf::internal::kEmptyString) {
    cap_sm_replypath_ = new ::std::string;
  }
  cap_sm_replypath_->assign(value);
}
inline void StoredIDPSMSToCCRIData::set_cap_sm_replypath(const char* value) {
  set_has_cap_sm_replypath();
  if (cap_sm_replypath_ == &::google::protobuf::internal::kEmptyString) {
    cap_sm_replypath_ = new ::std::string;
  }
  cap_sm_replypath_->assign(value);
}
inline void StoredIDPSMSToCCRIData::set_cap_sm_replypath(const char* value, size_t size) {
  set_has_cap_sm_replypath();
  if (cap_sm_replypath_ == &::google::protobuf::internal::kEmptyString) {
    cap_sm_replypath_ = new ::std::string;
  }
  cap_sm_replypath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoredIDPSMSToCCRIData::mutable_cap_sm_replypath() {
  set_has_cap_sm_replypath();
  if (cap_sm_replypath_ == &::google::protobuf::internal::kEmptyString) {
    cap_sm_replypath_ = new ::std::string;
  }
  return cap_sm_replypath_;
}
inline ::std::string* StoredIDPSMSToCCRIData::release_cap_sm_replypath() {
  clear_has_cap_sm_replypath();
  if (cap_sm_replypath_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cap_sm_replypath_;
    cap_sm_replypath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CAP_SM_VPFormat = 21 [default = ""];
inline bool StoredIDPSMSToCCRIData::has_cap_sm_vpformat() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void StoredIDPSMSToCCRIData::set_has_cap_sm_vpformat() {
  _has_bits_[0] |= 0x00100000u;
}
inline void StoredIDPSMSToCCRIData::clear_has_cap_sm_vpformat() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void StoredIDPSMSToCCRIData::clear_cap_sm_vpformat() {
  if (cap_sm_vpformat_ != &::google::protobuf::internal::kEmptyString) {
    cap_sm_vpformat_->clear();
  }
  clear_has_cap_sm_vpformat();
}
inline const ::std::string& StoredIDPSMSToCCRIData::cap_sm_vpformat() const {
  return *cap_sm_vpformat_;
}
inline void StoredIDPSMSToCCRIData::set_cap_sm_vpformat(const ::std::string& value) {
  set_has_cap_sm_vpformat();
  if (cap_sm_vpformat_ == &::google::protobuf::internal::kEmptyString) {
    cap_sm_vpformat_ = new ::std::string;
  }
  cap_sm_vpformat_->assign(value);
}
inline void StoredIDPSMSToCCRIData::set_cap_sm_vpformat(const char* value) {
  set_has_cap_sm_vpformat();
  if (cap_sm_vpformat_ == &::google::protobuf::internal::kEmptyString) {
    cap_sm_vpformat_ = new ::std::string;
  }
  cap_sm_vpformat_->assign(value);
}
inline void StoredIDPSMSToCCRIData::set_cap_sm_vpformat(const char* value, size_t size) {
  set_has_cap_sm_vpformat();
  if (cap_sm_vpformat_ == &::google::protobuf::internal::kEmptyString) {
    cap_sm_vpformat_ = new ::std::string;
  }
  cap_sm_vpformat_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoredIDPSMSToCCRIData::mutable_cap_sm_vpformat() {
  set_has_cap_sm_vpformat();
  if (cap_sm_vpformat_ == &::google::protobuf::internal::kEmptyString) {
    cap_sm_vpformat_ = new ::std::string;
  }
  return cap_sm_vpformat_;
}
inline ::std::string* StoredIDPSMSToCCRIData::release_cap_sm_vpformat() {
  clear_has_cap_sm_vpformat();
  if (cap_sm_vpformat_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cap_sm_vpformat_;
    cap_sm_vpformat_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CAP_SM_MessageTypeIndicator = 22 [default = ""];
inline bool StoredIDPSMSToCCRIData::has_cap_sm_messagetypeindicator() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void StoredIDPSMSToCCRIData::set_has_cap_sm_messagetypeindicator() {
  _has_bits_[0] |= 0x00200000u;
}
inline void StoredIDPSMSToCCRIData::clear_has_cap_sm_messagetypeindicator() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void StoredIDPSMSToCCRIData::clear_cap_sm_messagetypeindicator() {
  if (cap_sm_messagetypeindicator_ != &::google::protobuf::internal::kEmptyString) {
    cap_sm_messagetypeindicator_->clear();
  }
  clear_has_cap_sm_messagetypeindicator();
}
inline const ::std::string& StoredIDPSMSToCCRIData::cap_sm_messagetypeindicator() const {
  return *cap_sm_messagetypeindicator_;
}
inline void StoredIDPSMSToCCRIData::set_cap_sm_messagetypeindicator(const ::std::string& value) {
  set_has_cap_sm_messagetypeindicator();
  if (cap_sm_messagetypeindicator_ == &::google::protobuf::internal::kEmptyString) {
    cap_sm_messagetypeindicator_ = new ::std::string;
  }
  cap_sm_messagetypeindicator_->assign(value);
}
inline void StoredIDPSMSToCCRIData::set_cap_sm_messagetypeindicator(const char* value) {
  set_has_cap_sm_messagetypeindicator();
  if (cap_sm_messagetypeindicator_ == &::google::protobuf::internal::kEmptyString) {
    cap_sm_messagetypeindicator_ = new ::std::string;
  }
  cap_sm_messagetypeindicator_->assign(value);
}
inline void StoredIDPSMSToCCRIData::set_cap_sm_messagetypeindicator(const char* value, size_t size) {
  set_has_cap_sm_messagetypeindicator();
  if (cap_sm_messagetypeindicator_ == &::google::protobuf::internal::kEmptyString) {
    cap_sm_messagetypeindicator_ = new ::std::string;
  }
  cap_sm_messagetypeindicator_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoredIDPSMSToCCRIData::mutable_cap_sm_messagetypeindicator() {
  set_has_cap_sm_messagetypeindicator();
  if (cap_sm_messagetypeindicator_ == &::google::protobuf::internal::kEmptyString) {
    cap_sm_messagetypeindicator_ = new ::std::string;
  }
  return cap_sm_messagetypeindicator_;
}
inline ::std::string* StoredIDPSMSToCCRIData::release_cap_sm_messagetypeindicator() {
  clear_has_cap_sm_messagetypeindicator();
  if (cap_sm_messagetypeindicator_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cap_sm_messagetypeindicator_;
    cap_sm_messagetypeindicator_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CAP_SM_ProtocolID = 23 [default = ""];
inline bool StoredIDPSMSToCCRIData::has_cap_sm_protocolid() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void StoredIDPSMSToCCRIData::set_has_cap_sm_protocolid() {
  _has_bits_[0] |= 0x00400000u;
}
inline void StoredIDPSMSToCCRIData::clear_has_cap_sm_protocolid() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void StoredIDPSMSToCCRIData::clear_cap_sm_protocolid() {
  if (cap_sm_protocolid_ != &::google::protobuf::internal::kEmptyString) {
    cap_sm_protocolid_->clear();
  }
  clear_has_cap_sm_protocolid();
}
inline const ::std::string& StoredIDPSMSToCCRIData::cap_sm_protocolid() const {
  return *cap_sm_protocolid_;
}
inline void StoredIDPSMSToCCRIData::set_cap_sm_protocolid(const ::std::string& value) {
  set_has_cap_sm_protocolid();
  if (cap_sm_protocolid_ == &::google::protobuf::internal::kEmptyString) {
    cap_sm_protocolid_ = new ::std::string;
  }
  cap_sm_protocolid_->assign(value);
}
inline void StoredIDPSMSToCCRIData::set_cap_sm_protocolid(const char* value) {
  set_has_cap_sm_protocolid();
  if (cap_sm_protocolid_ == &::google::protobuf::internal::kEmptyString) {
    cap_sm_protocolid_ = new ::std::string;
  }
  cap_sm_protocolid_->assign(value);
}
inline void StoredIDPSMSToCCRIData::set_cap_sm_protocolid(const char* value, size_t size) {
  set_has_cap_sm_protocolid();
  if (cap_sm_protocolid_ == &::google::protobuf::internal::kEmptyString) {
    cap_sm_protocolid_ = new ::std::string;
  }
  cap_sm_protocolid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoredIDPSMSToCCRIData::mutable_cap_sm_protocolid() {
  set_has_cap_sm_protocolid();
  if (cap_sm_protocolid_ == &::google::protobuf::internal::kEmptyString) {
    cap_sm_protocolid_ = new ::std::string;
  }
  return cap_sm_protocolid_;
}
inline ::std::string* StoredIDPSMSToCCRIData::release_cap_sm_protocolid() {
  clear_has_cap_sm_protocolid();
  if (cap_sm_protocolid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cap_sm_protocolid_;
    cap_sm_protocolid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CAP_SM_DCS = 24 [default = ""];
inline bool StoredIDPSMSToCCRIData::has_cap_sm_dcs() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void StoredIDPSMSToCCRIData::set_has_cap_sm_dcs() {
  _has_bits_[0] |= 0x00800000u;
}
inline void StoredIDPSMSToCCRIData::clear_has_cap_sm_dcs() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void StoredIDPSMSToCCRIData::clear_cap_sm_dcs() {
  if (cap_sm_dcs_ != &::google::protobuf::internal::kEmptyString) {
    cap_sm_dcs_->clear();
  }
  clear_has_cap_sm_dcs();
}
inline const ::std::string& StoredIDPSMSToCCRIData::cap_sm_dcs() const {
  return *cap_sm_dcs_;
}
inline void StoredIDPSMSToCCRIData::set_cap_sm_dcs(const ::std::string& value) {
  set_has_cap_sm_dcs();
  if (cap_sm_dcs_ == &::google::protobuf::internal::kEmptyString) {
    cap_sm_dcs_ = new ::std::string;
  }
  cap_sm_dcs_->assign(value);
}
inline void StoredIDPSMSToCCRIData::set_cap_sm_dcs(const char* value) {
  set_has_cap_sm_dcs();
  if (cap_sm_dcs_ == &::google::protobuf::internal::kEmptyString) {
    cap_sm_dcs_ = new ::std::string;
  }
  cap_sm_dcs_->assign(value);
}
inline void StoredIDPSMSToCCRIData::set_cap_sm_dcs(const char* value, size_t size) {
  set_has_cap_sm_dcs();
  if (cap_sm_dcs_ == &::google::protobuf::internal::kEmptyString) {
    cap_sm_dcs_ = new ::std::string;
  }
  cap_sm_dcs_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoredIDPSMSToCCRIData::mutable_cap_sm_dcs() {
  set_has_cap_sm_dcs();
  if (cap_sm_dcs_ == &::google::protobuf::internal::kEmptyString) {
    cap_sm_dcs_ = new ::std::string;
  }
  return cap_sm_dcs_;
}
inline ::std::string* StoredIDPSMSToCCRIData::release_cap_sm_dcs() {
  clear_has_cap_sm_dcs();
  if (cap_sm_dcs_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cap_sm_dcs_;
    cap_sm_dcs_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CAP_SM_ValidityPeriod = 25 [default = ""];
inline bool StoredIDPSMSToCCRIData::has_cap_sm_validityperiod() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void StoredIDPSMSToCCRIData::set_has_cap_sm_validityperiod() {
  _has_bits_[0] |= 0x01000000u;
}
inline void StoredIDPSMSToCCRIData::clear_has_cap_sm_validityperiod() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void StoredIDPSMSToCCRIData::clear_cap_sm_validityperiod() {
  if (cap_sm_validityperiod_ != &::google::protobuf::internal::kEmptyString) {
    cap_sm_validityperiod_->clear();
  }
  clear_has_cap_sm_validityperiod();
}
inline const ::std::string& StoredIDPSMSToCCRIData::cap_sm_validityperiod() const {
  return *cap_sm_validityperiod_;
}
inline void StoredIDPSMSToCCRIData::set_cap_sm_validityperiod(const ::std::string& value) {
  set_has_cap_sm_validityperiod();
  if (cap_sm_validityperiod_ == &::google::protobuf::internal::kEmptyString) {
    cap_sm_validityperiod_ = new ::std::string;
  }
  cap_sm_validityperiod_->assign(value);
}
inline void StoredIDPSMSToCCRIData::set_cap_sm_validityperiod(const char* value) {
  set_has_cap_sm_validityperiod();
  if (cap_sm_validityperiod_ == &::google::protobuf::internal::kEmptyString) {
    cap_sm_validityperiod_ = new ::std::string;
  }
  cap_sm_validityperiod_->assign(value);
}
inline void StoredIDPSMSToCCRIData::set_cap_sm_validityperiod(const char* value, size_t size) {
  set_has_cap_sm_validityperiod();
  if (cap_sm_validityperiod_ == &::google::protobuf::internal::kEmptyString) {
    cap_sm_validityperiod_ = new ::std::string;
  }
  cap_sm_validityperiod_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoredIDPSMSToCCRIData::mutable_cap_sm_validityperiod() {
  set_has_cap_sm_validityperiod();
  if (cap_sm_validityperiod_ == &::google::protobuf::internal::kEmptyString) {
    cap_sm_validityperiod_ = new ::std::string;
  }
  return cap_sm_validityperiod_;
}
inline ::std::string* StoredIDPSMSToCCRIData::release_cap_sm_validityperiod() {
  clear_has_cap_sm_validityperiod();
  if (cap_sm_validityperiod_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cap_sm_validityperiod_;
    cap_sm_validityperiod_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CAP_SM_RejectDuplicate = 26 [default = ""];
inline bool StoredIDPSMSToCCRIData::has_cap_sm_rejectduplicate() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void StoredIDPSMSToCCRIData::set_has_cap_sm_rejectduplicate() {
  _has_bits_[0] |= 0x02000000u;
}
inline void StoredIDPSMSToCCRIData::clear_has_cap_sm_rejectduplicate() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void StoredIDPSMSToCCRIData::clear_cap_sm_rejectduplicate() {
  if (cap_sm_rejectduplicate_ != &::google::protobuf::internal::kEmptyString) {
    cap_sm_rejectduplicate_->clear();
  }
  clear_has_cap_sm_rejectduplicate();
}
inline const ::std::string& StoredIDPSMSToCCRIData::cap_sm_rejectduplicate() const {
  return *cap_sm_rejectduplicate_;
}
inline void StoredIDPSMSToCCRIData::set_cap_sm_rejectduplicate(const ::std::string& value) {
  set_has_cap_sm_rejectduplicate();
  if (cap_sm_rejectduplicate_ == &::google::protobuf::internal::kEmptyString) {
    cap_sm_rejectduplicate_ = new ::std::string;
  }
  cap_sm_rejectduplicate_->assign(value);
}
inline void StoredIDPSMSToCCRIData::set_cap_sm_rejectduplicate(const char* value) {
  set_has_cap_sm_rejectduplicate();
  if (cap_sm_rejectduplicate_ == &::google::protobuf::internal::kEmptyString) {
    cap_sm_rejectduplicate_ = new ::std::string;
  }
  cap_sm_rejectduplicate_->assign(value);
}
inline void StoredIDPSMSToCCRIData::set_cap_sm_rejectduplicate(const char* value, size_t size) {
  set_has_cap_sm_rejectduplicate();
  if (cap_sm_rejectduplicate_ == &::google::protobuf::internal::kEmptyString) {
    cap_sm_rejectduplicate_ = new ::std::string;
  }
  cap_sm_rejectduplicate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoredIDPSMSToCCRIData::mutable_cap_sm_rejectduplicate() {
  set_has_cap_sm_rejectduplicate();
  if (cap_sm_rejectduplicate_ == &::google::protobuf::internal::kEmptyString) {
    cap_sm_rejectduplicate_ = new ::std::string;
  }
  return cap_sm_rejectduplicate_;
}
inline ::std::string* StoredIDPSMSToCCRIData::release_cap_sm_rejectduplicate() {
  clear_has_cap_sm_rejectduplicate();
  if (cap_sm_rejectduplicate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cap_sm_rejectduplicate_;
    cap_sm_rejectduplicate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CAP_SCCP_CallingGT = 27 [default = ""];
inline bool StoredIDPSMSToCCRIData::has_cap_sccp_callinggt() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void StoredIDPSMSToCCRIData::set_has_cap_sccp_callinggt() {
  _has_bits_[0] |= 0x04000000u;
}
inline void StoredIDPSMSToCCRIData::clear_has_cap_sccp_callinggt() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void StoredIDPSMSToCCRIData::clear_cap_sccp_callinggt() {
  if (cap_sccp_callinggt_ != &::google::protobuf::internal::kEmptyString) {
    cap_sccp_callinggt_->clear();
  }
  clear_has_cap_sccp_callinggt();
}
inline const ::std::string& StoredIDPSMSToCCRIData::cap_sccp_callinggt() const {
  return *cap_sccp_callinggt_;
}
inline void StoredIDPSMSToCCRIData::set_cap_sccp_callinggt(const ::std::string& value) {
  set_has_cap_sccp_callinggt();
  if (cap_sccp_callinggt_ == &::google::protobuf::internal::kEmptyString) {
    cap_sccp_callinggt_ = new ::std::string;
  }
  cap_sccp_callinggt_->assign(value);
}
inline void StoredIDPSMSToCCRIData::set_cap_sccp_callinggt(const char* value) {
  set_has_cap_sccp_callinggt();
  if (cap_sccp_callinggt_ == &::google::protobuf::internal::kEmptyString) {
    cap_sccp_callinggt_ = new ::std::string;
  }
  cap_sccp_callinggt_->assign(value);
}
inline void StoredIDPSMSToCCRIData::set_cap_sccp_callinggt(const char* value, size_t size) {
  set_has_cap_sccp_callinggt();
  if (cap_sccp_callinggt_ == &::google::protobuf::internal::kEmptyString) {
    cap_sccp_callinggt_ = new ::std::string;
  }
  cap_sccp_callinggt_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoredIDPSMSToCCRIData::mutable_cap_sccp_callinggt() {
  set_has_cap_sccp_callinggt();
  if (cap_sccp_callinggt_ == &::google::protobuf::internal::kEmptyString) {
    cap_sccp_callinggt_ = new ::std::string;
  }
  return cap_sccp_callinggt_;
}
inline ::std::string* StoredIDPSMSToCCRIData::release_cap_sccp_callinggt() {
  clear_has_cap_sccp_callinggt();
  if (cap_sccp_callinggt_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cap_sccp_callinggt_;
    cap_sccp_callinggt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CAP_SCCP_CalledGT = 28 [default = ""];
inline bool StoredIDPSMSToCCRIData::has_cap_sccp_calledgt() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void StoredIDPSMSToCCRIData::set_has_cap_sccp_calledgt() {
  _has_bits_[0] |= 0x08000000u;
}
inline void StoredIDPSMSToCCRIData::clear_has_cap_sccp_calledgt() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void StoredIDPSMSToCCRIData::clear_cap_sccp_calledgt() {
  if (cap_sccp_calledgt_ != &::google::protobuf::internal::kEmptyString) {
    cap_sccp_calledgt_->clear();
  }
  clear_has_cap_sccp_calledgt();
}
inline const ::std::string& StoredIDPSMSToCCRIData::cap_sccp_calledgt() const {
  return *cap_sccp_calledgt_;
}
inline void StoredIDPSMSToCCRIData::set_cap_sccp_calledgt(const ::std::string& value) {
  set_has_cap_sccp_calledgt();
  if (cap_sccp_calledgt_ == &::google::protobuf::internal::kEmptyString) {
    cap_sccp_calledgt_ = new ::std::string;
  }
  cap_sccp_calledgt_->assign(value);
}
inline void StoredIDPSMSToCCRIData::set_cap_sccp_calledgt(const char* value) {
  set_has_cap_sccp_calledgt();
  if (cap_sccp_calledgt_ == &::google::protobuf::internal::kEmptyString) {
    cap_sccp_calledgt_ = new ::std::string;
  }
  cap_sccp_calledgt_->assign(value);
}
inline void StoredIDPSMSToCCRIData::set_cap_sccp_calledgt(const char* value, size_t size) {
  set_has_cap_sccp_calledgt();
  if (cap_sccp_calledgt_ == &::google::protobuf::internal::kEmptyString) {
    cap_sccp_calledgt_ = new ::std::string;
  }
  cap_sccp_calledgt_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoredIDPSMSToCCRIData::mutable_cap_sccp_calledgt() {
  set_has_cap_sccp_calledgt();
  if (cap_sccp_calledgt_ == &::google::protobuf::internal::kEmptyString) {
    cap_sccp_calledgt_ = new ::std::string;
  }
  return cap_sccp_calledgt_;
}
inline ::std::string* StoredIDPSMSToCCRIData::release_cap_sccp_calledgt() {
  clear_has_cap_sccp_calledgt();
  if (cap_sccp_calledgt_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cap_sccp_calledgt_;
    cap_sccp_calledgt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CAP_TCAP_Remote_Transaction_Id = 29 [default = ""];
inline bool StoredIDPSMSToCCRIData::has_cap_tcap_remote_transaction_id() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void StoredIDPSMSToCCRIData::set_has_cap_tcap_remote_transaction_id() {
  _has_bits_[0] |= 0x10000000u;
}
inline void StoredIDPSMSToCCRIData::clear_has_cap_tcap_remote_transaction_id() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void StoredIDPSMSToCCRIData::clear_cap_tcap_remote_transaction_id() {
  if (cap_tcap_remote_transaction_id_ != &::google::protobuf::internal::kEmptyString) {
    cap_tcap_remote_transaction_id_->clear();
  }
  clear_has_cap_tcap_remote_transaction_id();
}
inline const ::std::string& StoredIDPSMSToCCRIData::cap_tcap_remote_transaction_id() const {
  return *cap_tcap_remote_transaction_id_;
}
inline void StoredIDPSMSToCCRIData::set_cap_tcap_remote_transaction_id(const ::std::string& value) {
  set_has_cap_tcap_remote_transaction_id();
  if (cap_tcap_remote_transaction_id_ == &::google::protobuf::internal::kEmptyString) {
    cap_tcap_remote_transaction_id_ = new ::std::string;
  }
  cap_tcap_remote_transaction_id_->assign(value);
}
inline void StoredIDPSMSToCCRIData::set_cap_tcap_remote_transaction_id(const char* value) {
  set_has_cap_tcap_remote_transaction_id();
  if (cap_tcap_remote_transaction_id_ == &::google::protobuf::internal::kEmptyString) {
    cap_tcap_remote_transaction_id_ = new ::std::string;
  }
  cap_tcap_remote_transaction_id_->assign(value);
}
inline void StoredIDPSMSToCCRIData::set_cap_tcap_remote_transaction_id(const char* value, size_t size) {
  set_has_cap_tcap_remote_transaction_id();
  if (cap_tcap_remote_transaction_id_ == &::google::protobuf::internal::kEmptyString) {
    cap_tcap_remote_transaction_id_ = new ::std::string;
  }
  cap_tcap_remote_transaction_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoredIDPSMSToCCRIData::mutable_cap_tcap_remote_transaction_id() {
  set_has_cap_tcap_remote_transaction_id();
  if (cap_tcap_remote_transaction_id_ == &::google::protobuf::internal::kEmptyString) {
    cap_tcap_remote_transaction_id_ = new ::std::string;
  }
  return cap_tcap_remote_transaction_id_;
}
inline ::std::string* StoredIDPSMSToCCRIData::release_cap_tcap_remote_transaction_id() {
  clear_has_cap_tcap_remote_transaction_id();
  if (cap_tcap_remote_transaction_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cap_tcap_remote_transaction_id_;
    cap_tcap_remote_transaction_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CAP_TCAP_Local_Transaction_Id = 30 [default = ""];
inline bool StoredIDPSMSToCCRIData::has_cap_tcap_local_transaction_id() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void StoredIDPSMSToCCRIData::set_has_cap_tcap_local_transaction_id() {
  _has_bits_[0] |= 0x20000000u;
}
inline void StoredIDPSMSToCCRIData::clear_has_cap_tcap_local_transaction_id() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void StoredIDPSMSToCCRIData::clear_cap_tcap_local_transaction_id() {
  if (cap_tcap_local_transaction_id_ != &::google::protobuf::internal::kEmptyString) {
    cap_tcap_local_transaction_id_->clear();
  }
  clear_has_cap_tcap_local_transaction_id();
}
inline const ::std::string& StoredIDPSMSToCCRIData::cap_tcap_local_transaction_id() const {
  return *cap_tcap_local_transaction_id_;
}
inline void StoredIDPSMSToCCRIData::set_cap_tcap_local_transaction_id(const ::std::string& value) {
  set_has_cap_tcap_local_transaction_id();
  if (cap_tcap_local_transaction_id_ == &::google::protobuf::internal::kEmptyString) {
    cap_tcap_local_transaction_id_ = new ::std::string;
  }
  cap_tcap_local_transaction_id_->assign(value);
}
inline void StoredIDPSMSToCCRIData::set_cap_tcap_local_transaction_id(const char* value) {
  set_has_cap_tcap_local_transaction_id();
  if (cap_tcap_local_transaction_id_ == &::google::protobuf::internal::kEmptyString) {
    cap_tcap_local_transaction_id_ = new ::std::string;
  }
  cap_tcap_local_transaction_id_->assign(value);
}
inline void StoredIDPSMSToCCRIData::set_cap_tcap_local_transaction_id(const char* value, size_t size) {
  set_has_cap_tcap_local_transaction_id();
  if (cap_tcap_local_transaction_id_ == &::google::protobuf::internal::kEmptyString) {
    cap_tcap_local_transaction_id_ = new ::std::string;
  }
  cap_tcap_local_transaction_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoredIDPSMSToCCRIData::mutable_cap_tcap_local_transaction_id() {
  set_has_cap_tcap_local_transaction_id();
  if (cap_tcap_local_transaction_id_ == &::google::protobuf::internal::kEmptyString) {
    cap_tcap_local_transaction_id_ = new ::std::string;
  }
  return cap_tcap_local_transaction_id_;
}
inline ::std::string* StoredIDPSMSToCCRIData::release_cap_tcap_local_transaction_id() {
  clear_has_cap_tcap_local_transaction_id();
  if (cap_tcap_local_transaction_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cap_tcap_local_transaction_id_;
    cap_tcap_local_transaction_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CAP_CellID_AreaID_LAI = 31 [default = ""];
inline bool StoredIDPSMSToCCRIData::has_cap_cellid_areaid_lai() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void StoredIDPSMSToCCRIData::set_has_cap_cellid_areaid_lai() {
  _has_bits_[0] |= 0x40000000u;
}
inline void StoredIDPSMSToCCRIData::clear_has_cap_cellid_areaid_lai() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void StoredIDPSMSToCCRIData::clear_cap_cellid_areaid_lai() {
  if (cap_cellid_areaid_lai_ != &::google::protobuf::internal::kEmptyString) {
    cap_cellid_areaid_lai_->clear();
  }
  clear_has_cap_cellid_areaid_lai();
}
inline const ::std::string& StoredIDPSMSToCCRIData::cap_cellid_areaid_lai() const {
  return *cap_cellid_areaid_lai_;
}
inline void StoredIDPSMSToCCRIData::set_cap_cellid_areaid_lai(const ::std::string& value) {
  set_has_cap_cellid_areaid_lai();
  if (cap_cellid_areaid_lai_ == &::google::protobuf::internal::kEmptyString) {
    cap_cellid_areaid_lai_ = new ::std::string;
  }
  cap_cellid_areaid_lai_->assign(value);
}
inline void StoredIDPSMSToCCRIData::set_cap_cellid_areaid_lai(const char* value) {
  set_has_cap_cellid_areaid_lai();
  if (cap_cellid_areaid_lai_ == &::google::protobuf::internal::kEmptyString) {
    cap_cellid_areaid_lai_ = new ::std::string;
  }
  cap_cellid_areaid_lai_->assign(value);
}
inline void StoredIDPSMSToCCRIData::set_cap_cellid_areaid_lai(const char* value, size_t size) {
  set_has_cap_cellid_areaid_lai();
  if (cap_cellid_areaid_lai_ == &::google::protobuf::internal::kEmptyString) {
    cap_cellid_areaid_lai_ = new ::std::string;
  }
  cap_cellid_areaid_lai_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoredIDPSMSToCCRIData::mutable_cap_cellid_areaid_lai() {
  set_has_cap_cellid_areaid_lai();
  if (cap_cellid_areaid_lai_ == &::google::protobuf::internal::kEmptyString) {
    cap_cellid_areaid_lai_ = new ::std::string;
  }
  return cap_cellid_areaid_lai_;
}
inline ::std::string* StoredIDPSMSToCCRIData::release_cap_cellid_areaid_lai() {
  clear_has_cap_cellid_areaid_lai();
  if (cap_cellid_areaid_lai_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cap_cellid_areaid_lai_;
    cap_cellid_areaid_lai_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 CAP_Event_Type_SMS = 32 [default = 1000];
inline bool StoredIDPSMSToCCRIData::has_cap_event_type_sms() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void StoredIDPSMSToCCRIData::set_has_cap_event_type_sms() {
  _has_bits_[0] |= 0x80000000u;
}
inline void StoredIDPSMSToCCRIData::clear_has_cap_event_type_sms() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void StoredIDPSMSToCCRIData::clear_cap_event_type_sms() {
  cap_event_type_sms_ = 1000u;
  clear_has_cap_event_type_sms();
}
inline ::google::protobuf::uint32 StoredIDPSMSToCCRIData::cap_event_type_sms() const {
  return cap_event_type_sms_;
}
inline void StoredIDPSMSToCCRIData::set_cap_event_type_sms(::google::protobuf::uint32 value) {
  set_has_cap_event_type_sms();
  cap_event_type_sms_ = value;
}

// optional uint32 CAP_TCAP_Error_Cause = 33 [default = 500];
inline bool StoredIDPSMSToCCRIData::has_cap_tcap_error_cause() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void StoredIDPSMSToCCRIData::set_has_cap_tcap_error_cause() {
  _has_bits_[1] |= 0x00000001u;
}
inline void StoredIDPSMSToCCRIData::clear_has_cap_tcap_error_cause() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void StoredIDPSMSToCCRIData::clear_cap_tcap_error_cause() {
  cap_tcap_error_cause_ = 500u;
  clear_has_cap_tcap_error_cause();
}
inline ::google::protobuf::uint32 StoredIDPSMSToCCRIData::cap_tcap_error_cause() const {
  return cap_tcap_error_cause_;
}
inline void StoredIDPSMSToCCRIData::set_cap_tcap_error_cause(::google::protobuf::uint32 value) {
  set_has_cap_tcap_error_cause();
  cap_tcap_error_cause_ = value;
}

// optional uint32 CAP_SCCP_Error_Cause = 34 [default = 0];
inline bool StoredIDPSMSToCCRIData::has_cap_sccp_error_cause() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void StoredIDPSMSToCCRIData::set_has_cap_sccp_error_cause() {
  _has_bits_[1] |= 0x00000002u;
}
inline void StoredIDPSMSToCCRIData::clear_has_cap_sccp_error_cause() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void StoredIDPSMSToCCRIData::clear_cap_sccp_error_cause() {
  cap_sccp_error_cause_ = 0u;
  clear_has_cap_sccp_error_cause();
}
inline ::google::protobuf::uint32 StoredIDPSMSToCCRIData::cap_sccp_error_cause() const {
  return cap_sccp_error_cause_;
}
inline void StoredIDPSMSToCCRIData::set_cap_sccp_error_cause(::google::protobuf::uint32 value) {
  set_has_cap_sccp_error_cause();
  cap_sccp_error_cause_ = value;
}

// optional string CAP_SMSpecificInfo = 35 [default = ""];
inline bool StoredIDPSMSToCCRIData::has_cap_smspecificinfo() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void StoredIDPSMSToCCRIData::set_has_cap_smspecificinfo() {
  _has_bits_[1] |= 0x00000004u;
}
inline void StoredIDPSMSToCCRIData::clear_has_cap_smspecificinfo() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void StoredIDPSMSToCCRIData::clear_cap_smspecificinfo() {
  if (cap_smspecificinfo_ != &::google::protobuf::internal::kEmptyString) {
    cap_smspecificinfo_->clear();
  }
  clear_has_cap_smspecificinfo();
}
inline const ::std::string& StoredIDPSMSToCCRIData::cap_smspecificinfo() const {
  return *cap_smspecificinfo_;
}
inline void StoredIDPSMSToCCRIData::set_cap_smspecificinfo(const ::std::string& value) {
  set_has_cap_smspecificinfo();
  if (cap_smspecificinfo_ == &::google::protobuf::internal::kEmptyString) {
    cap_smspecificinfo_ = new ::std::string;
  }
  cap_smspecificinfo_->assign(value);
}
inline void StoredIDPSMSToCCRIData::set_cap_smspecificinfo(const char* value) {
  set_has_cap_smspecificinfo();
  if (cap_smspecificinfo_ == &::google::protobuf::internal::kEmptyString) {
    cap_smspecificinfo_ = new ::std::string;
  }
  cap_smspecificinfo_->assign(value);
}
inline void StoredIDPSMSToCCRIData::set_cap_smspecificinfo(const char* value, size_t size) {
  set_has_cap_smspecificinfo();
  if (cap_smspecificinfo_ == &::google::protobuf::internal::kEmptyString) {
    cap_smspecificinfo_ = new ::std::string;
  }
  cap_smspecificinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoredIDPSMSToCCRIData::mutable_cap_smspecificinfo() {
  set_has_cap_smspecificinfo();
  if (cap_smspecificinfo_ == &::google::protobuf::internal::kEmptyString) {
    cap_smspecificinfo_ = new ::std::string;
  }
  return cap_smspecificinfo_;
}
inline ::std::string* StoredIDPSMSToCCRIData::release_cap_smspecificinfo() {
  clear_has_cap_smspecificinfo();
  if (cap_smspecificinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cap_smspecificinfo_;
    cap_smspecificinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 m_totalGSUCCService = 36 [default = 0];
inline bool StoredIDPSMSToCCRIData::has_m_totalgsuccservice() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void StoredIDPSMSToCCRIData::set_has_m_totalgsuccservice() {
  _has_bits_[1] |= 0x00000008u;
}
inline void StoredIDPSMSToCCRIData::clear_has_m_totalgsuccservice() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void StoredIDPSMSToCCRIData::clear_m_totalgsuccservice() {
  m_totalgsuccservice_ = 0u;
  clear_has_m_totalgsuccservice();
}
inline ::google::protobuf::uint32 StoredIDPSMSToCCRIData::m_totalgsuccservice() const {
  return m_totalgsuccservice_;
}
inline void StoredIDPSMSToCCRIData::set_m_totalgsuccservice(::google::protobuf::uint32 value) {
  set_has_m_totalgsuccservice();
  m_totalgsuccservice_ = value;
}

// optional uint32 m_totalUSUCCService = 37 [default = 0];
inline bool StoredIDPSMSToCCRIData::has_m_totalusuccservice() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void StoredIDPSMSToCCRIData::set_has_m_totalusuccservice() {
  _has_bits_[1] |= 0x00000010u;
}
inline void StoredIDPSMSToCCRIData::clear_has_m_totalusuccservice() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void StoredIDPSMSToCCRIData::clear_m_totalusuccservice() {
  m_totalusuccservice_ = 0u;
  clear_has_m_totalusuccservice();
}
inline ::google::protobuf::uint32 StoredIDPSMSToCCRIData::m_totalusuccservice() const {
  return m_totalusuccservice_;
}
inline void StoredIDPSMSToCCRIData::set_m_totalusuccservice(::google::protobuf::uint32 value) {
  set_has_m_totalusuccservice();
  m_totalusuccservice_ = value;
}

// optional .SubscriptionIdConfig subscriptionIdInfo = 38;
inline bool StoredIDPSMSToCCRIData::has_subscriptionidinfo() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void StoredIDPSMSToCCRIData::set_has_subscriptionidinfo() {
  _has_bits_[1] |= 0x00000020u;
}
inline void StoredIDPSMSToCCRIData::clear_has_subscriptionidinfo() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void StoredIDPSMSToCCRIData::clear_subscriptionidinfo() {
  if (subscriptionidinfo_ != NULL) subscriptionidinfo_->::SubscriptionIdConfig::Clear();
  clear_has_subscriptionidinfo();
}
inline const ::SubscriptionIdConfig& StoredIDPSMSToCCRIData::subscriptionidinfo() const {
  return subscriptionidinfo_ != NULL ? *subscriptionidinfo_ : *default_instance_->subscriptionidinfo_;
}
inline ::SubscriptionIdConfig* StoredIDPSMSToCCRIData::mutable_subscriptionidinfo() {
  set_has_subscriptionidinfo();
  if (subscriptionidinfo_ == NULL) subscriptionidinfo_ = new ::SubscriptionIdConfig;
  return subscriptionidinfo_;
}
inline ::SubscriptionIdConfig* StoredIDPSMSToCCRIData::release_subscriptionidinfo() {
  clear_has_subscriptionidinfo();
  ::SubscriptionIdConfig* temp = subscriptionidinfo_;
  subscriptionidinfo_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// IDPToCCRIData

// optional uint32 callTypeVal = 1 [default = 0];
inline bool IDPToCCRIData::has_calltypeval() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IDPToCCRIData::set_has_calltypeval() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IDPToCCRIData::clear_has_calltypeval() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IDPToCCRIData::clear_calltypeval() {
  calltypeval_ = 0u;
  clear_has_calltypeval();
}
inline ::google::protobuf::uint32 IDPToCCRIData::calltypeval() const {
  return calltypeval_;
}
inline void IDPToCCRIData::set_calltypeval(::google::protobuf::uint32 value) {
  set_has_calltypeval();
  calltypeval_ = value;
}

// optional uint32 Service_Key = 2 [default = 0];
inline bool IDPToCCRIData::has_service_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IDPToCCRIData::set_has_service_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IDPToCCRIData::clear_has_service_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IDPToCCRIData::clear_service_key() {
  service_key_ = 0u;
  clear_has_service_key();
}
inline ::google::protobuf::uint32 IDPToCCRIData::service_key() const {
  return service_key_;
}
inline void IDPToCCRIData::set_service_key(::google::protobuf::uint32 value) {
  set_has_service_key();
  service_key_ = value;
}

// optional bytes Dialed_Digits = 3 [default = ""];
inline bool IDPToCCRIData::has_dialed_digits() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IDPToCCRIData::set_has_dialed_digits() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IDPToCCRIData::clear_has_dialed_digits() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IDPToCCRIData::clear_dialed_digits() {
  if (dialed_digits_ != &::google::protobuf::internal::kEmptyString) {
    dialed_digits_->clear();
  }
  clear_has_dialed_digits();
}
inline const ::std::string& IDPToCCRIData::dialed_digits() const {
  return *dialed_digits_;
}
inline void IDPToCCRIData::set_dialed_digits(const ::std::string& value) {
  set_has_dialed_digits();
  if (dialed_digits_ == &::google::protobuf::internal::kEmptyString) {
    dialed_digits_ = new ::std::string;
  }
  dialed_digits_->assign(value);
}
inline void IDPToCCRIData::set_dialed_digits(const char* value) {
  set_has_dialed_digits();
  if (dialed_digits_ == &::google::protobuf::internal::kEmptyString) {
    dialed_digits_ = new ::std::string;
  }
  dialed_digits_->assign(value);
}
inline void IDPToCCRIData::set_dialed_digits(const void* value, size_t size) {
  set_has_dialed_digits();
  if (dialed_digits_ == &::google::protobuf::internal::kEmptyString) {
    dialed_digits_ = new ::std::string;
  }
  dialed_digits_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IDPToCCRIData::mutable_dialed_digits() {
  set_has_dialed_digits();
  if (dialed_digits_ == &::google::protobuf::internal::kEmptyString) {
    dialed_digits_ = new ::std::string;
  }
  return dialed_digits_;
}
inline ::std::string* IDPToCCRIData::release_dialed_digits() {
  clear_has_dialed_digits();
  if (dialed_digits_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dialed_digits_;
    dialed_digits_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 Called_TON = 4 [default = 1000];
inline bool IDPToCCRIData::has_called_ton() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IDPToCCRIData::set_has_called_ton() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IDPToCCRIData::clear_has_called_ton() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IDPToCCRIData::clear_called_ton() {
  called_ton_ = 1000u;
  clear_has_called_ton();
}
inline ::google::protobuf::uint32 IDPToCCRIData::called_ton() const {
  return called_ton_;
}
inline void IDPToCCRIData::set_called_ton(::google::protobuf::uint32 value) {
  set_has_called_ton();
  called_ton_ = value;
}

// optional bytes CLI = 5 [default = ""];
inline bool IDPToCCRIData::has_cli() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IDPToCCRIData::set_has_cli() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IDPToCCRIData::clear_has_cli() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IDPToCCRIData::clear_cli() {
  if (cli_ != &::google::protobuf::internal::kEmptyString) {
    cli_->clear();
  }
  clear_has_cli();
}
inline const ::std::string& IDPToCCRIData::cli() const {
  return *cli_;
}
inline void IDPToCCRIData::set_cli(const ::std::string& value) {
  set_has_cli();
  if (cli_ == &::google::protobuf::internal::kEmptyString) {
    cli_ = new ::std::string;
  }
  cli_->assign(value);
}
inline void IDPToCCRIData::set_cli(const char* value) {
  set_has_cli();
  if (cli_ == &::google::protobuf::internal::kEmptyString) {
    cli_ = new ::std::string;
  }
  cli_->assign(value);
}
inline void IDPToCCRIData::set_cli(const void* value, size_t size) {
  set_has_cli();
  if (cli_ == &::google::protobuf::internal::kEmptyString) {
    cli_ = new ::std::string;
  }
  cli_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IDPToCCRIData::mutable_cli() {
  set_has_cli();
  if (cli_ == &::google::protobuf::internal::kEmptyString) {
    cli_ = new ::std::string;
  }
  return cli_;
}
inline ::std::string* IDPToCCRIData::release_cli() {
  clear_has_cli();
  if (cli_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cli_;
    cli_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 Calling_Category = 6 [default = 1000];
inline bool IDPToCCRIData::has_calling_category() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IDPToCCRIData::set_has_calling_category() {
  _has_bits_[0] |= 0x00000020u;
}
inline void IDPToCCRIData::clear_has_calling_category() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void IDPToCCRIData::clear_calling_category() {
  calling_category_ = 1000u;
  clear_has_calling_category();
}
inline ::google::protobuf::uint32 IDPToCCRIData::calling_category() const {
  return calling_category_;
}
inline void IDPToCCRIData::set_calling_category(::google::protobuf::uint32 value) {
  set_has_calling_category();
  calling_category_ = value;
}

// optional bytes Location_Number = 7 [default = ""];
inline bool IDPToCCRIData::has_location_number() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void IDPToCCRIData::set_has_location_number() {
  _has_bits_[0] |= 0x00000040u;
}
inline void IDPToCCRIData::clear_has_location_number() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void IDPToCCRIData::clear_location_number() {
  if (location_number_ != &::google::protobuf::internal::kEmptyString) {
    location_number_->clear();
  }
  clear_has_location_number();
}
inline const ::std::string& IDPToCCRIData::location_number() const {
  return *location_number_;
}
inline void IDPToCCRIData::set_location_number(const ::std::string& value) {
  set_has_location_number();
  if (location_number_ == &::google::protobuf::internal::kEmptyString) {
    location_number_ = new ::std::string;
  }
  location_number_->assign(value);
}
inline void IDPToCCRIData::set_location_number(const char* value) {
  set_has_location_number();
  if (location_number_ == &::google::protobuf::internal::kEmptyString) {
    location_number_ = new ::std::string;
  }
  location_number_->assign(value);
}
inline void IDPToCCRIData::set_location_number(const void* value, size_t size) {
  set_has_location_number();
  if (location_number_ == &::google::protobuf::internal::kEmptyString) {
    location_number_ = new ::std::string;
  }
  location_number_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IDPToCCRIData::mutable_location_number() {
  set_has_location_number();
  if (location_number_ == &::google::protobuf::internal::kEmptyString) {
    location_number_ = new ::std::string;
  }
  return location_number_;
}
inline ::std::string* IDPToCCRIData::release_location_number() {
  clear_has_location_number();
  if (location_number_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = location_number_;
    location_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes Redirecting_Number = 8 [default = ""];
inline bool IDPToCCRIData::has_redirecting_number() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void IDPToCCRIData::set_has_redirecting_number() {
  _has_bits_[0] |= 0x00000080u;
}
inline void IDPToCCRIData::clear_has_redirecting_number() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void IDPToCCRIData::clear_redirecting_number() {
  if (redirecting_number_ != &::google::protobuf::internal::kEmptyString) {
    redirecting_number_->clear();
  }
  clear_has_redirecting_number();
}
inline const ::std::string& IDPToCCRIData::redirecting_number() const {
  return *redirecting_number_;
}
inline void IDPToCCRIData::set_redirecting_number(const ::std::string& value) {
  set_has_redirecting_number();
  if (redirecting_number_ == &::google::protobuf::internal::kEmptyString) {
    redirecting_number_ = new ::std::string;
  }
  redirecting_number_->assign(value);
}
inline void IDPToCCRIData::set_redirecting_number(const char* value) {
  set_has_redirecting_number();
  if (redirecting_number_ == &::google::protobuf::internal::kEmptyString) {
    redirecting_number_ = new ::std::string;
  }
  redirecting_number_->assign(value);
}
inline void IDPToCCRIData::set_redirecting_number(const void* value, size_t size) {
  set_has_redirecting_number();
  if (redirecting_number_ == &::google::protobuf::internal::kEmptyString) {
    redirecting_number_ = new ::std::string;
  }
  redirecting_number_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IDPToCCRIData::mutable_redirecting_number() {
  set_has_redirecting_number();
  if (redirecting_number_ == &::google::protobuf::internal::kEmptyString) {
    redirecting_number_ = new ::std::string;
  }
  return redirecting_number_;
}
inline ::std::string* IDPToCCRIData::release_redirecting_number() {
  clear_has_redirecting_number();
  if (redirecting_number_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = redirecting_number_;
    redirecting_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 Redirecting_Indicator = 9 [default = 1000];
inline bool IDPToCCRIData::has_redirecting_indicator() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void IDPToCCRIData::set_has_redirecting_indicator() {
  _has_bits_[0] |= 0x00000100u;
}
inline void IDPToCCRIData::clear_has_redirecting_indicator() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void IDPToCCRIData::clear_redirecting_indicator() {
  redirecting_indicator_ = 1000u;
  clear_has_redirecting_indicator();
}
inline ::google::protobuf::uint32 IDPToCCRIData::redirecting_indicator() const {
  return redirecting_indicator_;
}
inline void IDPToCCRIData::set_redirecting_indicator(::google::protobuf::uint32 value) {
  set_has_redirecting_indicator();
  redirecting_indicator_ = value;
}

// optional uint32 Original_Redirecting_Reason = 10 [default = 1000];
inline bool IDPToCCRIData::has_original_redirecting_reason() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void IDPToCCRIData::set_has_original_redirecting_reason() {
  _has_bits_[0] |= 0x00000200u;
}
inline void IDPToCCRIData::clear_has_original_redirecting_reason() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void IDPToCCRIData::clear_original_redirecting_reason() {
  original_redirecting_reason_ = 1000u;
  clear_has_original_redirecting_reason();
}
inline ::google::protobuf::uint32 IDPToCCRIData::original_redirecting_reason() const {
  return original_redirecting_reason_;
}
inline void IDPToCCRIData::set_original_redirecting_reason(::google::protobuf::uint32 value) {
  set_has_original_redirecting_reason();
  original_redirecting_reason_ = value;
}

// optional uint32 Redirection_Counter = 11 [default = 1000];
inline bool IDPToCCRIData::has_redirection_counter() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void IDPToCCRIData::set_has_redirection_counter() {
  _has_bits_[0] |= 0x00000400u;
}
inline void IDPToCCRIData::clear_has_redirection_counter() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void IDPToCCRIData::clear_redirection_counter() {
  redirection_counter_ = 1000u;
  clear_has_redirection_counter();
}
inline ::google::protobuf::uint32 IDPToCCRIData::redirection_counter() const {
  return redirection_counter_;
}
inline void IDPToCCRIData::set_redirection_counter(::google::protobuf::uint32 value) {
  set_has_redirection_counter();
  redirection_counter_ = value;
}

// optional uint32 Redirecting_Reason = 12 [default = 1000];
inline bool IDPToCCRIData::has_redirecting_reason() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void IDPToCCRIData::set_has_redirecting_reason() {
  _has_bits_[0] |= 0x00000800u;
}
inline void IDPToCCRIData::clear_has_redirecting_reason() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void IDPToCCRIData::clear_redirecting_reason() {
  redirecting_reason_ = 1000u;
  clear_has_redirecting_reason();
}
inline ::google::protobuf::uint32 IDPToCCRIData::redirecting_reason() const {
  return redirecting_reason_;
}
inline void IDPToCCRIData::set_redirecting_reason(::google::protobuf::uint32 value) {
  set_has_redirecting_reason();
  redirecting_reason_ = value;
}

// optional bytes IMSI = 13 [default = ""];
inline bool IDPToCCRIData::has_imsi() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void IDPToCCRIData::set_has_imsi() {
  _has_bits_[0] |= 0x00001000u;
}
inline void IDPToCCRIData::clear_has_imsi() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void IDPToCCRIData::clear_imsi() {
  if (imsi_ != &::google::protobuf::internal::kEmptyString) {
    imsi_->clear();
  }
  clear_has_imsi();
}
inline const ::std::string& IDPToCCRIData::imsi() const {
  return *imsi_;
}
inline void IDPToCCRIData::set_imsi(const ::std::string& value) {
  set_has_imsi();
  if (imsi_ == &::google::protobuf::internal::kEmptyString) {
    imsi_ = new ::std::string;
  }
  imsi_->assign(value);
}
inline void IDPToCCRIData::set_imsi(const char* value) {
  set_has_imsi();
  if (imsi_ == &::google::protobuf::internal::kEmptyString) {
    imsi_ = new ::std::string;
  }
  imsi_->assign(value);
}
inline void IDPToCCRIData::set_imsi(const void* value, size_t size) {
  set_has_imsi();
  if (imsi_ == &::google::protobuf::internal::kEmptyString) {
    imsi_ = new ::std::string;
  }
  imsi_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IDPToCCRIData::mutable_imsi() {
  set_has_imsi();
  if (imsi_ == &::google::protobuf::internal::kEmptyString) {
    imsi_ = new ::std::string;
  }
  return imsi_;
}
inline ::std::string* IDPToCCRIData::release_imsi() {
  clear_has_imsi();
  if (imsi_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = imsi_;
    imsi_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes VLR_Number = 14 [default = ""];
inline bool IDPToCCRIData::has_vlr_number() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void IDPToCCRIData::set_has_vlr_number() {
  _has_bits_[0] |= 0x00002000u;
}
inline void IDPToCCRIData::clear_has_vlr_number() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void IDPToCCRIData::clear_vlr_number() {
  if (vlr_number_ != &::google::protobuf::internal::kEmptyString) {
    vlr_number_->clear();
  }
  clear_has_vlr_number();
}
inline const ::std::string& IDPToCCRIData::vlr_number() const {
  return *vlr_number_;
}
inline void IDPToCCRIData::set_vlr_number(const ::std::string& value) {
  set_has_vlr_number();
  if (vlr_number_ == &::google::protobuf::internal::kEmptyString) {
    vlr_number_ = new ::std::string;
  }
  vlr_number_->assign(value);
}
inline void IDPToCCRIData::set_vlr_number(const char* value) {
  set_has_vlr_number();
  if (vlr_number_ == &::google::protobuf::internal::kEmptyString) {
    vlr_number_ = new ::std::string;
  }
  vlr_number_->assign(value);
}
inline void IDPToCCRIData::set_vlr_number(const void* value, size_t size) {
  set_has_vlr_number();
  if (vlr_number_ == &::google::protobuf::internal::kEmptyString) {
    vlr_number_ = new ::std::string;
  }
  vlr_number_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IDPToCCRIData::mutable_vlr_number() {
  set_has_vlr_number();
  if (vlr_number_ == &::google::protobuf::internal::kEmptyString) {
    vlr_number_ = new ::std::string;
  }
  return vlr_number_;
}
inline ::std::string* IDPToCCRIData::release_vlr_number() {
  clear_has_vlr_number();
  if (vlr_number_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vlr_number_;
    vlr_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes Call_Reference = 15 [default = ""];
inline bool IDPToCCRIData::has_call_reference() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void IDPToCCRIData::set_has_call_reference() {
  _has_bits_[0] |= 0x00004000u;
}
inline void IDPToCCRIData::clear_has_call_reference() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void IDPToCCRIData::clear_call_reference() {
  if (call_reference_ != &::google::protobuf::internal::kEmptyString) {
    call_reference_->clear();
  }
  clear_has_call_reference();
}
inline const ::std::string& IDPToCCRIData::call_reference() const {
  return *call_reference_;
}
inline void IDPToCCRIData::set_call_reference(const ::std::string& value) {
  set_has_call_reference();
  if (call_reference_ == &::google::protobuf::internal::kEmptyString) {
    call_reference_ = new ::std::string;
  }
  call_reference_->assign(value);
}
inline void IDPToCCRIData::set_call_reference(const char* value) {
  set_has_call_reference();
  if (call_reference_ == &::google::protobuf::internal::kEmptyString) {
    call_reference_ = new ::std::string;
  }
  call_reference_->assign(value);
}
inline void IDPToCCRIData::set_call_reference(const void* value, size_t size) {
  set_has_call_reference();
  if (call_reference_ == &::google::protobuf::internal::kEmptyString) {
    call_reference_ = new ::std::string;
  }
  call_reference_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IDPToCCRIData::mutable_call_reference() {
  set_has_call_reference();
  if (call_reference_ == &::google::protobuf::internal::kEmptyString) {
    call_reference_ = new ::std::string;
  }
  return call_reference_;
}
inline ::std::string* IDPToCCRIData::release_call_reference() {
  clear_has_call_reference();
  if (call_reference_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = call_reference_;
    call_reference_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes MSC_Address = 16 [default = ""];
inline bool IDPToCCRIData::has_msc_address() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void IDPToCCRIData::set_has_msc_address() {
  _has_bits_[0] |= 0x00008000u;
}
inline void IDPToCCRIData::clear_has_msc_address() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void IDPToCCRIData::clear_msc_address() {
  if (msc_address_ != &::google::protobuf::internal::kEmptyString) {
    msc_address_->clear();
  }
  clear_has_msc_address();
}
inline const ::std::string& IDPToCCRIData::msc_address() const {
  return *msc_address_;
}
inline void IDPToCCRIData::set_msc_address(const ::std::string& value) {
  set_has_msc_address();
  if (msc_address_ == &::google::protobuf::internal::kEmptyString) {
    msc_address_ = new ::std::string;
  }
  msc_address_->assign(value);
}
inline void IDPToCCRIData::set_msc_address(const char* value) {
  set_has_msc_address();
  if (msc_address_ == &::google::protobuf::internal::kEmptyString) {
    msc_address_ = new ::std::string;
  }
  msc_address_->assign(value);
}
inline void IDPToCCRIData::set_msc_address(const void* value, size_t size) {
  set_has_msc_address();
  if (msc_address_ == &::google::protobuf::internal::kEmptyString) {
    msc_address_ = new ::std::string;
  }
  msc_address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IDPToCCRIData::mutable_msc_address() {
  set_has_msc_address();
  if (msc_address_ == &::google::protobuf::internal::kEmptyString) {
    msc_address_ = new ::std::string;
  }
  return msc_address_;
}
inline ::std::string* IDPToCCRIData::release_msc_address() {
  clear_has_msc_address();
  if (msc_address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msc_address_;
    msc_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 Called_NPI = 17 [default = 1000];
inline bool IDPToCCRIData::has_called_npi() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void IDPToCCRIData::set_has_called_npi() {
  _has_bits_[0] |= 0x00010000u;
}
inline void IDPToCCRIData::clear_has_called_npi() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void IDPToCCRIData::clear_called_npi() {
  called_npi_ = 1000u;
  clear_has_called_npi();
}
inline ::google::protobuf::uint32 IDPToCCRIData::called_npi() const {
  return called_npi_;
}
inline void IDPToCCRIData::set_called_npi(::google::protobuf::uint32 value) {
  set_has_called_npi();
  called_npi_ = value;
}

// optional uint32 Calling_NOA = 18 [default = 1000];
inline bool IDPToCCRIData::has_calling_noa() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void IDPToCCRIData::set_has_calling_noa() {
  _has_bits_[0] |= 0x00020000u;
}
inline void IDPToCCRIData::clear_has_calling_noa() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void IDPToCCRIData::clear_calling_noa() {
  calling_noa_ = 1000u;
  clear_has_calling_noa();
}
inline ::google::protobuf::uint32 IDPToCCRIData::calling_noa() const {
  return calling_noa_;
}
inline void IDPToCCRIData::set_calling_noa(::google::protobuf::uint32 value) {
  set_has_calling_noa();
  calling_noa_ = value;
}

// optional uint32 CLI_NPI = 19 [default = 1000];
inline bool IDPToCCRIData::has_cli_npi() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void IDPToCCRIData::set_has_cli_npi() {
  _has_bits_[0] |= 0x00040000u;
}
inline void IDPToCCRIData::clear_has_cli_npi() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void IDPToCCRIData::clear_cli_npi() {
  cli_npi_ = 1000u;
  clear_has_cli_npi();
}
inline ::google::protobuf::uint32 IDPToCCRIData::cli_npi() const {
  return cli_npi_;
}
inline void IDPToCCRIData::set_cli_npi(::google::protobuf::uint32 value) {
  set_has_cli_npi();
  cli_npi_ = value;
}

// optional uint32 CLIR = 20 [default = 1000];
inline bool IDPToCCRIData::has_clir() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void IDPToCCRIData::set_has_clir() {
  _has_bits_[0] |= 0x00080000u;
}
inline void IDPToCCRIData::clear_has_clir() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void IDPToCCRIData::clear_clir() {
  clir_ = 1000u;
  clear_has_clir();
}
inline ::google::protobuf::uint32 IDPToCCRIData::clir() const {
  return clir_;
}
inline void IDPToCCRIData::set_clir(::google::protobuf::uint32 value) {
  set_has_clir();
  clir_ = value;
}

// optional uint32 Version = 21 [default = 1000];
inline bool IDPToCCRIData::has_version() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void IDPToCCRIData::set_has_version() {
  _has_bits_[0] |= 0x00100000u;
}
inline void IDPToCCRIData::clear_has_version() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void IDPToCCRIData::clear_version() {
  version_ = 1000u;
  clear_has_version();
}
inline ::google::protobuf::uint32 IDPToCCRIData::version() const {
  return version_;
}
inline void IDPToCCRIData::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
}

// optional bytes SCCP_CallingGT = 22 [default = ""];
inline bool IDPToCCRIData::has_sccp_callinggt() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void IDPToCCRIData::set_has_sccp_callinggt() {
  _has_bits_[0] |= 0x00200000u;
}
inline void IDPToCCRIData::clear_has_sccp_callinggt() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void IDPToCCRIData::clear_sccp_callinggt() {
  if (sccp_callinggt_ != &::google::protobuf::internal::kEmptyString) {
    sccp_callinggt_->clear();
  }
  clear_has_sccp_callinggt();
}
inline const ::std::string& IDPToCCRIData::sccp_callinggt() const {
  return *sccp_callinggt_;
}
inline void IDPToCCRIData::set_sccp_callinggt(const ::std::string& value) {
  set_has_sccp_callinggt();
  if (sccp_callinggt_ == &::google::protobuf::internal::kEmptyString) {
    sccp_callinggt_ = new ::std::string;
  }
  sccp_callinggt_->assign(value);
}
inline void IDPToCCRIData::set_sccp_callinggt(const char* value) {
  set_has_sccp_callinggt();
  if (sccp_callinggt_ == &::google::protobuf::internal::kEmptyString) {
    sccp_callinggt_ = new ::std::string;
  }
  sccp_callinggt_->assign(value);
}
inline void IDPToCCRIData::set_sccp_callinggt(const void* value, size_t size) {
  set_has_sccp_callinggt();
  if (sccp_callinggt_ == &::google::protobuf::internal::kEmptyString) {
    sccp_callinggt_ = new ::std::string;
  }
  sccp_callinggt_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IDPToCCRIData::mutable_sccp_callinggt() {
  set_has_sccp_callinggt();
  if (sccp_callinggt_ == &::google::protobuf::internal::kEmptyString) {
    sccp_callinggt_ = new ::std::string;
  }
  return sccp_callinggt_;
}
inline ::std::string* IDPToCCRIData::release_sccp_callinggt() {
  clear_has_sccp_callinggt();
  if (sccp_callinggt_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sccp_callinggt_;
    sccp_callinggt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes SCCP_CalledGT = 23 [default = ""];
inline bool IDPToCCRIData::has_sccp_calledgt() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void IDPToCCRIData::set_has_sccp_calledgt() {
  _has_bits_[0] |= 0x00400000u;
}
inline void IDPToCCRIData::clear_has_sccp_calledgt() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void IDPToCCRIData::clear_sccp_calledgt() {
  if (sccp_calledgt_ != &::google::protobuf::internal::kEmptyString) {
    sccp_calledgt_->clear();
  }
  clear_has_sccp_calledgt();
}
inline const ::std::string& IDPToCCRIData::sccp_calledgt() const {
  return *sccp_calledgt_;
}
inline void IDPToCCRIData::set_sccp_calledgt(const ::std::string& value) {
  set_has_sccp_calledgt();
  if (sccp_calledgt_ == &::google::protobuf::internal::kEmptyString) {
    sccp_calledgt_ = new ::std::string;
  }
  sccp_calledgt_->assign(value);
}
inline void IDPToCCRIData::set_sccp_calledgt(const char* value) {
  set_has_sccp_calledgt();
  if (sccp_calledgt_ == &::google::protobuf::internal::kEmptyString) {
    sccp_calledgt_ = new ::std::string;
  }
  sccp_calledgt_->assign(value);
}
inline void IDPToCCRIData::set_sccp_calledgt(const void* value, size_t size) {
  set_has_sccp_calledgt();
  if (sccp_calledgt_ == &::google::protobuf::internal::kEmptyString) {
    sccp_calledgt_ = new ::std::string;
  }
  sccp_calledgt_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IDPToCCRIData::mutable_sccp_calledgt() {
  set_has_sccp_calledgt();
  if (sccp_calledgt_ == &::google::protobuf::internal::kEmptyString) {
    sccp_calledgt_ = new ::std::string;
  }
  return sccp_calledgt_;
}
inline ::std::string* IDPToCCRIData::release_sccp_calledgt() {
  clear_has_sccp_calledgt();
  if (sccp_calledgt_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sccp_calledgt_;
    sccp_calledgt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 GSM_Forwarding_Pending = 24 [default = 1000];
inline bool IDPToCCRIData::has_gsm_forwarding_pending() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void IDPToCCRIData::set_has_gsm_forwarding_pending() {
  _has_bits_[0] |= 0x00800000u;
}
inline void IDPToCCRIData::clear_has_gsm_forwarding_pending() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void IDPToCCRIData::clear_gsm_forwarding_pending() {
  gsm_forwarding_pending_ = 1000u;
  clear_has_gsm_forwarding_pending();
}
inline ::google::protobuf::uint32 IDPToCCRIData::gsm_forwarding_pending() const {
  return gsm_forwarding_pending_;
}
inline void IDPToCCRIData::set_gsm_forwarding_pending(::google::protobuf::uint32 value) {
  set_has_gsm_forwarding_pending();
  gsm_forwarding_pending_ = value;
}

// optional bytes TCAP_Remote_Transaction_Id = 25 [default = ""];
inline bool IDPToCCRIData::has_tcap_remote_transaction_id() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void IDPToCCRIData::set_has_tcap_remote_transaction_id() {
  _has_bits_[0] |= 0x01000000u;
}
inline void IDPToCCRIData::clear_has_tcap_remote_transaction_id() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void IDPToCCRIData::clear_tcap_remote_transaction_id() {
  if (tcap_remote_transaction_id_ != &::google::protobuf::internal::kEmptyString) {
    tcap_remote_transaction_id_->clear();
  }
  clear_has_tcap_remote_transaction_id();
}
inline const ::std::string& IDPToCCRIData::tcap_remote_transaction_id() const {
  return *tcap_remote_transaction_id_;
}
inline void IDPToCCRIData::set_tcap_remote_transaction_id(const ::std::string& value) {
  set_has_tcap_remote_transaction_id();
  if (tcap_remote_transaction_id_ == &::google::protobuf::internal::kEmptyString) {
    tcap_remote_transaction_id_ = new ::std::string;
  }
  tcap_remote_transaction_id_->assign(value);
}
inline void IDPToCCRIData::set_tcap_remote_transaction_id(const char* value) {
  set_has_tcap_remote_transaction_id();
  if (tcap_remote_transaction_id_ == &::google::protobuf::internal::kEmptyString) {
    tcap_remote_transaction_id_ = new ::std::string;
  }
  tcap_remote_transaction_id_->assign(value);
}
inline void IDPToCCRIData::set_tcap_remote_transaction_id(const void* value, size_t size) {
  set_has_tcap_remote_transaction_id();
  if (tcap_remote_transaction_id_ == &::google::protobuf::internal::kEmptyString) {
    tcap_remote_transaction_id_ = new ::std::string;
  }
  tcap_remote_transaction_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IDPToCCRIData::mutable_tcap_remote_transaction_id() {
  set_has_tcap_remote_transaction_id();
  if (tcap_remote_transaction_id_ == &::google::protobuf::internal::kEmptyString) {
    tcap_remote_transaction_id_ = new ::std::string;
  }
  return tcap_remote_transaction_id_;
}
inline ::std::string* IDPToCCRIData::release_tcap_remote_transaction_id() {
  clear_has_tcap_remote_transaction_id();
  if (tcap_remote_transaction_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tcap_remote_transaction_id_;
    tcap_remote_transaction_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes TCAP_Local_Transaction_Id = 26 [default = ""];
inline bool IDPToCCRIData::has_tcap_local_transaction_id() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void IDPToCCRIData::set_has_tcap_local_transaction_id() {
  _has_bits_[0] |= 0x02000000u;
}
inline void IDPToCCRIData::clear_has_tcap_local_transaction_id() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void IDPToCCRIData::clear_tcap_local_transaction_id() {
  if (tcap_local_transaction_id_ != &::google::protobuf::internal::kEmptyString) {
    tcap_local_transaction_id_->clear();
  }
  clear_has_tcap_local_transaction_id();
}
inline const ::std::string& IDPToCCRIData::tcap_local_transaction_id() const {
  return *tcap_local_transaction_id_;
}
inline void IDPToCCRIData::set_tcap_local_transaction_id(const ::std::string& value) {
  set_has_tcap_local_transaction_id();
  if (tcap_local_transaction_id_ == &::google::protobuf::internal::kEmptyString) {
    tcap_local_transaction_id_ = new ::std::string;
  }
  tcap_local_transaction_id_->assign(value);
}
inline void IDPToCCRIData::set_tcap_local_transaction_id(const char* value) {
  set_has_tcap_local_transaction_id();
  if (tcap_local_transaction_id_ == &::google::protobuf::internal::kEmptyString) {
    tcap_local_transaction_id_ = new ::std::string;
  }
  tcap_local_transaction_id_->assign(value);
}
inline void IDPToCCRIData::set_tcap_local_transaction_id(const void* value, size_t size) {
  set_has_tcap_local_transaction_id();
  if (tcap_local_transaction_id_ == &::google::protobuf::internal::kEmptyString) {
    tcap_local_transaction_id_ = new ::std::string;
  }
  tcap_local_transaction_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IDPToCCRIData::mutable_tcap_local_transaction_id() {
  set_has_tcap_local_transaction_id();
  if (tcap_local_transaction_id_ == &::google::protobuf::internal::kEmptyString) {
    tcap_local_transaction_id_ = new ::std::string;
  }
  return tcap_local_transaction_id_;
}
inline ::std::string* IDPToCCRIData::release_tcap_local_transaction_id() {
  clear_has_tcap_local_transaction_id();
  if (tcap_local_transaction_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tcap_local_transaction_id_;
    tcap_local_transaction_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes CellID_AreaID_LAI = 27 [default = ""];
inline bool IDPToCCRIData::has_cellid_areaid_lai() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void IDPToCCRIData::set_has_cellid_areaid_lai() {
  _has_bits_[0] |= 0x04000000u;
}
inline void IDPToCCRIData::clear_has_cellid_areaid_lai() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void IDPToCCRIData::clear_cellid_areaid_lai() {
  if (cellid_areaid_lai_ != &::google::protobuf::internal::kEmptyString) {
    cellid_areaid_lai_->clear();
  }
  clear_has_cellid_areaid_lai();
}
inline const ::std::string& IDPToCCRIData::cellid_areaid_lai() const {
  return *cellid_areaid_lai_;
}
inline void IDPToCCRIData::set_cellid_areaid_lai(const ::std::string& value) {
  set_has_cellid_areaid_lai();
  if (cellid_areaid_lai_ == &::google::protobuf::internal::kEmptyString) {
    cellid_areaid_lai_ = new ::std::string;
  }
  cellid_areaid_lai_->assign(value);
}
inline void IDPToCCRIData::set_cellid_areaid_lai(const char* value) {
  set_has_cellid_areaid_lai();
  if (cellid_areaid_lai_ == &::google::protobuf::internal::kEmptyString) {
    cellid_areaid_lai_ = new ::std::string;
  }
  cellid_areaid_lai_->assign(value);
}
inline void IDPToCCRIData::set_cellid_areaid_lai(const void* value, size_t size) {
  set_has_cellid_areaid_lai();
  if (cellid_areaid_lai_ == &::google::protobuf::internal::kEmptyString) {
    cellid_areaid_lai_ = new ::std::string;
  }
  cellid_areaid_lai_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IDPToCCRIData::mutable_cellid_areaid_lai() {
  set_has_cellid_areaid_lai();
  if (cellid_areaid_lai_ == &::google::protobuf::internal::kEmptyString) {
    cellid_areaid_lai_ = new ::std::string;
  }
  return cellid_areaid_lai_;
}
inline ::std::string* IDPToCCRIData::release_cellid_areaid_lai() {
  clear_has_cellid_areaid_lai();
  if (cellid_areaid_lai_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cellid_areaid_lai_;
    cellid_areaid_lai_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 Event_Type_BCSM = 28 [default = 1000];
inline bool IDPToCCRIData::has_event_type_bcsm() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void IDPToCCRIData::set_has_event_type_bcsm() {
  _has_bits_[0] |= 0x08000000u;
}
inline void IDPToCCRIData::clear_has_event_type_bcsm() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void IDPToCCRIData::clear_event_type_bcsm() {
  event_type_bcsm_ = 1000u;
  clear_has_event_type_bcsm();
}
inline ::google::protobuf::uint32 IDPToCCRIData::event_type_bcsm() const {
  return event_type_bcsm_;
}
inline void IDPToCCRIData::set_event_type_bcsm(::google::protobuf::uint32 value) {
  set_has_event_type_bcsm();
  event_type_bcsm_ = value;
}

// optional uint32 TCAP_Error_Cause = 29 [default = 500];
inline bool IDPToCCRIData::has_tcap_error_cause() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void IDPToCCRIData::set_has_tcap_error_cause() {
  _has_bits_[0] |= 0x10000000u;
}
inline void IDPToCCRIData::clear_has_tcap_error_cause() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void IDPToCCRIData::clear_tcap_error_cause() {
  tcap_error_cause_ = 500u;
  clear_has_tcap_error_cause();
}
inline ::google::protobuf::uint32 IDPToCCRIData::tcap_error_cause() const {
  return tcap_error_cause_;
}
inline void IDPToCCRIData::set_tcap_error_cause(::google::protobuf::uint32 value) {
  set_has_tcap_error_cause();
  tcap_error_cause_ = value;
}

// optional uint32 SCCP_Error_Cause = 30 [default = 0];
inline bool IDPToCCRIData::has_sccp_error_cause() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void IDPToCCRIData::set_has_sccp_error_cause() {
  _has_bits_[0] |= 0x20000000u;
}
inline void IDPToCCRIData::clear_has_sccp_error_cause() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void IDPToCCRIData::clear_sccp_error_cause() {
  sccp_error_cause_ = 0u;
  clear_has_sccp_error_cause();
}
inline ::google::protobuf::uint32 IDPToCCRIData::sccp_error_cause() const {
  return sccp_error_cause_;
}
inline void IDPToCCRIData::set_sccp_error_cause(::google::protobuf::uint32 value) {
  set_has_sccp_error_cause();
  sccp_error_cause_ = value;
}

// optional bytes GMSC = 31 [default = ""];
inline bool IDPToCCRIData::has_gmsc() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void IDPToCCRIData::set_has_gmsc() {
  _has_bits_[0] |= 0x40000000u;
}
inline void IDPToCCRIData::clear_has_gmsc() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void IDPToCCRIData::clear_gmsc() {
  if (gmsc_ != &::google::protobuf::internal::kEmptyString) {
    gmsc_->clear();
  }
  clear_has_gmsc();
}
inline const ::std::string& IDPToCCRIData::gmsc() const {
  return *gmsc_;
}
inline void IDPToCCRIData::set_gmsc(const ::std::string& value) {
  set_has_gmsc();
  if (gmsc_ == &::google::protobuf::internal::kEmptyString) {
    gmsc_ = new ::std::string;
  }
  gmsc_->assign(value);
}
inline void IDPToCCRIData::set_gmsc(const char* value) {
  set_has_gmsc();
  if (gmsc_ == &::google::protobuf::internal::kEmptyString) {
    gmsc_ = new ::std::string;
  }
  gmsc_->assign(value);
}
inline void IDPToCCRIData::set_gmsc(const void* value, size_t size) {
  set_has_gmsc();
  if (gmsc_ == &::google::protobuf::internal::kEmptyString) {
    gmsc_ = new ::std::string;
  }
  gmsc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IDPToCCRIData::mutable_gmsc() {
  set_has_gmsc();
  if (gmsc_ == &::google::protobuf::internal::kEmptyString) {
    gmsc_ = new ::std::string;
  }
  return gmsc_;
}
inline ::std::string* IDPToCCRIData::release_gmsc() {
  clear_has_gmsc();
  if (gmsc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gmsc_;
    gmsc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes Ext_Basic_Service_Code = 32 [default = ""];
inline bool IDPToCCRIData::has_ext_basic_service_code() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void IDPToCCRIData::set_has_ext_basic_service_code() {
  _has_bits_[0] |= 0x80000000u;
}
inline void IDPToCCRIData::clear_has_ext_basic_service_code() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void IDPToCCRIData::clear_ext_basic_service_code() {
  if (ext_basic_service_code_ != &::google::protobuf::internal::kEmptyString) {
    ext_basic_service_code_->clear();
  }
  clear_has_ext_basic_service_code();
}
inline const ::std::string& IDPToCCRIData::ext_basic_service_code() const {
  return *ext_basic_service_code_;
}
inline void IDPToCCRIData::set_ext_basic_service_code(const ::std::string& value) {
  set_has_ext_basic_service_code();
  if (ext_basic_service_code_ == &::google::protobuf::internal::kEmptyString) {
    ext_basic_service_code_ = new ::std::string;
  }
  ext_basic_service_code_->assign(value);
}
inline void IDPToCCRIData::set_ext_basic_service_code(const char* value) {
  set_has_ext_basic_service_code();
  if (ext_basic_service_code_ == &::google::protobuf::internal::kEmptyString) {
    ext_basic_service_code_ = new ::std::string;
  }
  ext_basic_service_code_->assign(value);
}
inline void IDPToCCRIData::set_ext_basic_service_code(const void* value, size_t size) {
  set_has_ext_basic_service_code();
  if (ext_basic_service_code_ == &::google::protobuf::internal::kEmptyString) {
    ext_basic_service_code_ = new ::std::string;
  }
  ext_basic_service_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IDPToCCRIData::mutable_ext_basic_service_code() {
  set_has_ext_basic_service_code();
  if (ext_basic_service_code_ == &::google::protobuf::internal::kEmptyString) {
    ext_basic_service_code_ = new ::std::string;
  }
  return ext_basic_service_code_;
}
inline ::std::string* IDPToCCRIData::release_ext_basic_service_code() {
  clear_has_ext_basic_service_code();
  if (ext_basic_service_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ext_basic_service_code_;
    ext_basic_service_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes Bearer_Capability = 33 [default = ""];
inline bool IDPToCCRIData::has_bearer_capability() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void IDPToCCRIData::set_has_bearer_capability() {
  _has_bits_[1] |= 0x00000001u;
}
inline void IDPToCCRIData::clear_has_bearer_capability() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void IDPToCCRIData::clear_bearer_capability() {
  if (bearer_capability_ != &::google::protobuf::internal::kEmptyString) {
    bearer_capability_->clear();
  }
  clear_has_bearer_capability();
}
inline const ::std::string& IDPToCCRIData::bearer_capability() const {
  return *bearer_capability_;
}
inline void IDPToCCRIData::set_bearer_capability(const ::std::string& value) {
  set_has_bearer_capability();
  if (bearer_capability_ == &::google::protobuf::internal::kEmptyString) {
    bearer_capability_ = new ::std::string;
  }
  bearer_capability_->assign(value);
}
inline void IDPToCCRIData::set_bearer_capability(const char* value) {
  set_has_bearer_capability();
  if (bearer_capability_ == &::google::protobuf::internal::kEmptyString) {
    bearer_capability_ = new ::std::string;
  }
  bearer_capability_->assign(value);
}
inline void IDPToCCRIData::set_bearer_capability(const void* value, size_t size) {
  set_has_bearer_capability();
  if (bearer_capability_ == &::google::protobuf::internal::kEmptyString) {
    bearer_capability_ = new ::std::string;
  }
  bearer_capability_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IDPToCCRIData::mutable_bearer_capability() {
  set_has_bearer_capability();
  if (bearer_capability_ == &::google::protobuf::internal::kEmptyString) {
    bearer_capability_ = new ::std::string;
  }
  return bearer_capability_;
}
inline ::std::string* IDPToCCRIData::release_bearer_capability() {
  clear_has_bearer_capability();
  if (bearer_capability_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bearer_capability_;
    bearer_capability_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes Bearer_Capability_Transfer = 34 [default = ""];
inline bool IDPToCCRIData::has_bearer_capability_transfer() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void IDPToCCRIData::set_has_bearer_capability_transfer() {
  _has_bits_[1] |= 0x00000002u;
}
inline void IDPToCCRIData::clear_has_bearer_capability_transfer() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void IDPToCCRIData::clear_bearer_capability_transfer() {
  if (bearer_capability_transfer_ != &::google::protobuf::internal::kEmptyString) {
    bearer_capability_transfer_->clear();
  }
  clear_has_bearer_capability_transfer();
}
inline const ::std::string& IDPToCCRIData::bearer_capability_transfer() const {
  return *bearer_capability_transfer_;
}
inline void IDPToCCRIData::set_bearer_capability_transfer(const ::std::string& value) {
  set_has_bearer_capability_transfer();
  if (bearer_capability_transfer_ == &::google::protobuf::internal::kEmptyString) {
    bearer_capability_transfer_ = new ::std::string;
  }
  bearer_capability_transfer_->assign(value);
}
inline void IDPToCCRIData::set_bearer_capability_transfer(const char* value) {
  set_has_bearer_capability_transfer();
  if (bearer_capability_transfer_ == &::google::protobuf::internal::kEmptyString) {
    bearer_capability_transfer_ = new ::std::string;
  }
  bearer_capability_transfer_->assign(value);
}
inline void IDPToCCRIData::set_bearer_capability_transfer(const void* value, size_t size) {
  set_has_bearer_capability_transfer();
  if (bearer_capability_transfer_ == &::google::protobuf::internal::kEmptyString) {
    bearer_capability_transfer_ = new ::std::string;
  }
  bearer_capability_transfer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IDPToCCRIData::mutable_bearer_capability_transfer() {
  set_has_bearer_capability_transfer();
  if (bearer_capability_transfer_ == &::google::protobuf::internal::kEmptyString) {
    bearer_capability_transfer_ = new ::std::string;
  }
  return bearer_capability_transfer_;
}
inline ::std::string* IDPToCCRIData::release_bearer_capability_transfer() {
  clear_has_bearer_capability_transfer();
  if (bearer_capability_transfer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bearer_capability_transfer_;
    bearer_capability_transfer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes Bearer_Capability_Transfer_Rate = 35 [default = ""];
inline bool IDPToCCRIData::has_bearer_capability_transfer_rate() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void IDPToCCRIData::set_has_bearer_capability_transfer_rate() {
  _has_bits_[1] |= 0x00000004u;
}
inline void IDPToCCRIData::clear_has_bearer_capability_transfer_rate() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void IDPToCCRIData::clear_bearer_capability_transfer_rate() {
  if (bearer_capability_transfer_rate_ != &::google::protobuf::internal::kEmptyString) {
    bearer_capability_transfer_rate_->clear();
  }
  clear_has_bearer_capability_transfer_rate();
}
inline const ::std::string& IDPToCCRIData::bearer_capability_transfer_rate() const {
  return *bearer_capability_transfer_rate_;
}
inline void IDPToCCRIData::set_bearer_capability_transfer_rate(const ::std::string& value) {
  set_has_bearer_capability_transfer_rate();
  if (bearer_capability_transfer_rate_ == &::google::protobuf::internal::kEmptyString) {
    bearer_capability_transfer_rate_ = new ::std::string;
  }
  bearer_capability_transfer_rate_->assign(value);
}
inline void IDPToCCRIData::set_bearer_capability_transfer_rate(const char* value) {
  set_has_bearer_capability_transfer_rate();
  if (bearer_capability_transfer_rate_ == &::google::protobuf::internal::kEmptyString) {
    bearer_capability_transfer_rate_ = new ::std::string;
  }
  bearer_capability_transfer_rate_->assign(value);
}
inline void IDPToCCRIData::set_bearer_capability_transfer_rate(const void* value, size_t size) {
  set_has_bearer_capability_transfer_rate();
  if (bearer_capability_transfer_rate_ == &::google::protobuf::internal::kEmptyString) {
    bearer_capability_transfer_rate_ = new ::std::string;
  }
  bearer_capability_transfer_rate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IDPToCCRIData::mutable_bearer_capability_transfer_rate() {
  set_has_bearer_capability_transfer_rate();
  if (bearer_capability_transfer_rate_ == &::google::protobuf::internal::kEmptyString) {
    bearer_capability_transfer_rate_ = new ::std::string;
  }
  return bearer_capability_transfer_rate_;
}
inline ::std::string* IDPToCCRIData::release_bearer_capability_transfer_rate() {
  clear_has_bearer_capability_transfer_rate();
  if (bearer_capability_transfer_rate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bearer_capability_transfer_rate_;
    bearer_capability_transfer_rate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes Bearer_Capability_Transfer_Mode = 36 [default = ""];
inline bool IDPToCCRIData::has_bearer_capability_transfer_mode() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void IDPToCCRIData::set_has_bearer_capability_transfer_mode() {
  _has_bits_[1] |= 0x00000008u;
}
inline void IDPToCCRIData::clear_has_bearer_capability_transfer_mode() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void IDPToCCRIData::clear_bearer_capability_transfer_mode() {
  if (bearer_capability_transfer_mode_ != &::google::protobuf::internal::kEmptyString) {
    bearer_capability_transfer_mode_->clear();
  }
  clear_has_bearer_capability_transfer_mode();
}
inline const ::std::string& IDPToCCRIData::bearer_capability_transfer_mode() const {
  return *bearer_capability_transfer_mode_;
}
inline void IDPToCCRIData::set_bearer_capability_transfer_mode(const ::std::string& value) {
  set_has_bearer_capability_transfer_mode();
  if (bearer_capability_transfer_mode_ == &::google::protobuf::internal::kEmptyString) {
    bearer_capability_transfer_mode_ = new ::std::string;
  }
  bearer_capability_transfer_mode_->assign(value);
}
inline void IDPToCCRIData::set_bearer_capability_transfer_mode(const char* value) {
  set_has_bearer_capability_transfer_mode();
  if (bearer_capability_transfer_mode_ == &::google::protobuf::internal::kEmptyString) {
    bearer_capability_transfer_mode_ = new ::std::string;
  }
  bearer_capability_transfer_mode_->assign(value);
}
inline void IDPToCCRIData::set_bearer_capability_transfer_mode(const void* value, size_t size) {
  set_has_bearer_capability_transfer_mode();
  if (bearer_capability_transfer_mode_ == &::google::protobuf::internal::kEmptyString) {
    bearer_capability_transfer_mode_ = new ::std::string;
  }
  bearer_capability_transfer_mode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IDPToCCRIData::mutable_bearer_capability_transfer_mode() {
  set_has_bearer_capability_transfer_mode();
  if (bearer_capability_transfer_mode_ == &::google::protobuf::internal::kEmptyString) {
    bearer_capability_transfer_mode_ = new ::std::string;
  }
  return bearer_capability_transfer_mode_;
}
inline ::std::string* IDPToCCRIData::release_bearer_capability_transfer_mode() {
  clear_has_bearer_capability_transfer_mode();
  if (bearer_capability_transfer_mode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bearer_capability_transfer_mode_;
    bearer_capability_transfer_mode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes Bearer_Capability_Cdr = 37 [default = ""];
inline bool IDPToCCRIData::has_bearer_capability_cdr() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void IDPToCCRIData::set_has_bearer_capability_cdr() {
  _has_bits_[1] |= 0x00000010u;
}
inline void IDPToCCRIData::clear_has_bearer_capability_cdr() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void IDPToCCRIData::clear_bearer_capability_cdr() {
  if (bearer_capability_cdr_ != &::google::protobuf::internal::kEmptyString) {
    bearer_capability_cdr_->clear();
  }
  clear_has_bearer_capability_cdr();
}
inline const ::std::string& IDPToCCRIData::bearer_capability_cdr() const {
  return *bearer_capability_cdr_;
}
inline void IDPToCCRIData::set_bearer_capability_cdr(const ::std::string& value) {
  set_has_bearer_capability_cdr();
  if (bearer_capability_cdr_ == &::google::protobuf::internal::kEmptyString) {
    bearer_capability_cdr_ = new ::std::string;
  }
  bearer_capability_cdr_->assign(value);
}
inline void IDPToCCRIData::set_bearer_capability_cdr(const char* value) {
  set_has_bearer_capability_cdr();
  if (bearer_capability_cdr_ == &::google::protobuf::internal::kEmptyString) {
    bearer_capability_cdr_ = new ::std::string;
  }
  bearer_capability_cdr_->assign(value);
}
inline void IDPToCCRIData::set_bearer_capability_cdr(const void* value, size_t size) {
  set_has_bearer_capability_cdr();
  if (bearer_capability_cdr_ == &::google::protobuf::internal::kEmptyString) {
    bearer_capability_cdr_ = new ::std::string;
  }
  bearer_capability_cdr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IDPToCCRIData::mutable_bearer_capability_cdr() {
  set_has_bearer_capability_cdr();
  if (bearer_capability_cdr_ == &::google::protobuf::internal::kEmptyString) {
    bearer_capability_cdr_ = new ::std::string;
  }
  return bearer_capability_cdr_;
}
inline ::std::string* IDPToCCRIData::release_bearer_capability_cdr() {
  clear_has_bearer_capability_cdr();
  if (bearer_capability_cdr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bearer_capability_cdr_;
    bearer_capability_cdr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool CAPIsFollowingOn = 38 [default = false];
inline bool IDPToCCRIData::has_capisfollowingon() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void IDPToCCRIData::set_has_capisfollowingon() {
  _has_bits_[1] |= 0x00000020u;
}
inline void IDPToCCRIData::clear_has_capisfollowingon() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void IDPToCCRIData::clear_capisfollowingon() {
  capisfollowingon_ = false;
  clear_has_capisfollowingon();
}
inline bool IDPToCCRIData::capisfollowingon() const {
  return capisfollowingon_;
}
inline void IDPToCCRIData::set_capisfollowingon(bool value) {
  set_has_capisfollowingon();
  capisfollowingon_ = value;
}

// optional .SubscriptionIdConfig subscriptionIdInfo = 39;
inline bool IDPToCCRIData::has_subscriptionidinfo() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void IDPToCCRIData::set_has_subscriptionidinfo() {
  _has_bits_[1] |= 0x00000040u;
}
inline void IDPToCCRIData::clear_has_subscriptionidinfo() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void IDPToCCRIData::clear_subscriptionidinfo() {
  if (subscriptionidinfo_ != NULL) subscriptionidinfo_->::SubscriptionIdConfig::Clear();
  clear_has_subscriptionidinfo();
}
inline const ::SubscriptionIdConfig& IDPToCCRIData::subscriptionidinfo() const {
  return subscriptionidinfo_ != NULL ? *subscriptionidinfo_ : *default_instance_->subscriptionidinfo_;
}
inline ::SubscriptionIdConfig* IDPToCCRIData::mutable_subscriptionidinfo() {
  set_has_subscriptionidinfo();
  if (subscriptionidinfo_ == NULL) subscriptionidinfo_ = new ::SubscriptionIdConfig;
  return subscriptionidinfo_;
}
inline ::SubscriptionIdConfig* IDPToCCRIData::release_subscriptionidinfo() {
  clear_has_subscriptionidinfo();
  ::SubscriptionIdConfig* temp = subscriptionidinfo_;
  subscriptionidinfo_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// pbERBData

// optional uint32 erbRecvEvtType = 1 [default = 0];
inline bool pbERBData::has_erbrecvevttype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pbERBData::set_has_erbrecvevttype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pbERBData::clear_has_erbrecvevttype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pbERBData::clear_erbrecvevttype() {
  erbrecvevttype_ = 0u;
  clear_has_erbrecvevttype();
}
inline ::google::protobuf::uint32 pbERBData::erbrecvevttype() const {
  return erbrecvevttype_;
}
inline void pbERBData::set_erbrecvevttype(::google::protobuf::uint32 value) {
  set_has_erbrecvevttype();
  erbrecvevttype_ = value;
}

// optional string eventSpecInfo = 2 [default = ""];
inline bool pbERBData::has_eventspecinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pbERBData::set_has_eventspecinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pbERBData::clear_has_eventspecinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pbERBData::clear_eventspecinfo() {
  if (eventspecinfo_ != &::google::protobuf::internal::kEmptyString) {
    eventspecinfo_->clear();
  }
  clear_has_eventspecinfo();
}
inline const ::std::string& pbERBData::eventspecinfo() const {
  return *eventspecinfo_;
}
inline void pbERBData::set_eventspecinfo(const ::std::string& value) {
  set_has_eventspecinfo();
  if (eventspecinfo_ == &::google::protobuf::internal::kEmptyString) {
    eventspecinfo_ = new ::std::string;
  }
  eventspecinfo_->assign(value);
}
inline void pbERBData::set_eventspecinfo(const char* value) {
  set_has_eventspecinfo();
  if (eventspecinfo_ == &::google::protobuf::internal::kEmptyString) {
    eventspecinfo_ = new ::std::string;
  }
  eventspecinfo_->assign(value);
}
inline void pbERBData::set_eventspecinfo(const char* value, size_t size) {
  set_has_eventspecinfo();
  if (eventspecinfo_ == &::google::protobuf::internal::kEmptyString) {
    eventspecinfo_ = new ::std::string;
  }
  eventspecinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbERBData::mutable_eventspecinfo() {
  set_has_eventspecinfo();
  if (eventspecinfo_ == &::google::protobuf::internal::kEmptyString) {
    eventspecinfo_ = new ::std::string;
  }
  return eventspecinfo_;
}
inline ::std::string* pbERBData::release_eventspecinfo() {
  clear_has_eventspecinfo();
  if (eventspecinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = eventspecinfo_;
    eventspecinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 recvlegId = 3 [default = 0];
inline bool pbERBData::has_recvlegid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void pbERBData::set_has_recvlegid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void pbERBData::clear_has_recvlegid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void pbERBData::clear_recvlegid() {
  recvlegid_ = 0u;
  clear_has_recvlegid();
}
inline ::google::protobuf::uint32 pbERBData::recvlegid() const {
  return recvlegid_;
}
inline void pbERBData::set_recvlegid(::google::protobuf::uint32 value) {
  set_has_recvlegid();
  recvlegid_ = value;
}

// optional uint32 msgType = 4 [default = 0];
inline bool pbERBData::has_msgtype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void pbERBData::set_has_msgtype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void pbERBData::clear_has_msgtype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void pbERBData::clear_msgtype() {
  msgtype_ = 0u;
  clear_has_msgtype();
}
inline ::google::protobuf::uint32 pbERBData::msgtype() const {
  return msgtype_;
}
inline void pbERBData::set_msgtype(::google::protobuf::uint32 value) {
  set_has_msgtype();
  msgtype_ = value;
}

// -------------------------------------------------------------------

// pbActivityTimerData

// optional uint32 atTimer = 1 [default = 0];
inline bool pbActivityTimerData::has_attimer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pbActivityTimerData::set_has_attimer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pbActivityTimerData::clear_has_attimer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pbActivityTimerData::clear_attimer() {
  attimer_ = 0u;
  clear_has_attimer();
}
inline ::google::protobuf::uint32 pbActivityTimerData::attimer() const {
  return attimer_;
}
inline void pbActivityTimerData::set_attimer(::google::protobuf::uint32 value) {
  set_has_attimer();
  attimer_ = value;
}

// optional uint32 responseTimeout = 2 [default = 0];
inline bool pbActivityTimerData::has_responsetimeout() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pbActivityTimerData::set_has_responsetimeout() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pbActivityTimerData::clear_has_responsetimeout() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pbActivityTimerData::clear_responsetimeout() {
  responsetimeout_ = 0u;
  clear_has_responsetimeout();
}
inline ::google::protobuf::uint32 pbActivityTimerData::responsetimeout() const {
  return responsetimeout_;
}
inline void pbActivityTimerData::set_responsetimeout(::google::protobuf::uint32 value) {
  set_has_responsetimeout();
  responsetimeout_ = value;
}

// optional uint32 retryCount = 3 [default = 0];
inline bool pbActivityTimerData::has_retrycount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void pbActivityTimerData::set_has_retrycount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void pbActivityTimerData::clear_has_retrycount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void pbActivityTimerData::clear_retrycount() {
  retrycount_ = 0u;
  clear_has_retrycount();
}
inline ::google::protobuf::uint32 pbActivityTimerData::retrycount() const {
  return retrycount_;
}
inline void pbActivityTimerData::set_retrycount(::google::protobuf::uint32 value) {
  set_has_retrycount();
  retrycount_ = value;
}

// optional uint32 invokeId = 4 [default = 0];
inline bool pbActivityTimerData::has_invokeid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void pbActivityTimerData::set_has_invokeid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void pbActivityTimerData::clear_has_invokeid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void pbActivityTimerData::clear_invokeid() {
  invokeid_ = 0u;
  clear_has_invokeid();
}
inline ::google::protobuf::uint32 pbActivityTimerData::invokeid() const {
  return invokeid_;
}
inline void pbActivityTimerData::set_invokeid(::google::protobuf::uint32 value) {
  set_has_invokeid();
  invokeid_ = value;
}

// -------------------------------------------------------------------

// pbIwfDccaSessionCtxt

// optional uint32 DccaState = 1 [default = 0];
inline bool pbIwfDccaSessionCtxt::has_dccastate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pbIwfDccaSessionCtxt::set_has_dccastate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pbIwfDccaSessionCtxt::clear_has_dccastate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pbIwfDccaSessionCtxt::clear_dccastate() {
  dccastate_ = 0u;
  clear_has_dccastate();
}
inline ::google::protobuf::uint32 pbIwfDccaSessionCtxt::dccastate() const {
  return dccastate_;
}
inline void pbIwfDccaSessionCtxt::set_dccastate(::google::protobuf::uint32 value) {
  set_has_dccastate();
  dccastate_ = value;
}

// optional string destHost = 2;
inline bool pbIwfDccaSessionCtxt::has_desthost() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pbIwfDccaSessionCtxt::set_has_desthost() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pbIwfDccaSessionCtxt::clear_has_desthost() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pbIwfDccaSessionCtxt::clear_desthost() {
  if (desthost_ != &::google::protobuf::internal::kEmptyString) {
    desthost_->clear();
  }
  clear_has_desthost();
}
inline const ::std::string& pbIwfDccaSessionCtxt::desthost() const {
  return *desthost_;
}
inline void pbIwfDccaSessionCtxt::set_desthost(const ::std::string& value) {
  set_has_desthost();
  if (desthost_ == &::google::protobuf::internal::kEmptyString) {
    desthost_ = new ::std::string;
  }
  desthost_->assign(value);
}
inline void pbIwfDccaSessionCtxt::set_desthost(const char* value) {
  set_has_desthost();
  if (desthost_ == &::google::protobuf::internal::kEmptyString) {
    desthost_ = new ::std::string;
  }
  desthost_->assign(value);
}
inline void pbIwfDccaSessionCtxt::set_desthost(const char* value, size_t size) {
  set_has_desthost();
  if (desthost_ == &::google::protobuf::internal::kEmptyString) {
    desthost_ = new ::std::string;
  }
  desthost_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbIwfDccaSessionCtxt::mutable_desthost() {
  set_has_desthost();
  if (desthost_ == &::google::protobuf::internal::kEmptyString) {
    desthost_ = new ::std::string;
  }
  return desthost_;
}
inline ::std::string* pbIwfDccaSessionCtxt::release_desthost() {
  clear_has_desthost();
  if (desthost_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = desthost_;
    desthost_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string destRealm = 3;
inline bool pbIwfDccaSessionCtxt::has_destrealm() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void pbIwfDccaSessionCtxt::set_has_destrealm() {
  _has_bits_[0] |= 0x00000004u;
}
inline void pbIwfDccaSessionCtxt::clear_has_destrealm() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void pbIwfDccaSessionCtxt::clear_destrealm() {
  if (destrealm_ != &::google::protobuf::internal::kEmptyString) {
    destrealm_->clear();
  }
  clear_has_destrealm();
}
inline const ::std::string& pbIwfDccaSessionCtxt::destrealm() const {
  return *destrealm_;
}
inline void pbIwfDccaSessionCtxt::set_destrealm(const ::std::string& value) {
  set_has_destrealm();
  if (destrealm_ == &::google::protobuf::internal::kEmptyString) {
    destrealm_ = new ::std::string;
  }
  destrealm_->assign(value);
}
inline void pbIwfDccaSessionCtxt::set_destrealm(const char* value) {
  set_has_destrealm();
  if (destrealm_ == &::google::protobuf::internal::kEmptyString) {
    destrealm_ = new ::std::string;
  }
  destrealm_->assign(value);
}
inline void pbIwfDccaSessionCtxt::set_destrealm(const char* value, size_t size) {
  set_has_destrealm();
  if (destrealm_ == &::google::protobuf::internal::kEmptyString) {
    destrealm_ = new ::std::string;
  }
  destrealm_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbIwfDccaSessionCtxt::mutable_destrealm() {
  set_has_destrealm();
  if (destrealm_ == &::google::protobuf::internal::kEmptyString) {
    destrealm_ = new ::std::string;
  }
  return destrealm_;
}
inline ::std::string* pbIwfDccaSessionCtxt::release_destrealm() {
  clear_has_destrealm();
  if (destrealm_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = destrealm_;
    destrealm_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 IwfCCFHAction = 4;
inline bool pbIwfDccaSessionCtxt::has_iwfccfhaction() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void pbIwfDccaSessionCtxt::set_has_iwfccfhaction() {
  _has_bits_[0] |= 0x00000008u;
}
inline void pbIwfDccaSessionCtxt::clear_has_iwfccfhaction() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void pbIwfDccaSessionCtxt::clear_iwfccfhaction() {
  iwfccfhaction_ = 0u;
  clear_has_iwfccfhaction();
}
inline ::google::protobuf::uint32 pbIwfDccaSessionCtxt::iwfccfhaction() const {
  return iwfccfhaction_;
}
inline void pbIwfDccaSessionCtxt::set_iwfccfhaction(::google::protobuf::uint32 value) {
  set_has_iwfccfhaction();
  iwfccfhaction_ = value;
}

// optional bool isFailoverSupported = 5 [default = true];
inline bool pbIwfDccaSessionCtxt::has_isfailoversupported() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void pbIwfDccaSessionCtxt::set_has_isfailoversupported() {
  _has_bits_[0] |= 0x00000010u;
}
inline void pbIwfDccaSessionCtxt::clear_has_isfailoversupported() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void pbIwfDccaSessionCtxt::clear_isfailoversupported() {
  isfailoversupported_ = true;
  clear_has_isfailoversupported();
}
inline bool pbIwfDccaSessionCtxt::isfailoversupported() const {
  return isfailoversupported_;
}
inline void pbIwfDccaSessionCtxt::set_isfailoversupported(bool value) {
  set_has_isfailoversupported();
  isfailoversupported_ = value;
}

// optional bool isDone = 6 [default = false];
inline bool pbIwfDccaSessionCtxt::has_isdone() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void pbIwfDccaSessionCtxt::set_has_isdone() {
  _has_bits_[0] |= 0x00000020u;
}
inline void pbIwfDccaSessionCtxt::clear_has_isdone() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void pbIwfDccaSessionCtxt::clear_isdone() {
  isdone_ = false;
  clear_has_isdone();
}
inline bool pbIwfDccaSessionCtxt::isdone() const {
  return isdone_;
}
inline void pbIwfDccaSessionCtxt::set_isdone(bool value) {
  set_has_isdone();
  isdone_ = value;
}

// optional uint32 retryCount = 7 [default = 0];
inline bool pbIwfDccaSessionCtxt::has_retrycount() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void pbIwfDccaSessionCtxt::set_has_retrycount() {
  _has_bits_[0] |= 0x00000040u;
}
inline void pbIwfDccaSessionCtxt::clear_has_retrycount() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void pbIwfDccaSessionCtxt::clear_retrycount() {
  retrycount_ = 0u;
  clear_has_retrycount();
}
inline ::google::protobuf::uint32 pbIwfDccaSessionCtxt::retrycount() const {
  return retrycount_;
}
inline void pbIwfDccaSessionCtxt::set_retrycount(::google::protobuf::uint32 value) {
  set_has_retrycount();
  retrycount_ = value;
}

// -------------------------------------------------------------------

// pbConnectArgData

// optional bool hasServiceControl = 1 [default = false];
inline bool pbConnectArgData::has_hasservicecontrol() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pbConnectArgData::set_has_hasservicecontrol() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pbConnectArgData::clear_has_hasservicecontrol() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pbConnectArgData::clear_hasservicecontrol() {
  hasservicecontrol_ = false;
  clear_has_hasservicecontrol();
}
inline bool pbConnectArgData::hasservicecontrol() const {
  return hasservicecontrol_;
}
inline void pbConnectArgData::set_hasservicecontrol(bool value) {
  set_has_hasservicecontrol();
  hasservicecontrol_ = value;
}

// optional bool hasCapInfo = 2 [default = false];
inline bool pbConnectArgData::has_hascapinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pbConnectArgData::set_has_hascapinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pbConnectArgData::clear_has_hascapinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pbConnectArgData::clear_hascapinfo() {
  hascapinfo_ = false;
  clear_has_hascapinfo();
}
inline bool pbConnectArgData::hascapinfo() const {
  return hascapinfo_;
}
inline void pbConnectArgData::set_hascapinfo(bool value) {
  set_has_hascapinfo();
  hascapinfo_ = value;
}

// optional bool hasCapConnectInfo = 3 [default = false];
inline bool pbConnectArgData::has_hascapconnectinfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void pbConnectArgData::set_has_hascapconnectinfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void pbConnectArgData::clear_has_hascapconnectinfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void pbConnectArgData::clear_hascapconnectinfo() {
  hascapconnectinfo_ = false;
  clear_has_hascapconnectinfo();
}
inline bool pbConnectArgData::hascapconnectinfo() const {
  return hascapconnectinfo_;
}
inline void pbConnectArgData::set_hascapconnectinfo(bool value) {
  set_has_hascapconnectinfo();
  hascapconnectinfo_ = value;
}

// optional string capAnncAccessNo = 4;
inline bool pbConnectArgData::has_capanncaccessno() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void pbConnectArgData::set_has_capanncaccessno() {
  _has_bits_[0] |= 0x00000008u;
}
inline void pbConnectArgData::clear_has_capanncaccessno() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void pbConnectArgData::clear_capanncaccessno() {
  if (capanncaccessno_ != &::google::protobuf::internal::kEmptyString) {
    capanncaccessno_->clear();
  }
  clear_has_capanncaccessno();
}
inline const ::std::string& pbConnectArgData::capanncaccessno() const {
  return *capanncaccessno_;
}
inline void pbConnectArgData::set_capanncaccessno(const ::std::string& value) {
  set_has_capanncaccessno();
  if (capanncaccessno_ == &::google::protobuf::internal::kEmptyString) {
    capanncaccessno_ = new ::std::string;
  }
  capanncaccessno_->assign(value);
}
inline void pbConnectArgData::set_capanncaccessno(const char* value) {
  set_has_capanncaccessno();
  if (capanncaccessno_ == &::google::protobuf::internal::kEmptyString) {
    capanncaccessno_ = new ::std::string;
  }
  capanncaccessno_->assign(value);
}
inline void pbConnectArgData::set_capanncaccessno(const char* value, size_t size) {
  set_has_capanncaccessno();
  if (capanncaccessno_ == &::google::protobuf::internal::kEmptyString) {
    capanncaccessno_ = new ::std::string;
  }
  capanncaccessno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbConnectArgData::mutable_capanncaccessno() {
  set_has_capanncaccessno();
  if (capanncaccessno_ == &::google::protobuf::internal::kEmptyString) {
    capanncaccessno_ = new ::std::string;
  }
  return capanncaccessno_;
}
inline ::std::string* pbConnectArgData::release_capanncaccessno() {
  clear_has_capanncaccessno();
  if (capanncaccessno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = capanncaccessno_;
    capanncaccessno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 capConnAnncNoNatrue = 5;
inline bool pbConnectArgData::has_capconnanncnonatrue() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void pbConnectArgData::set_has_capconnanncnonatrue() {
  _has_bits_[0] |= 0x00000010u;
}
inline void pbConnectArgData::clear_has_capconnanncnonatrue() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void pbConnectArgData::clear_capconnanncnonatrue() {
  capconnanncnonatrue_ = 0u;
  clear_has_capconnanncnonatrue();
}
inline ::google::protobuf::uint32 pbConnectArgData::capconnanncnonatrue() const {
  return capconnanncnonatrue_;
}
inline void pbConnectArgData::set_capconnanncnonatrue(::google::protobuf::uint32 value) {
  set_has_capconnanncnonatrue();
  capconnanncnonatrue_ = value;
}

// optional uint32 capConnAnncNoInn = 6;
inline bool pbConnectArgData::has_capconnanncnoinn() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void pbConnectArgData::set_has_capconnanncnoinn() {
  _has_bits_[0] |= 0x00000020u;
}
inline void pbConnectArgData::clear_has_capconnanncnoinn() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void pbConnectArgData::clear_capconnanncnoinn() {
  capconnanncnoinn_ = 0u;
  clear_has_capconnanncnoinn();
}
inline ::google::protobuf::uint32 pbConnectArgData::capconnanncnoinn() const {
  return capconnanncnoinn_;
}
inline void pbConnectArgData::set_capconnanncnoinn(::google::protobuf::uint32 value) {
  set_has_capconnanncnoinn();
  capconnanncnoinn_ = value;
}

// optional uint32 capConnAnncNoNPI = 7;
inline bool pbConnectArgData::has_capconnanncnonpi() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void pbConnectArgData::set_has_capconnanncnonpi() {
  _has_bits_[0] |= 0x00000040u;
}
inline void pbConnectArgData::clear_has_capconnanncnonpi() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void pbConnectArgData::clear_capconnanncnonpi() {
  capconnanncnonpi_ = 0u;
  clear_has_capconnanncnonpi();
}
inline ::google::protobuf::uint32 pbConnectArgData::capconnanncnonpi() const {
  return capconnanncnonpi_;
}
inline void pbConnectArgData::set_capconnanncnonpi(::google::protobuf::uint32 value) {
  set_has_capconnanncnonpi();
  capconnanncnonpi_ = value;
}

// optional string capConnDestNo = 8;
inline bool pbConnectArgData::has_capconndestno() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void pbConnectArgData::set_has_capconndestno() {
  _has_bits_[0] |= 0x00000080u;
}
inline void pbConnectArgData::clear_has_capconndestno() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void pbConnectArgData::clear_capconndestno() {
  if (capconndestno_ != &::google::protobuf::internal::kEmptyString) {
    capconndestno_->clear();
  }
  clear_has_capconndestno();
}
inline const ::std::string& pbConnectArgData::capconndestno() const {
  return *capconndestno_;
}
inline void pbConnectArgData::set_capconndestno(const ::std::string& value) {
  set_has_capconndestno();
  if (capconndestno_ == &::google::protobuf::internal::kEmptyString) {
    capconndestno_ = new ::std::string;
  }
  capconndestno_->assign(value);
}
inline void pbConnectArgData::set_capconndestno(const char* value) {
  set_has_capconndestno();
  if (capconndestno_ == &::google::protobuf::internal::kEmptyString) {
    capconndestno_ = new ::std::string;
  }
  capconndestno_->assign(value);
}
inline void pbConnectArgData::set_capconndestno(const char* value, size_t size) {
  set_has_capconndestno();
  if (capconndestno_ == &::google::protobuf::internal::kEmptyString) {
    capconndestno_ = new ::std::string;
  }
  capconndestno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbConnectArgData::mutable_capconndestno() {
  set_has_capconndestno();
  if (capconndestno_ == &::google::protobuf::internal::kEmptyString) {
    capconndestno_ = new ::std::string;
  }
  return capconndestno_;
}
inline ::std::string* pbConnectArgData::release_capconndestno() {
  clear_has_capconndestno();
  if (capconndestno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = capconndestno_;
    capconndestno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 capConnDestNoNature = 9;
inline bool pbConnectArgData::has_capconndestnonature() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void pbConnectArgData::set_has_capconndestnonature() {
  _has_bits_[0] |= 0x00000100u;
}
inline void pbConnectArgData::clear_has_capconndestnonature() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void pbConnectArgData::clear_capconndestnonature() {
  capconndestnonature_ = 0u;
  clear_has_capconndestnonature();
}
inline ::google::protobuf::uint32 pbConnectArgData::capconndestnonature() const {
  return capconndestnonature_;
}
inline void pbConnectArgData::set_capconndestnonature(::google::protobuf::uint32 value) {
  set_has_capconndestnonature();
  capconndestnonature_ = value;
}

// optional uint32 capConnDestNoNPI = 10;
inline bool pbConnectArgData::has_capconndestnonpi() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void pbConnectArgData::set_has_capconndestnonpi() {
  _has_bits_[0] |= 0x00000200u;
}
inline void pbConnectArgData::clear_has_capconndestnonpi() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void pbConnectArgData::clear_capconndestnonpi() {
  capconndestnonpi_ = 0u;
  clear_has_capconndestnonpi();
}
inline ::google::protobuf::uint32 pbConnectArgData::capconndestnonpi() const {
  return capconndestnonpi_;
}
inline void pbConnectArgData::set_capconndestnonpi(::google::protobuf::uint32 value) {
  set_has_capconndestnonpi();
  capconndestnonpi_ = value;
}

// optional uint32 capConnDestINN = 11;
inline bool pbConnectArgData::has_capconndestinn() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void pbConnectArgData::set_has_capconndestinn() {
  _has_bits_[0] |= 0x00000400u;
}
inline void pbConnectArgData::clear_has_capconndestinn() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void pbConnectArgData::clear_capconndestinn() {
  capconndestinn_ = 0u;
  clear_has_capconndestinn();
}
inline ::google::protobuf::uint32 pbConnectArgData::capconndestinn() const {
  return capconndestinn_;
}
inline void pbConnectArgData::set_capconndestinn(::google::protobuf::uint32 value) {
  set_has_capconndestinn();
  capconndestinn_ = value;
}

// optional string genericNo = 12;
inline bool pbConnectArgData::has_genericno() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void pbConnectArgData::set_has_genericno() {
  _has_bits_[0] |= 0x00000800u;
}
inline void pbConnectArgData::clear_has_genericno() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void pbConnectArgData::clear_genericno() {
  if (genericno_ != &::google::protobuf::internal::kEmptyString) {
    genericno_->clear();
  }
  clear_has_genericno();
}
inline const ::std::string& pbConnectArgData::genericno() const {
  return *genericno_;
}
inline void pbConnectArgData::set_genericno(const ::std::string& value) {
  set_has_genericno();
  if (genericno_ == &::google::protobuf::internal::kEmptyString) {
    genericno_ = new ::std::string;
  }
  genericno_->assign(value);
}
inline void pbConnectArgData::set_genericno(const char* value) {
  set_has_genericno();
  if (genericno_ == &::google::protobuf::internal::kEmptyString) {
    genericno_ = new ::std::string;
  }
  genericno_->assign(value);
}
inline void pbConnectArgData::set_genericno(const char* value, size_t size) {
  set_has_genericno();
  if (genericno_ == &::google::protobuf::internal::kEmptyString) {
    genericno_ = new ::std::string;
  }
  genericno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbConnectArgData::mutable_genericno() {
  set_has_genericno();
  if (genericno_ == &::google::protobuf::internal::kEmptyString) {
    genericno_ = new ::std::string;
  }
  return genericno_;
}
inline ::std::string* pbConnectArgData::release_genericno() {
  clear_has_genericno();
  if (genericno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = genericno_;
    genericno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 genericNoNature = 13;
inline bool pbConnectArgData::has_genericnonature() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void pbConnectArgData::set_has_genericnonature() {
  _has_bits_[0] |= 0x00001000u;
}
inline void pbConnectArgData::clear_has_genericnonature() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void pbConnectArgData::clear_genericnonature() {
  genericnonature_ = 0u;
  clear_has_genericnonature();
}
inline ::google::protobuf::uint32 pbConnectArgData::genericnonature() const {
  return genericnonature_;
}
inline void pbConnectArgData::set_genericnonature(::google::protobuf::uint32 value) {
  set_has_genericnonature();
  genericnonature_ = value;
}

// optional uint32 genericNoNPI = 14;
inline bool pbConnectArgData::has_genericnonpi() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void pbConnectArgData::set_has_genericnonpi() {
  _has_bits_[0] |= 0x00002000u;
}
inline void pbConnectArgData::clear_has_genericnonpi() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void pbConnectArgData::clear_genericnonpi() {
  genericnonpi_ = 0u;
  clear_has_genericnonpi();
}
inline ::google::protobuf::uint32 pbConnectArgData::genericnonpi() const {
  return genericnonpi_;
}
inline void pbConnectArgData::set_genericnonpi(::google::protobuf::uint32 value) {
  set_has_genericnonpi();
  genericnonpi_ = value;
}

// optional uint32 genericNoNII = 15;
inline bool pbConnectArgData::has_genericnonii() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void pbConnectArgData::set_has_genericnonii() {
  _has_bits_[0] |= 0x00004000u;
}
inline void pbConnectArgData::clear_has_genericnonii() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void pbConnectArgData::clear_genericnonii() {
  genericnonii_ = 0u;
  clear_has_genericnonii();
}
inline ::google::protobuf::uint32 pbConnectArgData::genericnonii() const {
  return genericnonii_;
}
inline void pbConnectArgData::set_genericnonii(::google::protobuf::uint32 value) {
  set_has_genericnonii();
  genericnonii_ = value;
}

// optional uint32 genericNoARI = 16;
inline bool pbConnectArgData::has_genericnoari() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void pbConnectArgData::set_has_genericnoari() {
  _has_bits_[0] |= 0x00008000u;
}
inline void pbConnectArgData::clear_has_genericnoari() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void pbConnectArgData::clear_genericnoari() {
  genericnoari_ = 0u;
  clear_has_genericnoari();
}
inline ::google::protobuf::uint32 pbConnectArgData::genericnoari() const {
  return genericnoari_;
}
inline void pbConnectArgData::set_genericnoari(::google::protobuf::uint32 value) {
  set_has_genericnoari();
  genericnoari_ = value;
}

// optional uint32 genericNoSCI = 17;
inline bool pbConnectArgData::has_genericnosci() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void pbConnectArgData::set_has_genericnosci() {
  _has_bits_[0] |= 0x00010000u;
}
inline void pbConnectArgData::clear_has_genericnosci() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void pbConnectArgData::clear_genericnosci() {
  genericnosci_ = 0u;
  clear_has_genericnosci();
}
inline ::google::protobuf::uint32 pbConnectArgData::genericnosci() const {
  return genericnosci_;
}
inline void pbConnectArgData::set_genericnosci(::google::protobuf::uint32 value) {
  set_has_genericnosci();
  genericnosci_ = value;
}

// optional uint32 genericNoNQI = 18;
inline bool pbConnectArgData::has_genericnonqi() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void pbConnectArgData::set_has_genericnonqi() {
  _has_bits_[0] |= 0x00020000u;
}
inline void pbConnectArgData::clear_has_genericnonqi() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void pbConnectArgData::clear_genericnonqi() {
  genericnonqi_ = 0u;
  clear_has_genericnonqi();
}
inline ::google::protobuf::uint32 pbConnectArgData::genericnonqi() const {
  return genericnonqi_;
}
inline void pbConnectArgData::set_genericnonqi(::google::protobuf::uint32 value) {
  set_has_genericnonqi();
  genericnonqi_ = value;
}

// optional string redirectingNum = 19;
inline bool pbConnectArgData::has_redirectingnum() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void pbConnectArgData::set_has_redirectingnum() {
  _has_bits_[0] |= 0x00040000u;
}
inline void pbConnectArgData::clear_has_redirectingnum() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void pbConnectArgData::clear_redirectingnum() {
  if (redirectingnum_ != &::google::protobuf::internal::kEmptyString) {
    redirectingnum_->clear();
  }
  clear_has_redirectingnum();
}
inline const ::std::string& pbConnectArgData::redirectingnum() const {
  return *redirectingnum_;
}
inline void pbConnectArgData::set_redirectingnum(const ::std::string& value) {
  set_has_redirectingnum();
  if (redirectingnum_ == &::google::protobuf::internal::kEmptyString) {
    redirectingnum_ = new ::std::string;
  }
  redirectingnum_->assign(value);
}
inline void pbConnectArgData::set_redirectingnum(const char* value) {
  set_has_redirectingnum();
  if (redirectingnum_ == &::google::protobuf::internal::kEmptyString) {
    redirectingnum_ = new ::std::string;
  }
  redirectingnum_->assign(value);
}
inline void pbConnectArgData::set_redirectingnum(const char* value, size_t size) {
  set_has_redirectingnum();
  if (redirectingnum_ == &::google::protobuf::internal::kEmptyString) {
    redirectingnum_ = new ::std::string;
  }
  redirectingnum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbConnectArgData::mutable_redirectingnum() {
  set_has_redirectingnum();
  if (redirectingnum_ == &::google::protobuf::internal::kEmptyString) {
    redirectingnum_ = new ::std::string;
  }
  return redirectingnum_;
}
inline ::std::string* pbConnectArgData::release_redirectingnum() {
  clear_has_redirectingnum();
  if (redirectingnum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = redirectingnum_;
    redirectingnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 redirectNoNOA = 20;
inline bool pbConnectArgData::has_redirectnonoa() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void pbConnectArgData::set_has_redirectnonoa() {
  _has_bits_[0] |= 0x00080000u;
}
inline void pbConnectArgData::clear_has_redirectnonoa() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void pbConnectArgData::clear_redirectnonoa() {
  redirectnonoa_ = 0u;
  clear_has_redirectnonoa();
}
inline ::google::protobuf::uint32 pbConnectArgData::redirectnonoa() const {
  return redirectnonoa_;
}
inline void pbConnectArgData::set_redirectnonoa(::google::protobuf::uint32 value) {
  set_has_redirectnonoa();
  redirectnonoa_ = value;
}

// optional uint32 redirectNoNPI = 21;
inline bool pbConnectArgData::has_redirectnonpi() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void pbConnectArgData::set_has_redirectnonpi() {
  _has_bits_[0] |= 0x00100000u;
}
inline void pbConnectArgData::clear_has_redirectnonpi() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void pbConnectArgData::clear_redirectnonpi() {
  redirectnonpi_ = 0u;
  clear_has_redirectnonpi();
}
inline ::google::protobuf::uint32 pbConnectArgData::redirectnonpi() const {
  return redirectnonpi_;
}
inline void pbConnectArgData::set_redirectnonpi(::google::protobuf::uint32 value) {
  set_has_redirectnonpi();
  redirectnonpi_ = value;
}

// optional uint32 redirectNoARI = 22;
inline bool pbConnectArgData::has_redirectnoari() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void pbConnectArgData::set_has_redirectnoari() {
  _has_bits_[0] |= 0x00200000u;
}
inline void pbConnectArgData::clear_has_redirectnoari() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void pbConnectArgData::clear_redirectnoari() {
  redirectnoari_ = 0u;
  clear_has_redirectnoari();
}
inline ::google::protobuf::uint32 pbConnectArgData::redirectnoari() const {
  return redirectnoari_;
}
inline void pbConnectArgData::set_redirectnoari(::google::protobuf::uint32 value) {
  set_has_redirectnoari();
  redirectnoari_ = value;
}

// optional uint32 redirectInd = 23;
inline bool pbConnectArgData::has_redirectind() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void pbConnectArgData::set_has_redirectind() {
  _has_bits_[0] |= 0x00400000u;
}
inline void pbConnectArgData::clear_has_redirectind() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void pbConnectArgData::clear_redirectind() {
  redirectind_ = 0u;
  clear_has_redirectind();
}
inline ::google::protobuf::uint32 pbConnectArgData::redirectind() const {
  return redirectind_;
}
inline void pbConnectArgData::set_redirectind(::google::protobuf::uint32 value) {
  set_has_redirectind();
  redirectind_ = value;
}

// optional uint32 origRedirectReason = 24;
inline bool pbConnectArgData::has_origredirectreason() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void pbConnectArgData::set_has_origredirectreason() {
  _has_bits_[0] |= 0x00800000u;
}
inline void pbConnectArgData::clear_has_origredirectreason() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void pbConnectArgData::clear_origredirectreason() {
  origredirectreason_ = 0u;
  clear_has_origredirectreason();
}
inline ::google::protobuf::uint32 pbConnectArgData::origredirectreason() const {
  return origredirectreason_;
}
inline void pbConnectArgData::set_origredirectreason(::google::protobuf::uint32 value) {
  set_has_origredirectreason();
  origredirectreason_ = value;
}

// optional uint32 redirectionCount = 25;
inline bool pbConnectArgData::has_redirectioncount() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void pbConnectArgData::set_has_redirectioncount() {
  _has_bits_[0] |= 0x01000000u;
}
inline void pbConnectArgData::clear_has_redirectioncount() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void pbConnectArgData::clear_redirectioncount() {
  redirectioncount_ = 0u;
  clear_has_redirectioncount();
}
inline ::google::protobuf::uint32 pbConnectArgData::redirectioncount() const {
  return redirectioncount_;
}
inline void pbConnectArgData::set_redirectioncount(::google::protobuf::uint32 value) {
  set_has_redirectioncount();
  redirectioncount_ = value;
}

// optional uint32 redirectReason = 26;
inline bool pbConnectArgData::has_redirectreason() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void pbConnectArgData::set_has_redirectreason() {
  _has_bits_[0] |= 0x02000000u;
}
inline void pbConnectArgData::clear_has_redirectreason() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void pbConnectArgData::clear_redirectreason() {
  redirectreason_ = 0u;
  clear_has_redirectreason();
}
inline ::google::protobuf::uint32 pbConnectArgData::redirectreason() const {
  return redirectreason_;
}
inline void pbConnectArgData::set_redirectreason(::google::protobuf::uint32 value) {
  set_has_redirectreason();
  redirectreason_ = value;
}

// optional string origCalledPartyId = 27;
inline bool pbConnectArgData::has_origcalledpartyid() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void pbConnectArgData::set_has_origcalledpartyid() {
  _has_bits_[0] |= 0x04000000u;
}
inline void pbConnectArgData::clear_has_origcalledpartyid() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void pbConnectArgData::clear_origcalledpartyid() {
  if (origcalledpartyid_ != &::google::protobuf::internal::kEmptyString) {
    origcalledpartyid_->clear();
  }
  clear_has_origcalledpartyid();
}
inline const ::std::string& pbConnectArgData::origcalledpartyid() const {
  return *origcalledpartyid_;
}
inline void pbConnectArgData::set_origcalledpartyid(const ::std::string& value) {
  set_has_origcalledpartyid();
  if (origcalledpartyid_ == &::google::protobuf::internal::kEmptyString) {
    origcalledpartyid_ = new ::std::string;
  }
  origcalledpartyid_->assign(value);
}
inline void pbConnectArgData::set_origcalledpartyid(const char* value) {
  set_has_origcalledpartyid();
  if (origcalledpartyid_ == &::google::protobuf::internal::kEmptyString) {
    origcalledpartyid_ = new ::std::string;
  }
  origcalledpartyid_->assign(value);
}
inline void pbConnectArgData::set_origcalledpartyid(const char* value, size_t size) {
  set_has_origcalledpartyid();
  if (origcalledpartyid_ == &::google::protobuf::internal::kEmptyString) {
    origcalledpartyid_ = new ::std::string;
  }
  origcalledpartyid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbConnectArgData::mutable_origcalledpartyid() {
  set_has_origcalledpartyid();
  if (origcalledpartyid_ == &::google::protobuf::internal::kEmptyString) {
    origcalledpartyid_ = new ::std::string;
  }
  return origcalledpartyid_;
}
inline ::std::string* pbConnectArgData::release_origcalledpartyid() {
  clear_has_origcalledpartyid();
  if (origcalledpartyid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = origcalledpartyid_;
    origcalledpartyid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 originalCalledNoNPI = 28;
inline bool pbConnectArgData::has_originalcallednonpi() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void pbConnectArgData::set_has_originalcallednonpi() {
  _has_bits_[0] |= 0x08000000u;
}
inline void pbConnectArgData::clear_has_originalcallednonpi() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void pbConnectArgData::clear_originalcallednonpi() {
  originalcallednonpi_ = 0u;
  clear_has_originalcallednonpi();
}
inline ::google::protobuf::uint32 pbConnectArgData::originalcallednonpi() const {
  return originalcallednonpi_;
}
inline void pbConnectArgData::set_originalcallednonpi(::google::protobuf::uint32 value) {
  set_has_originalcallednonpi();
  originalcallednonpi_ = value;
}

// optional uint32 originalCalledNoNOA = 29;
inline bool pbConnectArgData::has_originalcallednonoa() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void pbConnectArgData::set_has_originalcallednonoa() {
  _has_bits_[0] |= 0x10000000u;
}
inline void pbConnectArgData::clear_has_originalcallednonoa() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void pbConnectArgData::clear_originalcallednonoa() {
  originalcallednonoa_ = 0u;
  clear_has_originalcallednonoa();
}
inline ::google::protobuf::uint32 pbConnectArgData::originalcallednonoa() const {
  return originalcallednonoa_;
}
inline void pbConnectArgData::set_originalcallednonoa(::google::protobuf::uint32 value) {
  set_has_originalcallednonoa();
  originalcallednonoa_ = value;
}

// optional uint32 originalCalledNoARI = 30;
inline bool pbConnectArgData::has_originalcallednoari() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void pbConnectArgData::set_has_originalcallednoari() {
  _has_bits_[0] |= 0x20000000u;
}
inline void pbConnectArgData::clear_has_originalcallednoari() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void pbConnectArgData::clear_originalcallednoari() {
  originalcallednoari_ = 0u;
  clear_has_originalcallednoari();
}
inline ::google::protobuf::uint32 pbConnectArgData::originalcallednoari() const {
  return originalcallednoari_;
}
inline void pbConnectArgData::set_originalcallednoari(::google::protobuf::uint32 value) {
  set_has_originalcallednoari();
  originalcallednoari_ = value;
}

// optional uint32 capConnOCSIApplicable = 31;
inline bool pbConnectArgData::has_capconnocsiapplicable() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void pbConnectArgData::set_has_capconnocsiapplicable() {
  _has_bits_[0] |= 0x40000000u;
}
inline void pbConnectArgData::clear_has_capconnocsiapplicable() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void pbConnectArgData::clear_capconnocsiapplicable() {
  capconnocsiapplicable_ = 0u;
  clear_has_capconnocsiapplicable();
}
inline ::google::protobuf::uint32 pbConnectArgData::capconnocsiapplicable() const {
  return capconnocsiapplicable_;
}
inline void pbConnectArgData::set_capconnocsiapplicable(::google::protobuf::uint32 value) {
  set_has_capconnocsiapplicable();
  capconnocsiapplicable_ = value;
}

// optional uint32 capConnSuppressionOfAnnc = 32;
inline bool pbConnectArgData::has_capconnsuppressionofannc() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void pbConnectArgData::set_has_capconnsuppressionofannc() {
  _has_bits_[0] |= 0x80000000u;
}
inline void pbConnectArgData::clear_has_capconnsuppressionofannc() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void pbConnectArgData::clear_capconnsuppressionofannc() {
  capconnsuppressionofannc_ = 0u;
  clear_has_capconnsuppressionofannc();
}
inline ::google::protobuf::uint32 pbConnectArgData::capconnsuppressionofannc() const {
  return capconnsuppressionofannc_;
}
inline void pbConnectArgData::set_capconnsuppressionofannc(::google::protobuf::uint32 value) {
  set_has_capconnsuppressionofannc();
  capconnsuppressionofannc_ = value;
}

// optional uint32 capConnCallingCategory = 33;
inline bool pbConnectArgData::has_capconncallingcategory() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void pbConnectArgData::set_has_capconncallingcategory() {
  _has_bits_[1] |= 0x00000001u;
}
inline void pbConnectArgData::clear_has_capconncallingcategory() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void pbConnectArgData::clear_capconncallingcategory() {
  capconncallingcategory_ = 0u;
  clear_has_capconncallingcategory();
}
inline ::google::protobuf::uint32 pbConnectArgData::capconncallingcategory() const {
  return capconncallingcategory_;
}
inline void pbConnectArgData::set_capconncallingcategory(::google::protobuf::uint32 value) {
  set_has_capconncallingcategory();
  capconncallingcategory_ = value;
}

// -------------------------------------------------------------------

// pbACHData

// optional uint32 FinalUnitIndication = 1;
inline bool pbACHData::has_finalunitindication() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pbACHData::set_has_finalunitindication() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pbACHData::clear_has_finalunitindication() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pbACHData::clear_finalunitindication() {
  finalunitindication_ = 0u;
  clear_has_finalunitindication();
}
inline ::google::protobuf::uint32 pbACHData::finalunitindication() const {
  return finalunitindication_;
}
inline void pbACHData::set_finalunitindication(::google::protobuf::uint32 value) {
  set_has_finalunitindication();
  finalunitindication_ = value;
}

// optional uint32 BeepTone = 2;
inline bool pbACHData::has_beeptone() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pbACHData::set_has_beeptone() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pbACHData::clear_has_beeptone() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pbACHData::clear_beeptone() {
  beeptone_ = 0u;
  clear_has_beeptone();
}
inline ::google::protobuf::uint32 pbACHData::beeptone() const {
  return beeptone_;
}
inline void pbACHData::set_beeptone(::google::protobuf::uint32 value) {
  set_has_beeptone();
  beeptone_ = value;
}

// -------------------------------------------------------------------

// pbCapRoTsl

// optional bool bcsmEventFlag = 1;
inline bool pbCapRoTsl::has_bcsmeventflag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pbCapRoTsl::set_has_bcsmeventflag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pbCapRoTsl::clear_has_bcsmeventflag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pbCapRoTsl::clear_bcsmeventflag() {
  bcsmeventflag_ = false;
  clear_has_bcsmeventflag();
}
inline bool pbCapRoTsl::bcsmeventflag() const {
  return bcsmeventflag_;
}
inline void pbCapRoTsl::set_bcsmeventflag(bool value) {
  set_has_bcsmeventflag();
  bcsmeventflag_ = value;
}

// optional string capCallingPartyNumber = 2;
inline bool pbCapRoTsl::has_capcallingpartynumber() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pbCapRoTsl::set_has_capcallingpartynumber() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pbCapRoTsl::clear_has_capcallingpartynumber() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pbCapRoTsl::clear_capcallingpartynumber() {
  if (capcallingpartynumber_ != &::google::protobuf::internal::kEmptyString) {
    capcallingpartynumber_->clear();
  }
  clear_has_capcallingpartynumber();
}
inline const ::std::string& pbCapRoTsl::capcallingpartynumber() const {
  return *capcallingpartynumber_;
}
inline void pbCapRoTsl::set_capcallingpartynumber(const ::std::string& value) {
  set_has_capcallingpartynumber();
  if (capcallingpartynumber_ == &::google::protobuf::internal::kEmptyString) {
    capcallingpartynumber_ = new ::std::string;
  }
  capcallingpartynumber_->assign(value);
}
inline void pbCapRoTsl::set_capcallingpartynumber(const char* value) {
  set_has_capcallingpartynumber();
  if (capcallingpartynumber_ == &::google::protobuf::internal::kEmptyString) {
    capcallingpartynumber_ = new ::std::string;
  }
  capcallingpartynumber_->assign(value);
}
inline void pbCapRoTsl::set_capcallingpartynumber(const char* value, size_t size) {
  set_has_capcallingpartynumber();
  if (capcallingpartynumber_ == &::google::protobuf::internal::kEmptyString) {
    capcallingpartynumber_ = new ::std::string;
  }
  capcallingpartynumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbCapRoTsl::mutable_capcallingpartynumber() {
  set_has_capcallingpartynumber();
  if (capcallingpartynumber_ == &::google::protobuf::internal::kEmptyString) {
    capcallingpartynumber_ = new ::std::string;
  }
  return capcallingpartynumber_;
}
inline ::std::string* pbCapRoTsl::release_capcallingpartynumber() {
  clear_has_capcallingpartynumber();
  if (capcallingpartynumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = capcallingpartynumber_;
    capcallingpartynumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 serviceIdentifier = 3;
inline bool pbCapRoTsl::has_serviceidentifier() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void pbCapRoTsl::set_has_serviceidentifier() {
  _has_bits_[0] |= 0x00000004u;
}
inline void pbCapRoTsl::clear_has_serviceidentifier() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void pbCapRoTsl::clear_serviceidentifier() {
  serviceidentifier_ = 0u;
  clear_has_serviceidentifier();
}
inline ::google::protobuf::uint32 pbCapRoTsl::serviceidentifier() const {
  return serviceidentifier_;
}
inline void pbCapRoTsl::set_serviceidentifier(::google::protobuf::uint32 value) {
  set_has_serviceidentifier();
  serviceidentifier_ = value;
}

// optional bool receivedBasicService = 4;
inline bool pbCapRoTsl::has_receivedbasicservice() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void pbCapRoTsl::set_has_receivedbasicservice() {
  _has_bits_[0] |= 0x00000008u;
}
inline void pbCapRoTsl::clear_has_receivedbasicservice() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void pbCapRoTsl::clear_receivedbasicservice() {
  receivedbasicservice_ = false;
  clear_has_receivedbasicservice();
}
inline bool pbCapRoTsl::receivedbasicservice() const {
  return receivedbasicservice_;
}
inline void pbCapRoTsl::set_receivedbasicservice(bool value) {
  set_has_receivedbasicservice();
  receivedbasicservice_ = value;
}

// optional string roUserSessionId = 5;
inline bool pbCapRoTsl::has_rousersessionid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void pbCapRoTsl::set_has_rousersessionid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void pbCapRoTsl::clear_has_rousersessionid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void pbCapRoTsl::clear_rousersessionid() {
  if (rousersessionid_ != &::google::protobuf::internal::kEmptyString) {
    rousersessionid_->clear();
  }
  clear_has_rousersessionid();
}
inline const ::std::string& pbCapRoTsl::rousersessionid() const {
  return *rousersessionid_;
}
inline void pbCapRoTsl::set_rousersessionid(const ::std::string& value) {
  set_has_rousersessionid();
  if (rousersessionid_ == &::google::protobuf::internal::kEmptyString) {
    rousersessionid_ = new ::std::string;
  }
  rousersessionid_->assign(value);
}
inline void pbCapRoTsl::set_rousersessionid(const char* value) {
  set_has_rousersessionid();
  if (rousersessionid_ == &::google::protobuf::internal::kEmptyString) {
    rousersessionid_ = new ::std::string;
  }
  rousersessionid_->assign(value);
}
inline void pbCapRoTsl::set_rousersessionid(const char* value, size_t size) {
  set_has_rousersessionid();
  if (rousersessionid_ == &::google::protobuf::internal::kEmptyString) {
    rousersessionid_ = new ::std::string;
  }
  rousersessionid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbCapRoTsl::mutable_rousersessionid() {
  set_has_rousersessionid();
  if (rousersessionid_ == &::google::protobuf::internal::kEmptyString) {
    rousersessionid_ = new ::std::string;
  }
  return rousersessionid_;
}
inline ::std::string* pbCapRoTsl::release_rousersessionid() {
  clear_has_rousersessionid();
  if (rousersessionid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rousersessionid_;
    rousersessionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string imsiChargingIdentifier = 6;
inline bool pbCapRoTsl::has_imsichargingidentifier() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void pbCapRoTsl::set_has_imsichargingidentifier() {
  _has_bits_[0] |= 0x00000020u;
}
inline void pbCapRoTsl::clear_has_imsichargingidentifier() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void pbCapRoTsl::clear_imsichargingidentifier() {
  if (imsichargingidentifier_ != &::google::protobuf::internal::kEmptyString) {
    imsichargingidentifier_->clear();
  }
  clear_has_imsichargingidentifier();
}
inline const ::std::string& pbCapRoTsl::imsichargingidentifier() const {
  return *imsichargingidentifier_;
}
inline void pbCapRoTsl::set_imsichargingidentifier(const ::std::string& value) {
  set_has_imsichargingidentifier();
  if (imsichargingidentifier_ == &::google::protobuf::internal::kEmptyString) {
    imsichargingidentifier_ = new ::std::string;
  }
  imsichargingidentifier_->assign(value);
}
inline void pbCapRoTsl::set_imsichargingidentifier(const char* value) {
  set_has_imsichargingidentifier();
  if (imsichargingidentifier_ == &::google::protobuf::internal::kEmptyString) {
    imsichargingidentifier_ = new ::std::string;
  }
  imsichargingidentifier_->assign(value);
}
inline void pbCapRoTsl::set_imsichargingidentifier(const char* value, size_t size) {
  set_has_imsichargingidentifier();
  if (imsichargingidentifier_ == &::google::protobuf::internal::kEmptyString) {
    imsichargingidentifier_ = new ::std::string;
  }
  imsichargingidentifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbCapRoTsl::mutable_imsichargingidentifier() {
  set_has_imsichargingidentifier();
  if (imsichargingidentifier_ == &::google::protobuf::internal::kEmptyString) {
    imsichargingidentifier_ = new ::std::string;
  }
  return imsichargingidentifier_;
}
inline ::std::string* pbCapRoTsl::release_imsichargingidentifier() {
  clear_has_imsichargingidentifier();
  if (imsichargingidentifier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = imsichargingidentifier_;
    imsichargingidentifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string roServiceContextId = 7;
inline bool pbCapRoTsl::has_roservicecontextid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void pbCapRoTsl::set_has_roservicecontextid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void pbCapRoTsl::clear_has_roservicecontextid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void pbCapRoTsl::clear_roservicecontextid() {
  if (roservicecontextid_ != &::google::protobuf::internal::kEmptyString) {
    roservicecontextid_->clear();
  }
  clear_has_roservicecontextid();
}
inline const ::std::string& pbCapRoTsl::roservicecontextid() const {
  return *roservicecontextid_;
}
inline void pbCapRoTsl::set_roservicecontextid(const ::std::string& value) {
  set_has_roservicecontextid();
  if (roservicecontextid_ == &::google::protobuf::internal::kEmptyString) {
    roservicecontextid_ = new ::std::string;
  }
  roservicecontextid_->assign(value);
}
inline void pbCapRoTsl::set_roservicecontextid(const char* value) {
  set_has_roservicecontextid();
  if (roservicecontextid_ == &::google::protobuf::internal::kEmptyString) {
    roservicecontextid_ = new ::std::string;
  }
  roservicecontextid_->assign(value);
}
inline void pbCapRoTsl::set_roservicecontextid(const char* value, size_t size) {
  set_has_roservicecontextid();
  if (roservicecontextid_ == &::google::protobuf::internal::kEmptyString) {
    roservicecontextid_ = new ::std::string;
  }
  roservicecontextid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbCapRoTsl::mutable_roservicecontextid() {
  set_has_roservicecontextid();
  if (roservicecontextid_ == &::google::protobuf::internal::kEmptyString) {
    roservicecontextid_ = new ::std::string;
  }
  return roservicecontextid_;
}
inline ::std::string* pbCapRoTsl::release_roservicecontextid() {
  clear_has_roservicecontextid();
  if (roservicecontextid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roservicecontextid_;
    roservicecontextid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .SubscriptionIdConfig SubscriptionId = 8;
inline bool pbCapRoTsl::has_subscriptionid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void pbCapRoTsl::set_has_subscriptionid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void pbCapRoTsl::clear_has_subscriptionid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void pbCapRoTsl::clear_subscriptionid() {
  if (subscriptionid_ != NULL) subscriptionid_->::SubscriptionIdConfig::Clear();
  clear_has_subscriptionid();
}
inline const ::SubscriptionIdConfig& pbCapRoTsl::subscriptionid() const {
  return subscriptionid_ != NULL ? *subscriptionid_ : *default_instance_->subscriptionid_;
}
inline ::SubscriptionIdConfig* pbCapRoTsl::mutable_subscriptionid() {
  set_has_subscriptionid();
  if (subscriptionid_ == NULL) subscriptionid_ = new ::SubscriptionIdConfig;
  return subscriptionid_;
}
inline ::SubscriptionIdConfig* pbCapRoTsl::release_subscriptionid() {
  clear_has_subscriptionid();
  ::SubscriptionIdConfig* temp = subscriptionid_;
  subscriptionid_ = NULL;
  return temp;
}

// optional string roCugInformation = 9;
inline bool pbCapRoTsl::has_rocuginformation() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void pbCapRoTsl::set_has_rocuginformation() {
  _has_bits_[0] |= 0x00000100u;
}
inline void pbCapRoTsl::clear_has_rocuginformation() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void pbCapRoTsl::clear_rocuginformation() {
  if (rocuginformation_ != &::google::protobuf::internal::kEmptyString) {
    rocuginformation_->clear();
  }
  clear_has_rocuginformation();
}
inline const ::std::string& pbCapRoTsl::rocuginformation() const {
  return *rocuginformation_;
}
inline void pbCapRoTsl::set_rocuginformation(const ::std::string& value) {
  set_has_rocuginformation();
  if (rocuginformation_ == &::google::protobuf::internal::kEmptyString) {
    rocuginformation_ = new ::std::string;
  }
  rocuginformation_->assign(value);
}
inline void pbCapRoTsl::set_rocuginformation(const char* value) {
  set_has_rocuginformation();
  if (rocuginformation_ == &::google::protobuf::internal::kEmptyString) {
    rocuginformation_ = new ::std::string;
  }
  rocuginformation_->assign(value);
}
inline void pbCapRoTsl::set_rocuginformation(const char* value, size_t size) {
  set_has_rocuginformation();
  if (rocuginformation_ == &::google::protobuf::internal::kEmptyString) {
    rocuginformation_ = new ::std::string;
  }
  rocuginformation_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbCapRoTsl::mutable_rocuginformation() {
  set_has_rocuginformation();
  if (rocuginformation_ == &::google::protobuf::internal::kEmptyString) {
    rocuginformation_ = new ::std::string;
  }
  return rocuginformation_;
}
inline ::std::string* pbCapRoTsl::release_rocuginformation() {
  clear_has_rocuginformation();
  if (rocuginformation_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rocuginformation_;
    rocuginformation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string capMSCAddress = 10;
inline bool pbCapRoTsl::has_capmscaddress() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void pbCapRoTsl::set_has_capmscaddress() {
  _has_bits_[0] |= 0x00000200u;
}
inline void pbCapRoTsl::clear_has_capmscaddress() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void pbCapRoTsl::clear_capmscaddress() {
  if (capmscaddress_ != &::google::protobuf::internal::kEmptyString) {
    capmscaddress_->clear();
  }
  clear_has_capmscaddress();
}
inline const ::std::string& pbCapRoTsl::capmscaddress() const {
  return *capmscaddress_;
}
inline void pbCapRoTsl::set_capmscaddress(const ::std::string& value) {
  set_has_capmscaddress();
  if (capmscaddress_ == &::google::protobuf::internal::kEmptyString) {
    capmscaddress_ = new ::std::string;
  }
  capmscaddress_->assign(value);
}
inline void pbCapRoTsl::set_capmscaddress(const char* value) {
  set_has_capmscaddress();
  if (capmscaddress_ == &::google::protobuf::internal::kEmptyString) {
    capmscaddress_ = new ::std::string;
  }
  capmscaddress_->assign(value);
}
inline void pbCapRoTsl::set_capmscaddress(const char* value, size_t size) {
  set_has_capmscaddress();
  if (capmscaddress_ == &::google::protobuf::internal::kEmptyString) {
    capmscaddress_ = new ::std::string;
  }
  capmscaddress_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbCapRoTsl::mutable_capmscaddress() {
  set_has_capmscaddress();
  if (capmscaddress_ == &::google::protobuf::internal::kEmptyString) {
    capmscaddress_ = new ::std::string;
  }
  return capmscaddress_;
}
inline ::std::string* pbCapRoTsl::release_capmscaddress() {
  clear_has_capmscaddress();
  if (capmscaddress_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = capmscaddress_;
    capmscaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string capGMSCAddress = 11;
inline bool pbCapRoTsl::has_capgmscaddress() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void pbCapRoTsl::set_has_capgmscaddress() {
  _has_bits_[0] |= 0x00000400u;
}
inline void pbCapRoTsl::clear_has_capgmscaddress() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void pbCapRoTsl::clear_capgmscaddress() {
  if (capgmscaddress_ != &::google::protobuf::internal::kEmptyString) {
    capgmscaddress_->clear();
  }
  clear_has_capgmscaddress();
}
inline const ::std::string& pbCapRoTsl::capgmscaddress() const {
  return *capgmscaddress_;
}
inline void pbCapRoTsl::set_capgmscaddress(const ::std::string& value) {
  set_has_capgmscaddress();
  if (capgmscaddress_ == &::google::protobuf::internal::kEmptyString) {
    capgmscaddress_ = new ::std::string;
  }
  capgmscaddress_->assign(value);
}
inline void pbCapRoTsl::set_capgmscaddress(const char* value) {
  set_has_capgmscaddress();
  if (capgmscaddress_ == &::google::protobuf::internal::kEmptyString) {
    capgmscaddress_ = new ::std::string;
  }
  capgmscaddress_->assign(value);
}
inline void pbCapRoTsl::set_capgmscaddress(const char* value, size_t size) {
  set_has_capgmscaddress();
  if (capgmscaddress_ == &::google::protobuf::internal::kEmptyString) {
    capgmscaddress_ = new ::std::string;
  }
  capgmscaddress_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbCapRoTsl::mutable_capgmscaddress() {
  set_has_capgmscaddress();
  if (capgmscaddress_ == &::google::protobuf::internal::kEmptyString) {
    capgmscaddress_ = new ::std::string;
  }
  return capgmscaddress_;
}
inline ::std::string* pbCapRoTsl::release_capgmscaddress() {
  clear_has_capgmscaddress();
  if (capgmscaddress_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = capgmscaddress_;
    capgmscaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 ccaInitialResultCode = 12;
inline bool pbCapRoTsl::has_ccainitialresultcode() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void pbCapRoTsl::set_has_ccainitialresultcode() {
  _has_bits_[0] |= 0x00000800u;
}
inline void pbCapRoTsl::clear_has_ccainitialresultcode() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void pbCapRoTsl::clear_ccainitialresultcode() {
  ccainitialresultcode_ = 0u;
  clear_has_ccainitialresultcode();
}
inline ::google::protobuf::uint32 pbCapRoTsl::ccainitialresultcode() const {
  return ccainitialresultcode_;
}
inline void pbCapRoTsl::set_ccainitialresultcode(::google::protobuf::uint32 value) {
  set_has_ccainitialresultcode();
  ccainitialresultcode_ = value;
}

// optional uint32 ccaUpdateResultCode = 13;
inline bool pbCapRoTsl::has_ccaupdateresultcode() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void pbCapRoTsl::set_has_ccaupdateresultcode() {
  _has_bits_[0] |= 0x00001000u;
}
inline void pbCapRoTsl::clear_has_ccaupdateresultcode() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void pbCapRoTsl::clear_ccaupdateresultcode() {
  ccaupdateresultcode_ = 0u;
  clear_has_ccaupdateresultcode();
}
inline ::google::protobuf::uint32 pbCapRoTsl::ccaupdateresultcode() const {
  return ccaupdateresultcode_;
}
inline void pbCapRoTsl::set_ccaupdateresultcode(::google::protobuf::uint32 value) {
  set_has_ccaupdateresultcode();
  ccaupdateresultcode_ = value;
}

// optional uint32 ccaTerminateResultCode = 14;
inline bool pbCapRoTsl::has_ccaterminateresultcode() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void pbCapRoTsl::set_has_ccaterminateresultcode() {
  _has_bits_[0] |= 0x00002000u;
}
inline void pbCapRoTsl::clear_has_ccaterminateresultcode() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void pbCapRoTsl::clear_ccaterminateresultcode() {
  ccaterminateresultcode_ = 0u;
  clear_has_ccaterminateresultcode();
}
inline ::google::protobuf::uint32 pbCapRoTsl::ccaterminateresultcode() const {
  return ccaterminateresultcode_;
}
inline void pbCapRoTsl::set_ccaterminateresultcode(::google::protobuf::uint32 value) {
  set_has_ccaterminateresultcode();
  ccaterminateresultcode_ = value;
}

// optional bool receivedTcapContinue = 15 [default = false];
inline bool pbCapRoTsl::has_receivedtcapcontinue() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void pbCapRoTsl::set_has_receivedtcapcontinue() {
  _has_bits_[0] |= 0x00004000u;
}
inline void pbCapRoTsl::clear_has_receivedtcapcontinue() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void pbCapRoTsl::clear_receivedtcapcontinue() {
  receivedtcapcontinue_ = false;
  clear_has_receivedtcapcontinue();
}
inline bool pbCapRoTsl::receivedtcapcontinue() const {
  return receivedtcapcontinue_;
}
inline void pbCapRoTsl::set_receivedtcapcontinue(bool value) {
  set_has_receivedtcapcontinue();
  receivedtcapcontinue_ = value;
}

// optional bool receivedASR = 16 [default = false];
inline bool pbCapRoTsl::has_receivedasr() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void pbCapRoTsl::set_has_receivedasr() {
  _has_bits_[0] |= 0x00008000u;
}
inline void pbCapRoTsl::clear_has_receivedasr() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void pbCapRoTsl::clear_receivedasr() {
  receivedasr_ = false;
  clear_has_receivedasr();
}
inline bool pbCapRoTsl::receivedasr() const {
  return receivedasr_;
}
inline void pbCapRoTsl::set_receivedasr(bool value) {
  set_has_receivedasr();
  receivedasr_ = value;
}

// optional bool receivedIdpSms = 17 [default = false];
inline bool pbCapRoTsl::has_receivedidpsms() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void pbCapRoTsl::set_has_receivedidpsms() {
  _has_bits_[0] |= 0x00010000u;
}
inline void pbCapRoTsl::clear_has_receivedidpsms() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void pbCapRoTsl::clear_receivedidpsms() {
  receivedidpsms_ = false;
  clear_has_receivedidpsms();
}
inline bool pbCapRoTsl::receivedidpsms() const {
  return receivedidpsms_;
}
inline void pbCapRoTsl::set_receivedidpsms(bool value) {
  set_has_receivedidpsms();
  receivedidpsms_ = value;
}

// optional bool receivedIdp = 18 [default = false];
inline bool pbCapRoTsl::has_receivedidp() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void pbCapRoTsl::set_has_receivedidp() {
  _has_bits_[0] |= 0x00020000u;
}
inline void pbCapRoTsl::clear_has_receivedidp() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void pbCapRoTsl::clear_receivedidp() {
  receivedidp_ = false;
  clear_has_receivedidp();
}
inline bool pbCapRoTsl::receivedidp() const {
  return receivedidp_;
}
inline void pbCapRoTsl::set_receivedidp(bool value) {
  set_has_receivedidp();
  receivedidp_ = value;
}

// optional bool isTimeZoneSeconds = 19 [default = false];
inline bool pbCapRoTsl::has_istimezoneseconds() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void pbCapRoTsl::set_has_istimezoneseconds() {
  _has_bits_[0] |= 0x00040000u;
}
inline void pbCapRoTsl::clear_has_istimezoneseconds() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void pbCapRoTsl::clear_istimezoneseconds() {
  istimezoneseconds_ = false;
  clear_has_istimezoneseconds();
}
inline bool pbCapRoTsl::istimezoneseconds() const {
  return istimezoneseconds_;
}
inline void pbCapRoTsl::set_istimezoneseconds(bool value) {
  set_has_istimezoneseconds();
  istimezoneseconds_ = value;
}

// optional uint32 timeZoneSeconds = 20;
inline bool pbCapRoTsl::has_timezoneseconds() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void pbCapRoTsl::set_has_timezoneseconds() {
  _has_bits_[0] |= 0x00080000u;
}
inline void pbCapRoTsl::clear_has_timezoneseconds() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void pbCapRoTsl::clear_timezoneseconds() {
  timezoneseconds_ = 0u;
  clear_has_timezoneseconds();
}
inline ::google::protobuf::uint32 pbCapRoTsl::timezoneseconds() const {
  return timezoneseconds_;
}
inline void pbCapRoTsl::set_timezoneseconds(::google::protobuf::uint32 value) {
  set_has_timezoneseconds();
  timezoneseconds_ = value;
}

// optional uint32 ccaUpdateMsccResultCode = 21;
inline bool pbCapRoTsl::has_ccaupdatemsccresultcode() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void pbCapRoTsl::set_has_ccaupdatemsccresultcode() {
  _has_bits_[0] |= 0x00100000u;
}
inline void pbCapRoTsl::clear_has_ccaupdatemsccresultcode() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void pbCapRoTsl::clear_ccaupdatemsccresultcode() {
  ccaupdatemsccresultcode_ = 0u;
  clear_has_ccaupdatemsccresultcode();
}
inline ::google::protobuf::uint32 pbCapRoTsl::ccaupdatemsccresultcode() const {
  return ccaupdatemsccresultcode_;
}
inline void pbCapRoTsl::set_ccaupdatemsccresultcode(::google::protobuf::uint32 value) {
  set_has_ccaupdatemsccresultcode();
  ccaupdatemsccresultcode_ = value;
}

// optional bool isccaMsccGrantedCCTimeZero = 22 [default = false];
inline bool pbCapRoTsl::has_isccamsccgrantedcctimezero() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void pbCapRoTsl::set_has_isccamsccgrantedcctimezero() {
  _has_bits_[0] |= 0x00200000u;
}
inline void pbCapRoTsl::clear_has_isccamsccgrantedcctimezero() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void pbCapRoTsl::clear_isccamsccgrantedcctimezero() {
  isccamsccgrantedcctimezero_ = false;
  clear_has_isccamsccgrantedcctimezero();
}
inline bool pbCapRoTsl::isccamsccgrantedcctimezero() const {
  return isccamsccgrantedcctimezero_;
}
inline void pbCapRoTsl::set_isccamsccgrantedcctimezero(bool value) {
  set_has_isccamsccgrantedcctimezero();
  isccamsccgrantedcctimezero_ = value;
}

// optional bool isReleaseSent = 23;
inline bool pbCapRoTsl::has_isreleasesent() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void pbCapRoTsl::set_has_isreleasesent() {
  _has_bits_[0] |= 0x00400000u;
}
inline void pbCapRoTsl::clear_has_isreleasesent() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void pbCapRoTsl::clear_isreleasesent() {
  isreleasesent_ = false;
  clear_has_isreleasesent();
}
inline bool pbCapRoTsl::isreleasesent() const {
  return isreleasesent_;
}
inline void pbCapRoTsl::set_isreleasesent(bool value) {
  set_has_isreleasesent();
  isreleasesent_ = value;
}

// optional uint32 lastSentCCRequestType = 24;
inline bool pbCapRoTsl::has_lastsentccrequesttype() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void pbCapRoTsl::set_has_lastsentccrequesttype() {
  _has_bits_[0] |= 0x00800000u;
}
inline void pbCapRoTsl::clear_has_lastsentccrequesttype() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void pbCapRoTsl::clear_lastsentccrequesttype() {
  lastsentccrequesttype_ = 0u;
  clear_has_lastsentccrequesttype();
}
inline ::google::protobuf::uint32 pbCapRoTsl::lastsentccrequesttype() const {
  return lastsentccrequesttype_;
}
inline void pbCapRoTsl::set_lastsentccrequesttype(::google::protobuf::uint32 value) {
  set_has_lastsentccrequesttype();
  lastsentccrequesttype_ = value;
}

// optional uint32 ccRequestNumber = 25;
inline bool pbCapRoTsl::has_ccrequestnumber() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void pbCapRoTsl::set_has_ccrequestnumber() {
  _has_bits_[0] |= 0x01000000u;
}
inline void pbCapRoTsl::clear_has_ccrequestnumber() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void pbCapRoTsl::clear_ccrequestnumber() {
  ccrequestnumber_ = 0u;
  clear_has_ccrequestnumber();
}
inline ::google::protobuf::uint32 pbCapRoTsl::ccrequestnumber() const {
  return ccrequestnumber_;
}
inline void pbCapRoTsl::set_ccrequestnumber(::google::protobuf::uint32 value) {
  set_has_ccrequestnumber();
  ccrequestnumber_ = value;
}

// optional bool isFirstERBRcvd = 26;
inline bool pbCapRoTsl::has_isfirsterbrcvd() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void pbCapRoTsl::set_has_isfirsterbrcvd() {
  _has_bits_[0] |= 0x02000000u;
}
inline void pbCapRoTsl::clear_has_isfirsterbrcvd() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void pbCapRoTsl::clear_isfirsterbrcvd() {
  isfirsterbrcvd_ = false;
  clear_has_isfirsterbrcvd();
}
inline bool pbCapRoTsl::isfirsterbrcvd() const {
  return isfirsterbrcvd_;
}
inline void pbCapRoTsl::set_isfirsterbrcvd(bool value) {
  set_has_isfirsterbrcvd();
  isfirsterbrcvd_ = value;
}

// optional uint32 CallType = 27;
inline bool pbCapRoTsl::has_calltype() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void pbCapRoTsl::set_has_calltype() {
  _has_bits_[0] |= 0x04000000u;
}
inline void pbCapRoTsl::clear_has_calltype() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void pbCapRoTsl::clear_calltype() {
  calltype_ = 0u;
  clear_has_calltype();
}
inline ::google::protobuf::uint32 pbCapRoTsl::calltype() const {
  return calltype_;
}
inline void pbCapRoTsl::set_calltype(::google::protobuf::uint32 value) {
  set_has_calltype();
  calltype_ = value;
}

// optional uint32 scpAction = 28 [default = 0];
inline bool pbCapRoTsl::has_scpaction() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void pbCapRoTsl::set_has_scpaction() {
  _has_bits_[0] |= 0x08000000u;
}
inline void pbCapRoTsl::clear_has_scpaction() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void pbCapRoTsl::clear_scpaction() {
  scpaction_ = 0u;
  clear_has_scpaction();
}
inline ::google::protobuf::uint32 pbCapRoTsl::scpaction() const {
  return scpaction_;
}
inline void pbCapRoTsl::set_scpaction(::google::protobuf::uint32 value) {
  set_has_scpaction();
  scpaction_ = value;
}

// optional uint32 orgScpAction = 29 [default = 0];
inline bool pbCapRoTsl::has_orgscpaction() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void pbCapRoTsl::set_has_orgscpaction() {
  _has_bits_[0] |= 0x10000000u;
}
inline void pbCapRoTsl::clear_has_orgscpaction() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void pbCapRoTsl::clear_orgscpaction() {
  orgscpaction_ = 0u;
  clear_has_orgscpaction();
}
inline ::google::protobuf::uint32 pbCapRoTsl::orgscpaction() const {
  return orgscpaction_;
}
inline void pbCapRoTsl::set_orgscpaction(::google::protobuf::uint32 value) {
  set_has_orgscpaction();
  orgscpaction_ = value;
}

// optional int32 capControlMode = 30 [default = -1];
inline bool pbCapRoTsl::has_capcontrolmode() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void pbCapRoTsl::set_has_capcontrolmode() {
  _has_bits_[0] |= 0x20000000u;
}
inline void pbCapRoTsl::clear_has_capcontrolmode() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void pbCapRoTsl::clear_capcontrolmode() {
  capcontrolmode_ = -1;
  clear_has_capcontrolmode();
}
inline ::google::protobuf::int32 pbCapRoTsl::capcontrolmode() const {
  return capcontrolmode_;
}
inline void pbCapRoTsl::set_capcontrolmode(::google::protobuf::int32 value) {
  set_has_capcontrolmode();
  capcontrolmode_ = value;
}

// optional uint32 terminationCause = 31;
inline bool pbCapRoTsl::has_terminationcause() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void pbCapRoTsl::set_has_terminationcause() {
  _has_bits_[0] |= 0x40000000u;
}
inline void pbCapRoTsl::clear_has_terminationcause() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void pbCapRoTsl::clear_terminationcause() {
  terminationcause_ = 0u;
  clear_has_terminationcause();
}
inline ::google::protobuf::uint32 pbCapRoTsl::terminationcause() const {
  return terminationcause_;
}
inline void pbCapRoTsl::set_terminationcause(::google::protobuf::uint32 value) {
  set_has_terminationcause();
  terminationcause_ = value;
}

// optional .StoredIDPSMSToCCRIData mappedIDPToCCRIData = 32;
inline bool pbCapRoTsl::has_mappedidptoccridata() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void pbCapRoTsl::set_has_mappedidptoccridata() {
  _has_bits_[0] |= 0x80000000u;
}
inline void pbCapRoTsl::clear_has_mappedidptoccridata() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void pbCapRoTsl::clear_mappedidptoccridata() {
  if (mappedidptoccridata_ != NULL) mappedidptoccridata_->::StoredIDPSMSToCCRIData::Clear();
  clear_has_mappedidptoccridata();
}
inline const ::StoredIDPSMSToCCRIData& pbCapRoTsl::mappedidptoccridata() const {
  return mappedidptoccridata_ != NULL ? *mappedidptoccridata_ : *default_instance_->mappedidptoccridata_;
}
inline ::StoredIDPSMSToCCRIData* pbCapRoTsl::mutable_mappedidptoccridata() {
  set_has_mappedidptoccridata();
  if (mappedidptoccridata_ == NULL) mappedidptoccridata_ = new ::StoredIDPSMSToCCRIData;
  return mappedidptoccridata_;
}
inline ::StoredIDPSMSToCCRIData* pbCapRoTsl::release_mappedidptoccridata() {
  clear_has_mappedidptoccridata();
  ::StoredIDPSMSToCCRIData* temp = mappedidptoccridata_;
  mappedidptoccridata_ = NULL;
  return temp;
}

// optional uint32 recvAppContextName = 33;
inline bool pbCapRoTsl::has_recvappcontextname() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void pbCapRoTsl::set_has_recvappcontextname() {
  _has_bits_[1] |= 0x00000001u;
}
inline void pbCapRoTsl::clear_has_recvappcontextname() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void pbCapRoTsl::clear_recvappcontextname() {
  recvappcontextname_ = 0u;
  clear_has_recvappcontextname();
}
inline ::google::protobuf::uint32 pbCapRoTsl::recvappcontextname() const {
  return recvappcontextname_;
}
inline void pbCapRoTsl::set_recvappcontextname(::google::protobuf::uint32 value) {
  set_has_recvappcontextname();
  recvappcontextname_ = value;
}

// optional .IDPToCCRIData IdpCCRIData = 34;
inline bool pbCapRoTsl::has_idpccridata() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void pbCapRoTsl::set_has_idpccridata() {
  _has_bits_[1] |= 0x00000002u;
}
inline void pbCapRoTsl::clear_has_idpccridata() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void pbCapRoTsl::clear_idpccridata() {
  if (idpccridata_ != NULL) idpccridata_->::IDPToCCRIData::Clear();
  clear_has_idpccridata();
}
inline const ::IDPToCCRIData& pbCapRoTsl::idpccridata() const {
  return idpccridata_ != NULL ? *idpccridata_ : *default_instance_->idpccridata_;
}
inline ::IDPToCCRIData* pbCapRoTsl::mutable_idpccridata() {
  set_has_idpccridata();
  if (idpccridata_ == NULL) idpccridata_ = new ::IDPToCCRIData;
  return idpccridata_;
}
inline ::IDPToCCRIData* pbCapRoTsl::release_idpccridata() {
  clear_has_idpccridata();
  ::IDPToCCRIData* temp = idpccridata_;
  idpccridata_ = NULL;
  return temp;
}

// optional uint32 recvGSUCCTime = 35;
inline bool pbCapRoTsl::has_recvgsucctime() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void pbCapRoTsl::set_has_recvgsucctime() {
  _has_bits_[1] |= 0x00000004u;
}
inline void pbCapRoTsl::clear_has_recvgsucctime() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void pbCapRoTsl::clear_recvgsucctime() {
  recvgsucctime_ = 0u;
  clear_has_recvgsucctime();
}
inline ::google::protobuf::uint32 pbCapRoTsl::recvgsucctime() const {
  return recvgsucctime_;
}
inline void pbCapRoTsl::set_recvgsucctime(::google::protobuf::uint32 value) {
  set_has_recvgsucctime();
  recvgsucctime_ = value;
}

// optional uint32 recvNoAnsTime = 36;
inline bool pbCapRoTsl::has_recvnoanstime() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void pbCapRoTsl::set_has_recvnoanstime() {
  _has_bits_[1] |= 0x00000008u;
}
inline void pbCapRoTsl::clear_has_recvnoanstime() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void pbCapRoTsl::clear_recvnoanstime() {
  recvnoanstime_ = 0u;
  clear_has_recvnoanstime();
}
inline ::google::protobuf::uint32 pbCapRoTsl::recvnoanstime() const {
  return recvnoanstime_;
}
inline void pbCapRoTsl::set_recvnoanstime(::google::protobuf::uint32 value) {
  set_has_recvnoanstime();
  recvnoanstime_ = value;
}

// optional uint32 currUSUCCTime = 37;
inline bool pbCapRoTsl::has_currusucctime() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void pbCapRoTsl::set_has_currusucctime() {
  _has_bits_[1] |= 0x00000010u;
}
inline void pbCapRoTsl::clear_has_currusucctime() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void pbCapRoTsl::clear_currusucctime() {
  currusucctime_ = 0u;
  clear_has_currusucctime();
}
inline ::google::protobuf::uint32 pbCapRoTsl::currusucctime() const {
  return currusucctime_;
}
inline void pbCapRoTsl::set_currusucctime(::google::protobuf::uint32 value) {
  set_has_currusucctime();
  currusucctime_ = value;
}

// optional uint32 cumulativeGSUCCTime = 38;
inline bool pbCapRoTsl::has_cumulativegsucctime() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void pbCapRoTsl::set_has_cumulativegsucctime() {
  _has_bits_[1] |= 0x00000020u;
}
inline void pbCapRoTsl::clear_has_cumulativegsucctime() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void pbCapRoTsl::clear_cumulativegsucctime() {
  cumulativegsucctime_ = 0u;
  clear_has_cumulativegsucctime();
}
inline ::google::protobuf::uint32 pbCapRoTsl::cumulativegsucctime() const {
  return cumulativegsucctime_;
}
inline void pbCapRoTsl::set_cumulativegsucctime(::google::protobuf::uint32 value) {
  set_has_cumulativegsucctime();
  cumulativegsucctime_ = value;
}

// optional uint32 cumulativeUSUCCTime = 39;
inline bool pbCapRoTsl::has_cumulativeusucctime() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void pbCapRoTsl::set_has_cumulativeusucctime() {
  _has_bits_[1] |= 0x00000040u;
}
inline void pbCapRoTsl::clear_has_cumulativeusucctime() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void pbCapRoTsl::clear_cumulativeusucctime() {
  cumulativeusucctime_ = 0u;
  clear_has_cumulativeusucctime();
}
inline ::google::protobuf::uint32 pbCapRoTsl::cumulativeusucctime() const {
  return cumulativeusucctime_;
}
inline void pbCapRoTsl::set_cumulativeusucctime(::google::protobuf::uint32 value) {
  set_has_cumulativeusucctime();
  cumulativeusucctime_ = value;
}

// optional bool isFinalUnitReceived = 40 [default = false];
inline bool pbCapRoTsl::has_isfinalunitreceived() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void pbCapRoTsl::set_has_isfinalunitreceived() {
  _has_bits_[1] |= 0x00000080u;
}
inline void pbCapRoTsl::clear_has_isfinalunitreceived() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void pbCapRoTsl::clear_isfinalunitreceived() {
  isfinalunitreceived_ = false;
  clear_has_isfinalunitreceived();
}
inline bool pbCapRoTsl::isfinalunitreceived() const {
  return isfinalunitreceived_;
}
inline void pbCapRoTsl::set_isfinalunitreceived(bool value) {
  set_has_isfinalunitreceived();
  isfinalunitreceived_ = value;
}

// optional .pbERBData recvFirstERBData = 41;
inline bool pbCapRoTsl::has_recvfirsterbdata() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void pbCapRoTsl::set_has_recvfirsterbdata() {
  _has_bits_[1] |= 0x00000100u;
}
inline void pbCapRoTsl::clear_has_recvfirsterbdata() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void pbCapRoTsl::clear_recvfirsterbdata() {
  if (recvfirsterbdata_ != NULL) recvfirsterbdata_->::pbERBData::Clear();
  clear_has_recvfirsterbdata();
}
inline const ::pbERBData& pbCapRoTsl::recvfirsterbdata() const {
  return recvfirsterbdata_ != NULL ? *recvfirsterbdata_ : *default_instance_->recvfirsterbdata_;
}
inline ::pbERBData* pbCapRoTsl::mutable_recvfirsterbdata() {
  set_has_recvfirsterbdata();
  if (recvfirsterbdata_ == NULL) recvfirsterbdata_ = new ::pbERBData;
  return recvfirsterbdata_;
}
inline ::pbERBData* pbCapRoTsl::release_recvfirsterbdata() {
  clear_has_recvfirsterbdata();
  ::pbERBData* temp = recvfirsterbdata_;
  recvfirsterbdata_ = NULL;
  return temp;
}

// optional .pbERBData recvERBData = 42;
inline bool pbCapRoTsl::has_recverbdata() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void pbCapRoTsl::set_has_recverbdata() {
  _has_bits_[1] |= 0x00000200u;
}
inline void pbCapRoTsl::clear_has_recverbdata() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void pbCapRoTsl::clear_recverbdata() {
  if (recverbdata_ != NULL) recverbdata_->::pbERBData::Clear();
  clear_has_recverbdata();
}
inline const ::pbERBData& pbCapRoTsl::recverbdata() const {
  return recverbdata_ != NULL ? *recverbdata_ : *default_instance_->recverbdata_;
}
inline ::pbERBData* pbCapRoTsl::mutable_recverbdata() {
  set_has_recverbdata();
  if (recverbdata_ == NULL) recverbdata_ = new ::pbERBData;
  return recverbdata_;
}
inline ::pbERBData* pbCapRoTsl::release_recverbdata() {
  clear_has_recverbdata();
  ::pbERBData* temp = recverbdata_;
  recverbdata_ = NULL;
  return temp;
}

// optional uint32 callAnswerTimeStamp = 43;
inline bool pbCapRoTsl::has_callanswertimestamp() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void pbCapRoTsl::set_has_callanswertimestamp() {
  _has_bits_[1] |= 0x00000400u;
}
inline void pbCapRoTsl::clear_has_callanswertimestamp() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void pbCapRoTsl::clear_callanswertimestamp() {
  callanswertimestamp_ = 0u;
  clear_has_callanswertimestamp();
}
inline ::google::protobuf::uint32 pbCapRoTsl::callanswertimestamp() const {
  return callanswertimestamp_;
}
inline void pbCapRoTsl::set_callanswertimestamp(::google::protobuf::uint32 value) {
  set_has_callanswertimestamp();
  callanswertimestamp_ = value;
}

// optional bool isFollowingOn = 44;
inline bool pbCapRoTsl::has_isfollowingon() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void pbCapRoTsl::set_has_isfollowingon() {
  _has_bits_[1] |= 0x00000800u;
}
inline void pbCapRoTsl::clear_has_isfollowingon() {
  _has_bits_[1] &= ~0x00000800u;
}
inline void pbCapRoTsl::clear_isfollowingon() {
  isfollowingon_ = false;
  clear_has_isfollowingon();
}
inline bool pbCapRoTsl::isfollowingon() const {
  return isfollowingon_;
}
inline void pbCapRoTsl::set_isfollowingon(bool value) {
  set_has_isfollowingon();
  isfollowingon_ = value;
}

// optional .pbActivityTimerData activityTimerData = 45;
inline bool pbCapRoTsl::has_activitytimerdata() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void pbCapRoTsl::set_has_activitytimerdata() {
  _has_bits_[1] |= 0x00001000u;
}
inline void pbCapRoTsl::clear_has_activitytimerdata() {
  _has_bits_[1] &= ~0x00001000u;
}
inline void pbCapRoTsl::clear_activitytimerdata() {
  if (activitytimerdata_ != NULL) activitytimerdata_->::pbActivityTimerData::Clear();
  clear_has_activitytimerdata();
}
inline const ::pbActivityTimerData& pbCapRoTsl::activitytimerdata() const {
  return activitytimerdata_ != NULL ? *activitytimerdata_ : *default_instance_->activitytimerdata_;
}
inline ::pbActivityTimerData* pbCapRoTsl::mutable_activitytimerdata() {
  set_has_activitytimerdata();
  if (activitytimerdata_ == NULL) activitytimerdata_ = new ::pbActivityTimerData;
  return activitytimerdata_;
}
inline ::pbActivityTimerData* pbCapRoTsl::release_activitytimerdata() {
  clear_has_activitytimerdata();
  ::pbActivityTimerData* temp = activitytimerdata_;
  activitytimerdata_ = NULL;
  return temp;
}

// optional string strRemoteTransIdForCDR = 46;
inline bool pbCapRoTsl::has_strremotetransidforcdr() const {
  return (_has_bits_[1] & 0x00002000u) != 0;
}
inline void pbCapRoTsl::set_has_strremotetransidforcdr() {
  _has_bits_[1] |= 0x00002000u;
}
inline void pbCapRoTsl::clear_has_strremotetransidforcdr() {
  _has_bits_[1] &= ~0x00002000u;
}
inline void pbCapRoTsl::clear_strremotetransidforcdr() {
  if (strremotetransidforcdr_ != &::google::protobuf::internal::kEmptyString) {
    strremotetransidforcdr_->clear();
  }
  clear_has_strremotetransidforcdr();
}
inline const ::std::string& pbCapRoTsl::strremotetransidforcdr() const {
  return *strremotetransidforcdr_;
}
inline void pbCapRoTsl::set_strremotetransidforcdr(const ::std::string& value) {
  set_has_strremotetransidforcdr();
  if (strremotetransidforcdr_ == &::google::protobuf::internal::kEmptyString) {
    strremotetransidforcdr_ = new ::std::string;
  }
  strremotetransidforcdr_->assign(value);
}
inline void pbCapRoTsl::set_strremotetransidforcdr(const char* value) {
  set_has_strremotetransidforcdr();
  if (strremotetransidforcdr_ == &::google::protobuf::internal::kEmptyString) {
    strremotetransidforcdr_ = new ::std::string;
  }
  strremotetransidforcdr_->assign(value);
}
inline void pbCapRoTsl::set_strremotetransidforcdr(const char* value, size_t size) {
  set_has_strremotetransidforcdr();
  if (strremotetransidforcdr_ == &::google::protobuf::internal::kEmptyString) {
    strremotetransidforcdr_ = new ::std::string;
  }
  strremotetransidforcdr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbCapRoTsl::mutable_strremotetransidforcdr() {
  set_has_strremotetransidforcdr();
  if (strremotetransidforcdr_ == &::google::protobuf::internal::kEmptyString) {
    strremotetransidforcdr_ = new ::std::string;
  }
  return strremotetransidforcdr_;
}
inline ::std::string* pbCapRoTsl::release_strremotetransidforcdr() {
  clear_has_strremotetransidforcdr();
  if (strremotetransidforcdr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strremotetransidforcdr_;
    strremotetransidforcdr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string strLocalTransIdForCDR = 47;
inline bool pbCapRoTsl::has_strlocaltransidforcdr() const {
  return (_has_bits_[1] & 0x00004000u) != 0;
}
inline void pbCapRoTsl::set_has_strlocaltransidforcdr() {
  _has_bits_[1] |= 0x00004000u;
}
inline void pbCapRoTsl::clear_has_strlocaltransidforcdr() {
  _has_bits_[1] &= ~0x00004000u;
}
inline void pbCapRoTsl::clear_strlocaltransidforcdr() {
  if (strlocaltransidforcdr_ != &::google::protobuf::internal::kEmptyString) {
    strlocaltransidforcdr_->clear();
  }
  clear_has_strlocaltransidforcdr();
}
inline const ::std::string& pbCapRoTsl::strlocaltransidforcdr() const {
  return *strlocaltransidforcdr_;
}
inline void pbCapRoTsl::set_strlocaltransidforcdr(const ::std::string& value) {
  set_has_strlocaltransidforcdr();
  if (strlocaltransidforcdr_ == &::google::protobuf::internal::kEmptyString) {
    strlocaltransidforcdr_ = new ::std::string;
  }
  strlocaltransidforcdr_->assign(value);
}
inline void pbCapRoTsl::set_strlocaltransidforcdr(const char* value) {
  set_has_strlocaltransidforcdr();
  if (strlocaltransidforcdr_ == &::google::protobuf::internal::kEmptyString) {
    strlocaltransidforcdr_ = new ::std::string;
  }
  strlocaltransidforcdr_->assign(value);
}
inline void pbCapRoTsl::set_strlocaltransidforcdr(const char* value, size_t size) {
  set_has_strlocaltransidforcdr();
  if (strlocaltransidforcdr_ == &::google::protobuf::internal::kEmptyString) {
    strlocaltransidforcdr_ = new ::std::string;
  }
  strlocaltransidforcdr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbCapRoTsl::mutable_strlocaltransidforcdr() {
  set_has_strlocaltransidforcdr();
  if (strlocaltransidforcdr_ == &::google::protobuf::internal::kEmptyString) {
    strlocaltransidforcdr_ = new ::std::string;
  }
  return strlocaltransidforcdr_;
}
inline ::std::string* pbCapRoTsl::release_strlocaltransidforcdr() {
  clear_has_strlocaltransidforcdr();
  if (strlocaltransidforcdr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strlocaltransidforcdr_;
    strlocaltransidforcdr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool bIsCallContinueSet = 48 [default = false];
inline bool pbCapRoTsl::has_biscallcontinueset() const {
  return (_has_bits_[1] & 0x00008000u) != 0;
}
inline void pbCapRoTsl::set_has_biscallcontinueset() {
  _has_bits_[1] |= 0x00008000u;
}
inline void pbCapRoTsl::clear_has_biscallcontinueset() {
  _has_bits_[1] &= ~0x00008000u;
}
inline void pbCapRoTsl::clear_biscallcontinueset() {
  biscallcontinueset_ = false;
  clear_has_biscallcontinueset();
}
inline bool pbCapRoTsl::biscallcontinueset() const {
  return biscallcontinueset_;
}
inline void pbCapRoTsl::set_biscallcontinueset(bool value) {
  set_has_biscallcontinueset();
  biscallcontinueset_ = value;
}

// optional uint32 sessionStartTimeStamp = 49;
inline bool pbCapRoTsl::has_sessionstarttimestamp() const {
  return (_has_bits_[1] & 0x00010000u) != 0;
}
inline void pbCapRoTsl::set_has_sessionstarttimestamp() {
  _has_bits_[1] |= 0x00010000u;
}
inline void pbCapRoTsl::clear_has_sessionstarttimestamp() {
  _has_bits_[1] &= ~0x00010000u;
}
inline void pbCapRoTsl::clear_sessionstarttimestamp() {
  sessionstarttimestamp_ = 0u;
  clear_has_sessionstarttimestamp();
}
inline ::google::protobuf::uint32 pbCapRoTsl::sessionstarttimestamp() const {
  return sessionstarttimestamp_;
}
inline void pbCapRoTsl::set_sessionstarttimestamp(::google::protobuf::uint32 value) {
  set_has_sessionstarttimestamp();
  sessionstarttimestamp_ = value;
}

// optional uint32 connectMaxDuration = 50;
inline bool pbCapRoTsl::has_connectmaxduration() const {
  return (_has_bits_[1] & 0x00020000u) != 0;
}
inline void pbCapRoTsl::set_has_connectmaxduration() {
  _has_bits_[1] |= 0x00020000u;
}
inline void pbCapRoTsl::clear_has_connectmaxduration() {
  _has_bits_[1] &= ~0x00020000u;
}
inline void pbCapRoTsl::clear_connectmaxduration() {
  connectmaxduration_ = 0u;
  clear_has_connectmaxduration();
}
inline ::google::protobuf::uint32 pbCapRoTsl::connectmaxduration() const {
  return connectmaxduration_;
}
inline void pbCapRoTsl::set_connectmaxduration(::google::protobuf::uint32 value) {
  set_has_connectmaxduration();
  connectmaxduration_ = value;
}

// optional uint32 erbAnswerTimeStamp = 51;
inline bool pbCapRoTsl::has_erbanswertimestamp() const {
  return (_has_bits_[1] & 0x00040000u) != 0;
}
inline void pbCapRoTsl::set_has_erbanswertimestamp() {
  _has_bits_[1] |= 0x00040000u;
}
inline void pbCapRoTsl::clear_has_erbanswertimestamp() {
  _has_bits_[1] &= ~0x00040000u;
}
inline void pbCapRoTsl::clear_erbanswertimestamp() {
  erbanswertimestamp_ = 0u;
  clear_has_erbanswertimestamp();
}
inline ::google::protobuf::uint32 pbCapRoTsl::erbanswertimestamp() const {
  return erbanswertimestamp_;
}
inline void pbCapRoTsl::set_erbanswertimestamp(::google::protobuf::uint32 value) {
  set_has_erbanswertimestamp();
  erbanswertimestamp_ = value;
}

// optional string erbSpecificInfo = 52;
inline bool pbCapRoTsl::has_erbspecificinfo() const {
  return (_has_bits_[1] & 0x00080000u) != 0;
}
inline void pbCapRoTsl::set_has_erbspecificinfo() {
  _has_bits_[1] |= 0x00080000u;
}
inline void pbCapRoTsl::clear_has_erbspecificinfo() {
  _has_bits_[1] &= ~0x00080000u;
}
inline void pbCapRoTsl::clear_erbspecificinfo() {
  if (erbspecificinfo_ != &::google::protobuf::internal::kEmptyString) {
    erbspecificinfo_->clear();
  }
  clear_has_erbspecificinfo();
}
inline const ::std::string& pbCapRoTsl::erbspecificinfo() const {
  return *erbspecificinfo_;
}
inline void pbCapRoTsl::set_erbspecificinfo(const ::std::string& value) {
  set_has_erbspecificinfo();
  if (erbspecificinfo_ == &::google::protobuf::internal::kEmptyString) {
    erbspecificinfo_ = new ::std::string;
  }
  erbspecificinfo_->assign(value);
}
inline void pbCapRoTsl::set_erbspecificinfo(const char* value) {
  set_has_erbspecificinfo();
  if (erbspecificinfo_ == &::google::protobuf::internal::kEmptyString) {
    erbspecificinfo_ = new ::std::string;
  }
  erbspecificinfo_->assign(value);
}
inline void pbCapRoTsl::set_erbspecificinfo(const char* value, size_t size) {
  set_has_erbspecificinfo();
  if (erbspecificinfo_ == &::google::protobuf::internal::kEmptyString) {
    erbspecificinfo_ = new ::std::string;
  }
  erbspecificinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbCapRoTsl::mutable_erbspecificinfo() {
  set_has_erbspecificinfo();
  if (erbspecificinfo_ == &::google::protobuf::internal::kEmptyString) {
    erbspecificinfo_ = new ::std::string;
  }
  return erbspecificinfo_;
}
inline ::std::string* pbCapRoTsl::release_erbspecificinfo() {
  clear_has_erbspecificinfo();
  if (erbspecificinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = erbspecificinfo_;
    erbspecificinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .pbIwfDccaSessionCtxt dccaCtxt = 53;
inline bool pbCapRoTsl::has_dccactxt() const {
  return (_has_bits_[1] & 0x00100000u) != 0;
}
inline void pbCapRoTsl::set_has_dccactxt() {
  _has_bits_[1] |= 0x00100000u;
}
inline void pbCapRoTsl::clear_has_dccactxt() {
  _has_bits_[1] &= ~0x00100000u;
}
inline void pbCapRoTsl::clear_dccactxt() {
  if (dccactxt_ != NULL) dccactxt_->::pbIwfDccaSessionCtxt::Clear();
  clear_has_dccactxt();
}
inline const ::pbIwfDccaSessionCtxt& pbCapRoTsl::dccactxt() const {
  return dccactxt_ != NULL ? *dccactxt_ : *default_instance_->dccactxt_;
}
inline ::pbIwfDccaSessionCtxt* pbCapRoTsl::mutable_dccactxt() {
  set_has_dccactxt();
  if (dccactxt_ == NULL) dccactxt_ = new ::pbIwfDccaSessionCtxt;
  return dccactxt_;
}
inline ::pbIwfDccaSessionCtxt* pbCapRoTsl::release_dccactxt() {
  clear_has_dccactxt();
  ::pbIwfDccaSessionCtxt* temp = dccactxt_;
  dccactxt_ = NULL;
  return temp;
}

// optional bool isFailedCDRLogged = 54 [default = false];
inline bool pbCapRoTsl::has_isfailedcdrlogged() const {
  return (_has_bits_[1] & 0x00200000u) != 0;
}
inline void pbCapRoTsl::set_has_isfailedcdrlogged() {
  _has_bits_[1] |= 0x00200000u;
}
inline void pbCapRoTsl::clear_has_isfailedcdrlogged() {
  _has_bits_[1] &= ~0x00200000u;
}
inline void pbCapRoTsl::clear_isfailedcdrlogged() {
  isfailedcdrlogged_ = false;
  clear_has_isfailedcdrlogged();
}
inline bool pbCapRoTsl::isfailedcdrlogged() const {
  return isfailedcdrlogged_;
}
inline void pbCapRoTsl::set_isfailedcdrlogged(bool value) {
  set_has_isfailedcdrlogged();
  isfailedcdrlogged_ = value;
}

// optional uint32 releaseCause = 55;
inline bool pbCapRoTsl::has_releasecause() const {
  return (_has_bits_[1] & 0x00400000u) != 0;
}
inline void pbCapRoTsl::set_has_releasecause() {
  _has_bits_[1] |= 0x00400000u;
}
inline void pbCapRoTsl::clear_has_releasecause() {
  _has_bits_[1] &= ~0x00400000u;
}
inline void pbCapRoTsl::clear_releasecause() {
  releasecause_ = 0u;
  clear_has_releasecause();
}
inline ::google::protobuf::uint32 pbCapRoTsl::releasecause() const {
  return releasecause_;
}
inline void pbCapRoTsl::set_releasecause(::google::protobuf::uint32 value) {
  set_has_releasecause();
  releasecause_ = value;
}

// optional .TransState currState = 56;
inline bool pbCapRoTsl::has_currstate() const {
  return (_has_bits_[1] & 0x00800000u) != 0;
}
inline void pbCapRoTsl::set_has_currstate() {
  _has_bits_[1] |= 0x00800000u;
}
inline void pbCapRoTsl::clear_has_currstate() {
  _has_bits_[1] &= ~0x00800000u;
}
inline void pbCapRoTsl::clear_currstate() {
  currstate_ = 0;
  clear_has_currstate();
}
inline TransState pbCapRoTsl::currstate() const {
  return static_cast< TransState >(currstate_);
}
inline void pbCapRoTsl::set_currstate(TransState value) {
  GOOGLE_DCHECK(TransState_IsValid(value));
  set_has_currstate();
  currstate_ = value;
}

// optional .pbConnectArgData connectArg = 57;
inline bool pbCapRoTsl::has_connectarg() const {
  return (_has_bits_[1] & 0x01000000u) != 0;
}
inline void pbCapRoTsl::set_has_connectarg() {
  _has_bits_[1] |= 0x01000000u;
}
inline void pbCapRoTsl::clear_has_connectarg() {
  _has_bits_[1] &= ~0x01000000u;
}
inline void pbCapRoTsl::clear_connectarg() {
  if (connectarg_ != NULL) connectarg_->::pbConnectArgData::Clear();
  clear_has_connectarg();
}
inline const ::pbConnectArgData& pbCapRoTsl::connectarg() const {
  return connectarg_ != NULL ? *connectarg_ : *default_instance_->connectarg_;
}
inline ::pbConnectArgData* pbCapRoTsl::mutable_connectarg() {
  set_has_connectarg();
  if (connectarg_ == NULL) connectarg_ = new ::pbConnectArgData;
  return connectarg_;
}
inline ::pbConnectArgData* pbCapRoTsl::release_connectarg() {
  clear_has_connectarg();
  ::pbConnectArgData* temp = connectarg_;
  connectarg_ = NULL;
  return temp;
}

// optional .pbACHData achdata = 58;
inline bool pbCapRoTsl::has_achdata() const {
  return (_has_bits_[1] & 0x02000000u) != 0;
}
inline void pbCapRoTsl::set_has_achdata() {
  _has_bits_[1] |= 0x02000000u;
}
inline void pbCapRoTsl::clear_has_achdata() {
  _has_bits_[1] &= ~0x02000000u;
}
inline void pbCapRoTsl::clear_achdata() {
  if (achdata_ != NULL) achdata_->::pbACHData::Clear();
  clear_has_achdata();
}
inline const ::pbACHData& pbCapRoTsl::achdata() const {
  return achdata_ != NULL ? *achdata_ : *default_instance_->achdata_;
}
inline ::pbACHData* pbCapRoTsl::mutable_achdata() {
  set_has_achdata();
  if (achdata_ == NULL) achdata_ = new ::pbACHData;
  return achdata_;
}
inline ::pbACHData* pbCapRoTsl::release_achdata() {
  clear_has_achdata();
  ::pbACHData* temp = achdata_;
  achdata_ = NULL;
  return temp;
}

// optional uint32 disconTriggerTimeStamp = 59;
inline bool pbCapRoTsl::has_discontriggertimestamp() const {
  return (_has_bits_[1] & 0x04000000u) != 0;
}
inline void pbCapRoTsl::set_has_discontriggertimestamp() {
  _has_bits_[1] |= 0x04000000u;
}
inline void pbCapRoTsl::clear_has_discontriggertimestamp() {
  _has_bits_[1] &= ~0x04000000u;
}
inline void pbCapRoTsl::clear_discontriggertimestamp() {
  discontriggertimestamp_ = 0u;
  clear_has_discontriggertimestamp();
}
inline ::google::protobuf::uint32 pbCapRoTsl::discontriggertimestamp() const {
  return discontriggertimestamp_;
}
inline void pbCapRoTsl::set_discontriggertimestamp(::google::protobuf::uint32 value) {
  set_has_discontriggertimestamp();
  discontriggertimestamp_ = value;
}

// optional fixed32 ccfhFailedoverReason = 60 [default = 0];
inline bool pbCapRoTsl::has_ccfhfailedoverreason() const {
  return (_has_bits_[1] & 0x08000000u) != 0;
}
inline void pbCapRoTsl::set_has_ccfhfailedoverreason() {
  _has_bits_[1] |= 0x08000000u;
}
inline void pbCapRoTsl::clear_has_ccfhfailedoverreason() {
  _has_bits_[1] &= ~0x08000000u;
}
inline void pbCapRoTsl::clear_ccfhfailedoverreason() {
  ccfhfailedoverreason_ = 0u;
  clear_has_ccfhfailedoverreason();
}
inline ::google::protobuf::uint32 pbCapRoTsl::ccfhfailedoverreason() const {
  return ccfhfailedoverreason_;
}
inline void pbCapRoTsl::set_ccfhfailedoverreason(::google::protobuf::uint32 value) {
  set_has_ccfhfailedoverreason();
  ccfhfailedoverreason_ = value;
}

// optional uint32 triggerFollowOnSession = 61 [default = 1];
inline bool pbCapRoTsl::has_triggerfollowonsession() const {
  return (_has_bits_[1] & 0x10000000u) != 0;
}
inline void pbCapRoTsl::set_has_triggerfollowonsession() {
  _has_bits_[1] |= 0x10000000u;
}
inline void pbCapRoTsl::clear_has_triggerfollowonsession() {
  _has_bits_[1] &= ~0x10000000u;
}
inline void pbCapRoTsl::clear_triggerfollowonsession() {
  triggerfollowonsession_ = 1u;
  clear_has_triggerfollowonsession();
}
inline ::google::protobuf::uint32 pbCapRoTsl::triggerfollowonsession() const {
  return triggerfollowonsession_;
}
inline void pbCapRoTsl::set_triggerfollowonsession(::google::protobuf::uint32 value) {
  set_has_triggerfollowonsession();
  triggerfollowonsession_ = value;
}

// optional uint32 updateTriggerTimeStamp = 62;
inline bool pbCapRoTsl::has_updatetriggertimestamp() const {
  return (_has_bits_[1] & 0x20000000u) != 0;
}
inline void pbCapRoTsl::set_has_updatetriggertimestamp() {
  _has_bits_[1] |= 0x20000000u;
}
inline void pbCapRoTsl::clear_has_updatetriggertimestamp() {
  _has_bits_[1] &= ~0x20000000u;
}
inline void pbCapRoTsl::clear_updatetriggertimestamp() {
  updatetriggertimestamp_ = 0u;
  clear_has_updatetriggertimestamp();
}
inline ::google::protobuf::uint32 pbCapRoTsl::updatetriggertimestamp() const {
  return updatetriggertimestamp_;
}
inline void pbCapRoTsl::set_updatetriggertimestamp(::google::protobuf::uint32 value) {
  set_has_updatetriggertimestamp();
  updatetriggertimestamp_ = value;
}

// optional bool IsCCRTBuiltForInvalidCCAI = 63 [default = false];
inline bool pbCapRoTsl::has_isccrtbuiltforinvalidccai() const {
  return (_has_bits_[1] & 0x40000000u) != 0;
}
inline void pbCapRoTsl::set_has_isccrtbuiltforinvalidccai() {
  _has_bits_[1] |= 0x40000000u;
}
inline void pbCapRoTsl::clear_has_isccrtbuiltforinvalidccai() {
  _has_bits_[1] &= ~0x40000000u;
}
inline void pbCapRoTsl::clear_isccrtbuiltforinvalidccai() {
  isccrtbuiltforinvalidccai_ = false;
  clear_has_isccrtbuiltforinvalidccai();
}
inline bool pbCapRoTsl::isccrtbuiltforinvalidccai() const {
  return isccrtbuiltforinvalidccai_;
}
inline void pbCapRoTsl::set_isccrtbuiltforinvalidccai(bool value) {
  set_has_isccrtbuiltforinvalidccai();
  isccrtbuiltforinvalidccai_ = value;
}

// -------------------------------------------------------------------

// pbStoredUserData

// optional .pbCapRoTsl caprotsl = 1;
inline bool pbStoredUserData::has_caprotsl() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pbStoredUserData::set_has_caprotsl() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pbStoredUserData::clear_has_caprotsl() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pbStoredUserData::clear_caprotsl() {
  if (caprotsl_ != NULL) caprotsl_->::pbCapRoTsl::Clear();
  clear_has_caprotsl();
}
inline const ::pbCapRoTsl& pbStoredUserData::caprotsl() const {
  return caprotsl_ != NULL ? *caprotsl_ : *default_instance_->caprotsl_;
}
inline ::pbCapRoTsl* pbStoredUserData::mutable_caprotsl() {
  set_has_caprotsl();
  if (caprotsl_ == NULL) caprotsl_ = new ::pbCapRoTsl;
  return caprotsl_;
}
inline ::pbCapRoTsl* pbStoredUserData::release_caprotsl() {
  clear_has_caprotsl();
  ::pbCapRoTsl* temp = caprotsl_;
  caprotsl_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// pbIwfTimerData

// optional .pbIwfTimerData.ETimerType m_eTimerType = 1;
inline bool pbIwfTimerData::has_m_etimertype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pbIwfTimerData::set_has_m_etimertype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pbIwfTimerData::clear_has_m_etimertype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pbIwfTimerData::clear_m_etimertype() {
  m_etimertype_ = 1;
  clear_has_m_etimertype();
}
inline ::pbIwfTimerData_ETimerType pbIwfTimerData::m_etimertype() const {
  return static_cast< ::pbIwfTimerData_ETimerType >(m_etimertype_);
}
inline void pbIwfTimerData::set_m_etimertype(::pbIwfTimerData_ETimerType value) {
  GOOGLE_DCHECK(::pbIwfTimerData_ETimerType_IsValid(value));
  set_has_m_etimertype();
  m_etimertype_ = value;
}

// optional .pbIwfTimerData.EKeyType m_eKeyType = 2;
inline bool pbIwfTimerData::has_m_ekeytype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pbIwfTimerData::set_has_m_ekeytype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pbIwfTimerData::clear_has_m_ekeytype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pbIwfTimerData::clear_m_ekeytype() {
  m_ekeytype_ = -1;
  clear_has_m_ekeytype();
}
inline ::pbIwfTimerData_EKeyType pbIwfTimerData::m_ekeytype() const {
  return static_cast< ::pbIwfTimerData_EKeyType >(m_ekeytype_);
}
inline void pbIwfTimerData::set_m_ekeytype(::pbIwfTimerData_EKeyType value) {
  GOOGLE_DCHECK(::pbIwfTimerData_EKeyType_IsValid(value));
  set_has_m_ekeytype();
  m_ekeytype_ = value;
}

// optional fixed32 m_tStartTime = 3;
inline bool pbIwfTimerData::has_m_tstarttime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void pbIwfTimerData::set_has_m_tstarttime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void pbIwfTimerData::clear_has_m_tstarttime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void pbIwfTimerData::clear_m_tstarttime() {
  m_tstarttime_ = 0u;
  clear_has_m_tstarttime();
}
inline ::google::protobuf::uint32 pbIwfTimerData::m_tstarttime() const {
  return m_tstarttime_;
}
inline void pbIwfTimerData::set_m_tstarttime(::google::protobuf::uint32 value) {
  set_has_m_tstarttime();
  m_tstarttime_ = value;
}

// optional uint32 m_uiDuration = 4;
inline bool pbIwfTimerData::has_m_uiduration() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void pbIwfTimerData::set_has_m_uiduration() {
  _has_bits_[0] |= 0x00000008u;
}
inline void pbIwfTimerData::clear_has_m_uiduration() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void pbIwfTimerData::clear_m_uiduration() {
  m_uiduration_ = 0u;
  clear_has_m_uiduration();
}
inline ::google::protobuf::uint32 pbIwfTimerData::m_uiduration() const {
  return m_uiduration_;
}
inline void pbIwfTimerData::set_m_uiduration(::google::protobuf::uint32 value) {
  set_has_m_uiduration();
  m_uiduration_ = value;
}

// optional uint32 m_uiTimerId = 5;
inline bool pbIwfTimerData::has_m_uitimerid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void pbIwfTimerData::set_has_m_uitimerid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void pbIwfTimerData::clear_has_m_uitimerid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void pbIwfTimerData::clear_m_uitimerid() {
  m_uitimerid_ = 0u;
  clear_has_m_uitimerid();
}
inline ::google::protobuf::uint32 pbIwfTimerData::m_uitimerid() const {
  return m_uitimerid_;
}
inline void pbIwfTimerData::set_m_uitimerid(::google::protobuf::uint32 value) {
  set_has_m_uitimerid();
  m_uitimerid_ = value;
}

// -------------------------------------------------------------------

// pbSCCP_ADDR

// optional bytes addr = 1;
inline bool pbSCCP_ADDR::has_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pbSCCP_ADDR::set_has_addr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pbSCCP_ADDR::clear_has_addr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pbSCCP_ADDR::clear_addr() {
  if (addr_ != &::google::protobuf::internal::kEmptyString) {
    addr_->clear();
  }
  clear_has_addr();
}
inline const ::std::string& pbSCCP_ADDR::addr() const {
  return *addr_;
}
inline void pbSCCP_ADDR::set_addr(const ::std::string& value) {
  set_has_addr();
  if (addr_ == &::google::protobuf::internal::kEmptyString) {
    addr_ = new ::std::string;
  }
  addr_->assign(value);
}
inline void pbSCCP_ADDR::set_addr(const char* value) {
  set_has_addr();
  if (addr_ == &::google::protobuf::internal::kEmptyString) {
    addr_ = new ::std::string;
  }
  addr_->assign(value);
}
inline void pbSCCP_ADDR::set_addr(const void* value, size_t size) {
  set_has_addr();
  if (addr_ == &::google::protobuf::internal::kEmptyString) {
    addr_ = new ::std::string;
  }
  addr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbSCCP_ADDR::mutable_addr() {
  set_has_addr();
  if (addr_ == &::google::protobuf::internal::kEmptyString) {
    addr_ = new ::std::string;
  }
  return addr_;
}
inline ::std::string* pbSCCP_ADDR::release_addr() {
  clear_has_addr();
  if (addr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = addr_;
    addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 length = 2;
inline bool pbSCCP_ADDR::has_length() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pbSCCP_ADDR::set_has_length() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pbSCCP_ADDR::clear_has_length() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pbSCCP_ADDR::clear_length() {
  length_ = 0u;
  clear_has_length();
}
inline ::google::protobuf::uint32 pbSCCP_ADDR::length() const {
  return length_;
}
inline void pbSCCP_ADDR::set_length(::google::protobuf::uint32 value) {
  set_has_length();
  length_ = value;
}

// -------------------------------------------------------------------

// pbMtp3_Header

// optional uint32 sio = 1;
inline bool pbMtp3_Header::has_sio() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pbMtp3_Header::set_has_sio() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pbMtp3_Header::clear_has_sio() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pbMtp3_Header::clear_sio() {
  sio_ = 0u;
  clear_has_sio();
}
inline ::google::protobuf::uint32 pbMtp3_Header::sio() const {
  return sio_;
}
inline void pbMtp3_Header::set_sio(::google::protobuf::uint32 value) {
  set_has_sio();
  sio_ = value;
}

// optional string label = 2;
inline bool pbMtp3_Header::has_label() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pbMtp3_Header::set_has_label() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pbMtp3_Header::clear_has_label() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pbMtp3_Header::clear_label() {
  if (label_ != &::google::protobuf::internal::kEmptyString) {
    label_->clear();
  }
  clear_has_label();
}
inline const ::std::string& pbMtp3_Header::label() const {
  return *label_;
}
inline void pbMtp3_Header::set_label(const ::std::string& value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(value);
}
inline void pbMtp3_Header::set_label(const char* value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(value);
}
inline void pbMtp3_Header::set_label(const char* value, size_t size) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbMtp3_Header::mutable_label() {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  return label_;
}
inline ::std::string* pbMtp3_Header::release_label() {
  clear_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = label_;
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// pbTcapTransactionData

// optional uint32 lTid = 1;
inline bool pbTcapTransactionData::has_ltid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pbTcapTransactionData::set_has_ltid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pbTcapTransactionData::clear_has_ltid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pbTcapTransactionData::clear_ltid() {
  ltid_ = 0u;
  clear_has_ltid();
}
inline ::google::protobuf::uint32 pbTcapTransactionData::ltid() const {
  return ltid_;
}
inline void pbTcapTransactionData::set_ltid(::google::protobuf::uint32 value) {
  set_has_ltid();
  ltid_ = value;
}

// optional uint32 rTid = 2;
inline bool pbTcapTransactionData::has_rtid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pbTcapTransactionData::set_has_rtid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pbTcapTransactionData::clear_has_rtid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pbTcapTransactionData::clear_rtid() {
  rtid_ = 0u;
  clear_has_rtid();
}
inline ::google::protobuf::uint32 pbTcapTransactionData::rtid() const {
  return rtid_;
}
inline void pbTcapTransactionData::set_rtid(::google::protobuf::uint32 value) {
  set_has_rtid();
  rtid_ = value;
}

// optional .pbSCCP_ADDR oaddr = 3;
inline bool pbTcapTransactionData::has_oaddr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void pbTcapTransactionData::set_has_oaddr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void pbTcapTransactionData::clear_has_oaddr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void pbTcapTransactionData::clear_oaddr() {
  if (oaddr_ != NULL) oaddr_->::pbSCCP_ADDR::Clear();
  clear_has_oaddr();
}
inline const ::pbSCCP_ADDR& pbTcapTransactionData::oaddr() const {
  return oaddr_ != NULL ? *oaddr_ : *default_instance_->oaddr_;
}
inline ::pbSCCP_ADDR* pbTcapTransactionData::mutable_oaddr() {
  set_has_oaddr();
  if (oaddr_ == NULL) oaddr_ = new ::pbSCCP_ADDR;
  return oaddr_;
}
inline ::pbSCCP_ADDR* pbTcapTransactionData::release_oaddr() {
  clear_has_oaddr();
  ::pbSCCP_ADDR* temp = oaddr_;
  oaddr_ = NULL;
  return temp;
}

// optional .pbSCCP_ADDR daddr = 4;
inline bool pbTcapTransactionData::has_daddr() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void pbTcapTransactionData::set_has_daddr() {
  _has_bits_[0] |= 0x00000008u;
}
inline void pbTcapTransactionData::clear_has_daddr() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void pbTcapTransactionData::clear_daddr() {
  if (daddr_ != NULL) daddr_->::pbSCCP_ADDR::Clear();
  clear_has_daddr();
}
inline const ::pbSCCP_ADDR& pbTcapTransactionData::daddr() const {
  return daddr_ != NULL ? *daddr_ : *default_instance_->daddr_;
}
inline ::pbSCCP_ADDR* pbTcapTransactionData::mutable_daddr() {
  set_has_daddr();
  if (daddr_ == NULL) daddr_ = new ::pbSCCP_ADDR;
  return daddr_;
}
inline ::pbSCCP_ADDR* pbTcapTransactionData::release_daddr() {
  clear_has_daddr();
  ::pbSCCP_ADDR* temp = daddr_;
  daddr_ = NULL;
  return temp;
}

// optional .pbMtp3_Header label = 5;
inline bool pbTcapTransactionData::has_label() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void pbTcapTransactionData::set_has_label() {
  _has_bits_[0] |= 0x00000010u;
}
inline void pbTcapTransactionData::clear_has_label() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void pbTcapTransactionData::clear_label() {
  if (label_ != NULL) label_->::pbMtp3_Header::Clear();
  clear_has_label();
}
inline const ::pbMtp3_Header& pbTcapTransactionData::label() const {
  return label_ != NULL ? *label_ : *default_instance_->label_;
}
inline ::pbMtp3_Header* pbTcapTransactionData::mutable_label() {
  set_has_label();
  if (label_ == NULL) label_ = new ::pbMtp3_Header;
  return label_;
}
inline ::pbMtp3_Header* pbTcapTransactionData::release_label() {
  clear_has_label();
  ::pbMtp3_Header* temp = label_;
  label_ = NULL;
  return temp;
}

// optional .QualityOfService qos = 6;
inline bool pbTcapTransactionData::has_qos() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void pbTcapTransactionData::set_has_qos() {
  _has_bits_[0] |= 0x00000020u;
}
inline void pbTcapTransactionData::clear_has_qos() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void pbTcapTransactionData::clear_qos() {
  if (qos_ != NULL) qos_->::QualityOfService::Clear();
  clear_has_qos();
}
inline const ::QualityOfService& pbTcapTransactionData::qos() const {
  return qos_ != NULL ? *qos_ : *default_instance_->qos_;
}
inline ::QualityOfService* pbTcapTransactionData::mutable_qos() {
  set_has_qos();
  if (qos_ == NULL) qos_ = new ::QualityOfService;
  return qos_;
}
inline ::QualityOfService* pbTcapTransactionData::release_qos() {
  clear_has_qos();
  ::QualityOfService* temp = qos_;
  qos_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// pbDiameterSessionData

// optional uint32 peerInst = 1;
inline bool pbDiameterSessionData::has_peerinst() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pbDiameterSessionData::set_has_peerinst() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pbDiameterSessionData::clear_has_peerinst() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pbDiameterSessionData::clear_peerinst() {
  peerinst_ = 0u;
  clear_has_peerinst();
}
inline ::google::protobuf::uint32 pbDiameterSessionData::peerinst() const {
  return peerinst_;
}
inline void pbDiameterSessionData::set_peerinst(::google::protobuf::uint32 value) {
  set_has_peerinst();
  peerinst_ = value;
}

// optional uint32 timeout = 2;
inline bool pbDiameterSessionData::has_timeout() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pbDiameterSessionData::set_has_timeout() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pbDiameterSessionData::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pbDiameterSessionData::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 pbDiameterSessionData::timeout() const {
  return timeout_;
}
inline void pbDiameterSessionData::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
}

// optional uint32 lifetime = 3;
inline bool pbDiameterSessionData::has_lifetime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void pbDiameterSessionData::set_has_lifetime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void pbDiameterSessionData::clear_has_lifetime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void pbDiameterSessionData::clear_lifetime() {
  lifetime_ = 0u;
  clear_has_lifetime();
}
inline ::google::protobuf::uint32 pbDiameterSessionData::lifetime() const {
  return lifetime_;
}
inline void pbDiameterSessionData::set_lifetime(::google::protobuf::uint32 value) {
  set_has_lifetime();
  lifetime_ = value;
}

// optional uint32 gracePeriod = 4;
inline bool pbDiameterSessionData::has_graceperiod() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void pbDiameterSessionData::set_has_graceperiod() {
  _has_bits_[0] |= 0x00000008u;
}
inline void pbDiameterSessionData::clear_has_graceperiod() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void pbDiameterSessionData::clear_graceperiod() {
  graceperiod_ = 0u;
  clear_has_graceperiod();
}
inline ::google::protobuf::uint32 pbDiameterSessionData::graceperiod() const {
  return graceperiod_;
}
inline void pbDiameterSessionData::set_graceperiod(::google::protobuf::uint32 value) {
  set_has_graceperiod();
  graceperiod_ = value;
}

// -------------------------------------------------------------------

// pbIwfFsmInfo

// required .pbState current = 1;
inline bool pbIwfFsmInfo::has_current() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pbIwfFsmInfo::set_has_current() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pbIwfFsmInfo::clear_has_current() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pbIwfFsmInfo::clear_current() {
  if (current_ != NULL) current_->::pbState::Clear();
  clear_has_current();
}
inline const ::pbState& pbIwfFsmInfo::current() const {
  return current_ != NULL ? *current_ : *default_instance_->current_;
}
inline ::pbState* pbIwfFsmInfo::mutable_current() {
  set_has_current();
  if (current_ == NULL) current_ = new ::pbState;
  return current_;
}
inline ::pbState* pbIwfFsmInfo::release_current() {
  clear_has_current();
  ::pbState* temp = current_;
  current_ = NULL;
  return temp;
}

// required .pbState prevState = 2;
inline bool pbIwfFsmInfo::has_prevstate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pbIwfFsmInfo::set_has_prevstate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pbIwfFsmInfo::clear_has_prevstate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pbIwfFsmInfo::clear_prevstate() {
  if (prevstate_ != NULL) prevstate_->::pbState::Clear();
  clear_has_prevstate();
}
inline const ::pbState& pbIwfFsmInfo::prevstate() const {
  return prevstate_ != NULL ? *prevstate_ : *default_instance_->prevstate_;
}
inline ::pbState* pbIwfFsmInfo::mutable_prevstate() {
  set_has_prevstate();
  if (prevstate_ == NULL) prevstate_ = new ::pbState;
  return prevstate_;
}
inline ::pbState* pbIwfFsmInfo::release_prevstate() {
  clear_has_prevstate();
  ::pbState* temp = prevstate_;
  prevstate_ = NULL;
  return temp;
}

// optional .pbProtocol UpstrmReqProtocol = 3 [default = DIAMETER_S6A];
inline bool pbIwfFsmInfo::has_upstrmreqprotocol() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void pbIwfFsmInfo::set_has_upstrmreqprotocol() {
  _has_bits_[0] |= 0x00000004u;
}
inline void pbIwfFsmInfo::clear_has_upstrmreqprotocol() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void pbIwfFsmInfo::clear_upstrmreqprotocol() {
  upstrmreqprotocol_ = 0;
  clear_has_upstrmreqprotocol();
}
inline pbProtocol pbIwfFsmInfo::upstrmreqprotocol() const {
  return static_cast< pbProtocol >(upstrmreqprotocol_);
}
inline void pbIwfFsmInfo::set_upstrmreqprotocol(pbProtocol value) {
  GOOGLE_DCHECK(pbProtocol_IsValid(value));
  set_has_upstrmreqprotocol();
  upstrmreqprotocol_ = value;
}

// optional .pbProtocol DnstrmReqProtocol = 4 [default = MAP_GR];
inline bool pbIwfFsmInfo::has_dnstrmreqprotocol() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void pbIwfFsmInfo::set_has_dnstrmreqprotocol() {
  _has_bits_[0] |= 0x00000008u;
}
inline void pbIwfFsmInfo::clear_has_dnstrmreqprotocol() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void pbIwfFsmInfo::clear_dnstrmreqprotocol() {
  dnstrmreqprotocol_ = 2;
  clear_has_dnstrmreqprotocol();
}
inline pbProtocol pbIwfFsmInfo::dnstrmreqprotocol() const {
  return static_cast< pbProtocol >(dnstrmreqprotocol_);
}
inline void pbIwfFsmInfo::set_dnstrmreqprotocol(pbProtocol value) {
  GOOGLE_DCHECK(pbProtocol_IsValid(value));
  set_has_dnstrmreqprotocol();
  dnstrmreqprotocol_ = value;
}

// optional uint32 diasessionIdx = 5 [default = 0];
inline bool pbIwfFsmInfo::has_diasessionidx() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void pbIwfFsmInfo::set_has_diasessionidx() {
  _has_bits_[0] |= 0x00000010u;
}
inline void pbIwfFsmInfo::clear_has_diasessionidx() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void pbIwfFsmInfo::clear_diasessionidx() {
  diasessionidx_ = 0u;
  clear_has_diasessionidx();
}
inline ::google::protobuf::uint32 pbIwfFsmInfo::diasessionidx() const {
  return diasessionidx_;
}
inline void pbIwfFsmInfo::set_diasessionidx(::google::protobuf::uint32 value) {
  set_has_diasessionidx();
  diasessionidx_ = value;
}

// required string diaSessionId = 6 [default = ""];
inline bool pbIwfFsmInfo::has_diasessionid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void pbIwfFsmInfo::set_has_diasessionid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void pbIwfFsmInfo::clear_has_diasessionid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void pbIwfFsmInfo::clear_diasessionid() {
  if (diasessionid_ != &::google::protobuf::internal::kEmptyString) {
    diasessionid_->clear();
  }
  clear_has_diasessionid();
}
inline const ::std::string& pbIwfFsmInfo::diasessionid() const {
  return *diasessionid_;
}
inline void pbIwfFsmInfo::set_diasessionid(const ::std::string& value) {
  set_has_diasessionid();
  if (diasessionid_ == &::google::protobuf::internal::kEmptyString) {
    diasessionid_ = new ::std::string;
  }
  diasessionid_->assign(value);
}
inline void pbIwfFsmInfo::set_diasessionid(const char* value) {
  set_has_diasessionid();
  if (diasessionid_ == &::google::protobuf::internal::kEmptyString) {
    diasessionid_ = new ::std::string;
  }
  diasessionid_->assign(value);
}
inline void pbIwfFsmInfo::set_diasessionid(const char* value, size_t size) {
  set_has_diasessionid();
  if (diasessionid_ == &::google::protobuf::internal::kEmptyString) {
    diasessionid_ = new ::std::string;
  }
  diasessionid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbIwfFsmInfo::mutable_diasessionid() {
  set_has_diasessionid();
  if (diasessionid_ == &::google::protobuf::internal::kEmptyString) {
    diasessionid_ = new ::std::string;
  }
  return diasessionid_;
}
inline ::std::string* pbIwfFsmInfo::release_diasessionid() {
  clear_has_diasessionid();
  if (diasessionid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = diasessionid_;
    diasessionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required uint32 tcapDialogueId = 7 [default = 0];
inline bool pbIwfFsmInfo::has_tcapdialogueid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void pbIwfFsmInfo::set_has_tcapdialogueid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void pbIwfFsmInfo::clear_has_tcapdialogueid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void pbIwfFsmInfo::clear_tcapdialogueid() {
  tcapdialogueid_ = 0u;
  clear_has_tcapdialogueid();
}
inline ::google::protobuf::uint32 pbIwfFsmInfo::tcapdialogueid() const {
  return tcapdialogueid_;
}
inline void pbIwfFsmInfo::set_tcapdialogueid(::google::protobuf::uint32 value) {
  set_has_tcapdialogueid();
  tcapdialogueid_ = value;
}

// optional .pbDiaMsg currRcvdDiaMsg = 8;
inline bool pbIwfFsmInfo::has_currrcvddiamsg() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void pbIwfFsmInfo::set_has_currrcvddiamsg() {
  _has_bits_[0] |= 0x00000080u;
}
inline void pbIwfFsmInfo::clear_has_currrcvddiamsg() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void pbIwfFsmInfo::clear_currrcvddiamsg() {
  if (currrcvddiamsg_ != NULL) currrcvddiamsg_->::pbDiaMsg::Clear();
  clear_has_currrcvddiamsg();
}
inline const ::pbDiaMsg& pbIwfFsmInfo::currrcvddiamsg() const {
  return currrcvddiamsg_ != NULL ? *currrcvddiamsg_ : *default_instance_->currrcvddiamsg_;
}
inline ::pbDiaMsg* pbIwfFsmInfo::mutable_currrcvddiamsg() {
  set_has_currrcvddiamsg();
  if (currrcvddiamsg_ == NULL) currrcvddiamsg_ = new ::pbDiaMsg;
  return currrcvddiamsg_;
}
inline ::pbDiaMsg* pbIwfFsmInfo::release_currrcvddiamsg() {
  clear_has_currrcvddiamsg();
  ::pbDiaMsg* temp = currrcvddiamsg_;
  currrcvddiamsg_ = NULL;
  return temp;
}

// optional .pbTcapDialogue currRcvdTcapDlg = 9;
inline bool pbIwfFsmInfo::has_currrcvdtcapdlg() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void pbIwfFsmInfo::set_has_currrcvdtcapdlg() {
  _has_bits_[0] |= 0x00000100u;
}
inline void pbIwfFsmInfo::clear_has_currrcvdtcapdlg() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void pbIwfFsmInfo::clear_currrcvdtcapdlg() {
  if (currrcvdtcapdlg_ != NULL) currrcvdtcapdlg_->::pbTcapDialogue::Clear();
  clear_has_currrcvdtcapdlg();
}
inline const ::pbTcapDialogue& pbIwfFsmInfo::currrcvdtcapdlg() const {
  return currrcvdtcapdlg_ != NULL ? *currrcvdtcapdlg_ : *default_instance_->currrcvdtcapdlg_;
}
inline ::pbTcapDialogue* pbIwfFsmInfo::mutable_currrcvdtcapdlg() {
  set_has_currrcvdtcapdlg();
  if (currrcvdtcapdlg_ == NULL) currrcvdtcapdlg_ = new ::pbTcapDialogue;
  return currrcvdtcapdlg_;
}
inline ::pbTcapDialogue* pbIwfFsmInfo::release_currrcvdtcapdlg() {
  clear_has_currrcvdtcapdlg();
  ::pbTcapDialogue* temp = currrcvdtcapdlg_;
  currrcvdtcapdlg_ = NULL;
  return temp;
}

// optional .pbTcapComponent currRcvdTcapCpt = 10;
inline bool pbIwfFsmInfo::has_currrcvdtcapcpt() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void pbIwfFsmInfo::set_has_currrcvdtcapcpt() {
  _has_bits_[0] |= 0x00000200u;
}
inline void pbIwfFsmInfo::clear_has_currrcvdtcapcpt() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void pbIwfFsmInfo::clear_currrcvdtcapcpt() {
  if (currrcvdtcapcpt_ != NULL) currrcvdtcapcpt_->::pbTcapComponent::Clear();
  clear_has_currrcvdtcapcpt();
}
inline const ::pbTcapComponent& pbIwfFsmInfo::currrcvdtcapcpt() const {
  return currrcvdtcapcpt_ != NULL ? *currrcvdtcapcpt_ : *default_instance_->currrcvdtcapcpt_;
}
inline ::pbTcapComponent* pbIwfFsmInfo::mutable_currrcvdtcapcpt() {
  set_has_currrcvdtcapcpt();
  if (currrcvdtcapcpt_ == NULL) currrcvdtcapcpt_ = new ::pbTcapComponent;
  return currrcvdtcapcpt_;
}
inline ::pbTcapComponent* pbIwfFsmInfo::release_currrcvdtcapcpt() {
  clear_has_currrcvdtcapcpt();
  ::pbTcapComponent* temp = currrcvdtcapcpt_;
  currrcvdtcapcpt_ = NULL;
  return temp;
}

// optional .pbTcapBeginDialogue currTcapBeginDlg = 11;
inline bool pbIwfFsmInfo::has_currtcapbegindlg() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void pbIwfFsmInfo::set_has_currtcapbegindlg() {
  _has_bits_[0] |= 0x00000400u;
}
inline void pbIwfFsmInfo::clear_has_currtcapbegindlg() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void pbIwfFsmInfo::clear_currtcapbegindlg() {
  if (currtcapbegindlg_ != NULL) currtcapbegindlg_->::pbTcapBeginDialogue::Clear();
  clear_has_currtcapbegindlg();
}
inline const ::pbTcapBeginDialogue& pbIwfFsmInfo::currtcapbegindlg() const {
  return currtcapbegindlg_ != NULL ? *currtcapbegindlg_ : *default_instance_->currtcapbegindlg_;
}
inline ::pbTcapBeginDialogue* pbIwfFsmInfo::mutable_currtcapbegindlg() {
  set_has_currtcapbegindlg();
  if (currtcapbegindlg_ == NULL) currtcapbegindlg_ = new ::pbTcapBeginDialogue;
  return currtcapbegindlg_;
}
inline ::pbTcapBeginDialogue* pbIwfFsmInfo::release_currtcapbegindlg() {
  clear_has_currtcapbegindlg();
  ::pbTcapBeginDialogue* temp = currtcapbegindlg_;
  currtcapbegindlg_ = NULL;
  return temp;
}

// optional bool isCurrSendErr = 12;
inline bool pbIwfFsmInfo::has_iscurrsenderr() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void pbIwfFsmInfo::set_has_iscurrsenderr() {
  _has_bits_[0] |= 0x00000800u;
}
inline void pbIwfFsmInfo::clear_has_iscurrsenderr() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void pbIwfFsmInfo::clear_iscurrsenderr() {
  iscurrsenderr_ = false;
  clear_has_iscurrsenderr();
}
inline bool pbIwfFsmInfo::iscurrsenderr() const {
  return iscurrsenderr_;
}
inline void pbIwfFsmInfo::set_iscurrsenderr(bool value) {
  set_has_iscurrsenderr();
  iscurrsenderr_ = value;
}

// optional .pbStoredUserData userData = 13;
inline bool pbIwfFsmInfo::has_userdata() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void pbIwfFsmInfo::set_has_userdata() {
  _has_bits_[0] |= 0x00001000u;
}
inline void pbIwfFsmInfo::clear_has_userdata() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void pbIwfFsmInfo::clear_userdata() {
  if (userdata_ != NULL) userdata_->::pbStoredUserData::Clear();
  clear_has_userdata();
}
inline const ::pbStoredUserData& pbIwfFsmInfo::userdata() const {
  return userdata_ != NULL ? *userdata_ : *default_instance_->userdata_;
}
inline ::pbStoredUserData* pbIwfFsmInfo::mutable_userdata() {
  set_has_userdata();
  if (userdata_ == NULL) userdata_ = new ::pbStoredUserData;
  return userdata_;
}
inline ::pbStoredUserData* pbIwfFsmInfo::release_userdata() {
  clear_has_userdata();
  ::pbStoredUserData* temp = userdata_;
  userdata_ = NULL;
  return temp;
}

// optional int32 errCode = 14 [default = 0];
inline bool pbIwfFsmInfo::has_errcode() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void pbIwfFsmInfo::set_has_errcode() {
  _has_bits_[0] |= 0x00002000u;
}
inline void pbIwfFsmInfo::clear_has_errcode() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void pbIwfFsmInfo::clear_errcode() {
  errcode_ = 0;
  clear_has_errcode();
}
inline ::google::protobuf::int32 pbIwfFsmInfo::errcode() const {
  return errcode_;
}
inline void pbIwfFsmInfo::set_errcode(::google::protobuf::int32 value) {
  set_has_errcode();
  errcode_ = value;
}

// optional string username = 15;
inline bool pbIwfFsmInfo::has_username() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void pbIwfFsmInfo::set_has_username() {
  _has_bits_[0] |= 0x00004000u;
}
inline void pbIwfFsmInfo::clear_has_username() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void pbIwfFsmInfo::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& pbIwfFsmInfo::username() const {
  return *username_;
}
inline void pbIwfFsmInfo::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void pbIwfFsmInfo::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void pbIwfFsmInfo::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbIwfFsmInfo::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* pbIwfFsmInfo::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .pbSCCPParameters sccpParams = 16;
inline bool pbIwfFsmInfo::has_sccpparams() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void pbIwfFsmInfo::set_has_sccpparams() {
  _has_bits_[0] |= 0x00008000u;
}
inline void pbIwfFsmInfo::clear_has_sccpparams() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void pbIwfFsmInfo::clear_sccpparams() {
  if (sccpparams_ != NULL) sccpparams_->::pbSCCPParameters::Clear();
  clear_has_sccpparams();
}
inline const ::pbSCCPParameters& pbIwfFsmInfo::sccpparams() const {
  return sccpparams_ != NULL ? *sccpparams_ : *default_instance_->sccpparams_;
}
inline ::pbSCCPParameters* pbIwfFsmInfo::mutable_sccpparams() {
  set_has_sccpparams();
  if (sccpparams_ == NULL) sccpparams_ = new ::pbSCCPParameters;
  return sccpparams_;
}
inline ::pbSCCPParameters* pbIwfFsmInfo::release_sccpparams() {
  clear_has_sccpparams();
  ::pbSCCPParameters* temp = sccpparams_;
  sccpparams_ = NULL;
  return temp;
}

// optional string sgsnAddress = 17;
inline bool pbIwfFsmInfo::has_sgsnaddress() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void pbIwfFsmInfo::set_has_sgsnaddress() {
  _has_bits_[0] |= 0x00010000u;
}
inline void pbIwfFsmInfo::clear_has_sgsnaddress() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void pbIwfFsmInfo::clear_sgsnaddress() {
  if (sgsnaddress_ != &::google::protobuf::internal::kEmptyString) {
    sgsnaddress_->clear();
  }
  clear_has_sgsnaddress();
}
inline const ::std::string& pbIwfFsmInfo::sgsnaddress() const {
  return *sgsnaddress_;
}
inline void pbIwfFsmInfo::set_sgsnaddress(const ::std::string& value) {
  set_has_sgsnaddress();
  if (sgsnaddress_ == &::google::protobuf::internal::kEmptyString) {
    sgsnaddress_ = new ::std::string;
  }
  sgsnaddress_->assign(value);
}
inline void pbIwfFsmInfo::set_sgsnaddress(const char* value) {
  set_has_sgsnaddress();
  if (sgsnaddress_ == &::google::protobuf::internal::kEmptyString) {
    sgsnaddress_ = new ::std::string;
  }
  sgsnaddress_->assign(value);
}
inline void pbIwfFsmInfo::set_sgsnaddress(const char* value, size_t size) {
  set_has_sgsnaddress();
  if (sgsnaddress_ == &::google::protobuf::internal::kEmptyString) {
    sgsnaddress_ = new ::std::string;
  }
  sgsnaddress_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbIwfFsmInfo::mutable_sgsnaddress() {
  set_has_sgsnaddress();
  if (sgsnaddress_ == &::google::protobuf::internal::kEmptyString) {
    sgsnaddress_ = new ::std::string;
  }
  return sgsnaddress_;
}
inline ::std::string* pbIwfFsmInfo::release_sgsnaddress() {
  clear_has_sgsnaddress();
  if (sgsnaddress_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sgsnaddress_;
    sgsnaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool IsDiaRespSent = 18;
inline bool pbIwfFsmInfo::has_isdiarespsent() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void pbIwfFsmInfo::set_has_isdiarespsent() {
  _has_bits_[0] |= 0x00020000u;
}
inline void pbIwfFsmInfo::clear_has_isdiarespsent() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void pbIwfFsmInfo::clear_isdiarespsent() {
  isdiarespsent_ = false;
  clear_has_isdiarespsent();
}
inline bool pbIwfFsmInfo::isdiarespsent() const {
  return isdiarespsent_;
}
inline void pbIwfFsmInfo::set_isdiarespsent(bool value) {
  set_has_isdiarespsent();
  isdiarespsent_ = value;
}

// optional bool isrouteByGT = 19 [default = false];
inline bool pbIwfFsmInfo::has_isroutebygt() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void pbIwfFsmInfo::set_has_isroutebygt() {
  _has_bits_[0] |= 0x00040000u;
}
inline void pbIwfFsmInfo::clear_has_isroutebygt() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void pbIwfFsmInfo::clear_isroutebygt() {
  isroutebygt_ = false;
  clear_has_isroutebygt();
}
inline bool pbIwfFsmInfo::isroutebygt() const {
  return isroutebygt_;
}
inline void pbIwfFsmInfo::set_isroutebygt(bool value) {
  set_has_isroutebygt();
  isroutebygt_ = value;
}

// optional .pbIwfTranslator translator = 20;
inline bool pbIwfFsmInfo::has_translator() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void pbIwfFsmInfo::set_has_translator() {
  _has_bits_[0] |= 0x00080000u;
}
inline void pbIwfFsmInfo::clear_has_translator() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void pbIwfFsmInfo::clear_translator() {
  if (translator_ != NULL) translator_->::pbIwfTranslator::Clear();
  clear_has_translator();
}
inline const ::pbIwfTranslator& pbIwfFsmInfo::translator() const {
  return translator_ != NULL ? *translator_ : *default_instance_->translator_;
}
inline ::pbIwfTranslator* pbIwfFsmInfo::mutable_translator() {
  set_has_translator();
  if (translator_ == NULL) translator_ = new ::pbIwfTranslator;
  return translator_;
}
inline ::pbIwfTranslator* pbIwfFsmInfo::release_translator() {
  clear_has_translator();
  ::pbIwfTranslator* temp = translator_;
  translator_ = NULL;
  return temp;
}

// optional .pbRoutingLabel routingLabel = 21;
inline bool pbIwfFsmInfo::has_routinglabel() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void pbIwfFsmInfo::set_has_routinglabel() {
  _has_bits_[0] |= 0x00100000u;
}
inline void pbIwfFsmInfo::clear_has_routinglabel() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void pbIwfFsmInfo::clear_routinglabel() {
  if (routinglabel_ != NULL) routinglabel_->::pbRoutingLabel::Clear();
  clear_has_routinglabel();
}
inline const ::pbRoutingLabel& pbIwfFsmInfo::routinglabel() const {
  return routinglabel_ != NULL ? *routinglabel_ : *default_instance_->routinglabel_;
}
inline ::pbRoutingLabel* pbIwfFsmInfo::mutable_routinglabel() {
  set_has_routinglabel();
  if (routinglabel_ == NULL) routinglabel_ = new ::pbRoutingLabel;
  return routinglabel_;
}
inline ::pbRoutingLabel* pbIwfFsmInfo::release_routinglabel() {
  clear_has_routinglabel();
  ::pbRoutingLabel* temp = routinglabel_;
  routinglabel_ = NULL;
  return temp;
}

// optional uint32 invokeId = 22 [default = 0];
inline bool pbIwfFsmInfo::has_invokeid() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void pbIwfFsmInfo::set_has_invokeid() {
  _has_bits_[0] |= 0x00200000u;
}
inline void pbIwfFsmInfo::clear_has_invokeid() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void pbIwfFsmInfo::clear_invokeid() {
  invokeid_ = 0u;
  clear_has_invokeid();
}
inline ::google::protobuf::uint32 pbIwfFsmInfo::invokeid() const {
  return invokeid_;
}
inline void pbIwfFsmInfo::set_invokeid(::google::protobuf::uint32 value) {
  set_has_invokeid();
  invokeid_ = value;
}

// optional .pbSccpAddress selfSccpAddr = 23;
inline bool pbIwfFsmInfo::has_selfsccpaddr() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void pbIwfFsmInfo::set_has_selfsccpaddr() {
  _has_bits_[0] |= 0x00400000u;
}
inline void pbIwfFsmInfo::clear_has_selfsccpaddr() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void pbIwfFsmInfo::clear_selfsccpaddr() {
  if (selfsccpaddr_ != NULL) selfsccpaddr_->::pbSccpAddress::Clear();
  clear_has_selfsccpaddr();
}
inline const ::pbSccpAddress& pbIwfFsmInfo::selfsccpaddr() const {
  return selfsccpaddr_ != NULL ? *selfsccpaddr_ : *default_instance_->selfsccpaddr_;
}
inline ::pbSccpAddress* pbIwfFsmInfo::mutable_selfsccpaddr() {
  set_has_selfsccpaddr();
  if (selfsccpaddr_ == NULL) selfsccpaddr_ = new ::pbSccpAddress;
  return selfsccpaddr_;
}
inline ::pbSccpAddress* pbIwfFsmInfo::release_selfsccpaddr() {
  clear_has_selfsccpaddr();
  ::pbSccpAddress* temp = selfsccpaddr_;
  selfsccpaddr_ = NULL;
  return temp;
}

// optional bool isTcapEnd = 24 [default = false];
inline bool pbIwfFsmInfo::has_istcapend() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void pbIwfFsmInfo::set_has_istcapend() {
  _has_bits_[0] |= 0x00800000u;
}
inline void pbIwfFsmInfo::clear_has_istcapend() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void pbIwfFsmInfo::clear_istcapend() {
  istcapend_ = false;
  clear_has_istcapend();
}
inline bool pbIwfFsmInfo::istcapend() const {
  return istcapend_;
}
inline void pbIwfFsmInfo::set_istcapend(bool value) {
  set_has_istcapend();
  istcapend_ = value;
}

// optional bool startNoEventTimer = 25 [default = false];
inline bool pbIwfFsmInfo::has_startnoeventtimer() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void pbIwfFsmInfo::set_has_startnoeventtimer() {
  _has_bits_[0] |= 0x01000000u;
}
inline void pbIwfFsmInfo::clear_has_startnoeventtimer() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void pbIwfFsmInfo::clear_startnoeventtimer() {
  startnoeventtimer_ = false;
  clear_has_startnoeventtimer();
}
inline bool pbIwfFsmInfo::startnoeventtimer() const {
  return startnoeventtimer_;
}
inline void pbIwfFsmInfo::set_startnoeventtimer(bool value) {
  set_has_startnoeventtimer();
  startnoeventtimer_ = value;
}

// optional bool isFinalUpstrmReqSent = 26;
inline bool pbIwfFsmInfo::has_isfinalupstrmreqsent() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void pbIwfFsmInfo::set_has_isfinalupstrmreqsent() {
  _has_bits_[0] |= 0x02000000u;
}
inline void pbIwfFsmInfo::clear_has_isfinalupstrmreqsent() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void pbIwfFsmInfo::clear_isfinalupstrmreqsent() {
  isfinalupstrmreqsent_ = false;
  clear_has_isfinalupstrmreqsent();
}
inline bool pbIwfFsmInfo::isfinalupstrmreqsent() const {
  return isfinalupstrmreqsent_;
}
inline void pbIwfFsmInfo::set_isfinalupstrmreqsent(bool value) {
  set_has_isfinalupstrmreqsent();
  isfinalupstrmreqsent_ = value;
}

// optional bool markForRollback = 27 [default = false];
inline bool pbIwfFsmInfo::has_markforrollback() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void pbIwfFsmInfo::set_has_markforrollback() {
  _has_bits_[0] |= 0x04000000u;
}
inline void pbIwfFsmInfo::clear_has_markforrollback() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void pbIwfFsmInfo::clear_markforrollback() {
  markforrollback_ = false;
  clear_has_markforrollback();
}
inline bool pbIwfFsmInfo::markforrollback() const {
  return markforrollback_;
}
inline void pbIwfFsmInfo::set_markforrollback(bool value) {
  set_has_markforrollback();
  markforrollback_ = value;
}

// optional bool flowFailure = 28 [default = false];
inline bool pbIwfFsmInfo::has_flowfailure() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void pbIwfFsmInfo::set_has_flowfailure() {
  _has_bits_[0] |= 0x08000000u;
}
inline void pbIwfFsmInfo::clear_has_flowfailure() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void pbIwfFsmInfo::clear_flowfailure() {
  flowfailure_ = false;
  clear_has_flowfailure();
}
inline bool pbIwfFsmInfo::flowfailure() const {
  return flowfailure_;
}
inline void pbIwfFsmInfo::set_flowfailure(bool value) {
  set_has_flowfailure();
  flowfailure_ = value;
}

// optional bool isCloseState = 29 [default = false];
inline bool pbIwfFsmInfo::has_isclosestate() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void pbIwfFsmInfo::set_has_isclosestate() {
  _has_bits_[0] |= 0x10000000u;
}
inline void pbIwfFsmInfo::clear_has_isclosestate() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void pbIwfFsmInfo::clear_isclosestate() {
  isclosestate_ = false;
  clear_has_isclosestate();
}
inline bool pbIwfFsmInfo::isclosestate() const {
  return isclosestate_;
}
inline void pbIwfFsmInfo::set_isclosestate(bool value) {
  set_has_isclosestate();
  isclosestate_ = value;
}

// repeated .pbIwfTimerData timerInfo = 30;
inline int pbIwfFsmInfo::timerinfo_size() const {
  return timerinfo_.size();
}
inline void pbIwfFsmInfo::clear_timerinfo() {
  timerinfo_.Clear();
}
inline const ::pbIwfTimerData& pbIwfFsmInfo::timerinfo(int index) const {
  return timerinfo_.Get(index);
}
inline ::pbIwfTimerData* pbIwfFsmInfo::mutable_timerinfo(int index) {
  return timerinfo_.Mutable(index);
}
inline ::pbIwfTimerData* pbIwfFsmInfo::add_timerinfo() {
  return timerinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pbIwfTimerData >&
pbIwfFsmInfo::timerinfo() const {
  return timerinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::pbIwfTimerData >*
pbIwfFsmInfo::mutable_timerinfo() {
  return &timerinfo_;
}

// optional .pbTcapTransactionData tcapInfo = 31;
inline bool pbIwfFsmInfo::has_tcapinfo() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void pbIwfFsmInfo::set_has_tcapinfo() {
  _has_bits_[0] |= 0x40000000u;
}
inline void pbIwfFsmInfo::clear_has_tcapinfo() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void pbIwfFsmInfo::clear_tcapinfo() {
  if (tcapinfo_ != NULL) tcapinfo_->::pbTcapTransactionData::Clear();
  clear_has_tcapinfo();
}
inline const ::pbTcapTransactionData& pbIwfFsmInfo::tcapinfo() const {
  return tcapinfo_ != NULL ? *tcapinfo_ : *default_instance_->tcapinfo_;
}
inline ::pbTcapTransactionData* pbIwfFsmInfo::mutable_tcapinfo() {
  set_has_tcapinfo();
  if (tcapinfo_ == NULL) tcapinfo_ = new ::pbTcapTransactionData;
  return tcapinfo_;
}
inline ::pbTcapTransactionData* pbIwfFsmInfo::release_tcapinfo() {
  clear_has_tcapinfo();
  ::pbTcapTransactionData* temp = tcapinfo_;
  tcapinfo_ = NULL;
  return temp;
}

// optional .pbDiameterSessionData diameterInfo = 32;
inline bool pbIwfFsmInfo::has_diameterinfo() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void pbIwfFsmInfo::set_has_diameterinfo() {
  _has_bits_[0] |= 0x80000000u;
}
inline void pbIwfFsmInfo::clear_has_diameterinfo() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void pbIwfFsmInfo::clear_diameterinfo() {
  if (diameterinfo_ != NULL) diameterinfo_->::pbDiameterSessionData::Clear();
  clear_has_diameterinfo();
}
inline const ::pbDiameterSessionData& pbIwfFsmInfo::diameterinfo() const {
  return diameterinfo_ != NULL ? *diameterinfo_ : *default_instance_->diameterinfo_;
}
inline ::pbDiameterSessionData* pbIwfFsmInfo::mutable_diameterinfo() {
  set_has_diameterinfo();
  if (diameterinfo_ == NULL) diameterinfo_ = new ::pbDiameterSessionData;
  return diameterinfo_;
}
inline ::pbDiameterSessionData* pbIwfFsmInfo::release_diameterinfo() {
  clear_has_diameterinfo();
  ::pbDiameterSessionData* temp = diameterinfo_;
  diameterinfo_ = NULL;
  return temp;
}

// optional fixed32 freeListKey = 33;
inline bool pbIwfFsmInfo::has_freelistkey() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void pbIwfFsmInfo::set_has_freelistkey() {
  _has_bits_[1] |= 0x00000001u;
}
inline void pbIwfFsmInfo::clear_has_freelistkey() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void pbIwfFsmInfo::clear_freelistkey() {
  freelistkey_ = 0u;
  clear_has_freelistkey();
}
inline ::google::protobuf::uint32 pbIwfFsmInfo::freelistkey() const {
  return freelistkey_;
}
inline void pbIwfFsmInfo::set_freelistkey(::google::protobuf::uint32 value) {
  set_has_freelistkey();
  freelistkey_ = value;
}

// optional string actionRuleName = 34 [default = ""];
inline bool pbIwfFsmInfo::has_actionrulename() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void pbIwfFsmInfo::set_has_actionrulename() {
  _has_bits_[1] |= 0x00000002u;
}
inline void pbIwfFsmInfo::clear_has_actionrulename() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void pbIwfFsmInfo::clear_actionrulename() {
  if (actionrulename_ != &::google::protobuf::internal::kEmptyString) {
    actionrulename_->clear();
  }
  clear_has_actionrulename();
}
inline const ::std::string& pbIwfFsmInfo::actionrulename() const {
  return *actionrulename_;
}
inline void pbIwfFsmInfo::set_actionrulename(const ::std::string& value) {
  set_has_actionrulename();
  if (actionrulename_ == &::google::protobuf::internal::kEmptyString) {
    actionrulename_ = new ::std::string;
  }
  actionrulename_->assign(value);
}
inline void pbIwfFsmInfo::set_actionrulename(const char* value) {
  set_has_actionrulename();
  if (actionrulename_ == &::google::protobuf::internal::kEmptyString) {
    actionrulename_ = new ::std::string;
  }
  actionrulename_->assign(value);
}
inline void pbIwfFsmInfo::set_actionrulename(const char* value, size_t size) {
  set_has_actionrulename();
  if (actionrulename_ == &::google::protobuf::internal::kEmptyString) {
    actionrulename_ = new ::std::string;
  }
  actionrulename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbIwfFsmInfo::mutable_actionrulename() {
  set_has_actionrulename();
  if (actionrulename_ == &::google::protobuf::internal::kEmptyString) {
    actionrulename_ = new ::std::string;
  }
  return actionrulename_;
}
inline ::std::string* pbIwfFsmInfo::release_actionrulename() {
  clear_has_actionrulename();
  if (actionrulename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = actionrulename_;
    actionrulename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .pbSccpAddress callingSccpAddr = 35;
inline bool pbIwfFsmInfo::has_callingsccpaddr() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void pbIwfFsmInfo::set_has_callingsccpaddr() {
  _has_bits_[1] |= 0x00000004u;
}
inline void pbIwfFsmInfo::clear_has_callingsccpaddr() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void pbIwfFsmInfo::clear_callingsccpaddr() {
  if (callingsccpaddr_ != NULL) callingsccpaddr_->::pbSccpAddress::Clear();
  clear_has_callingsccpaddr();
}
inline const ::pbSccpAddress& pbIwfFsmInfo::callingsccpaddr() const {
  return callingsccpaddr_ != NULL ? *callingsccpaddr_ : *default_instance_->callingsccpaddr_;
}
inline ::pbSccpAddress* pbIwfFsmInfo::mutable_callingsccpaddr() {
  set_has_callingsccpaddr();
  if (callingsccpaddr_ == NULL) callingsccpaddr_ = new ::pbSccpAddress;
  return callingsccpaddr_;
}
inline ::pbSccpAddress* pbIwfFsmInfo::release_callingsccpaddr() {
  clear_has_callingsccpaddr();
  ::pbSccpAddress* temp = callingsccpaddr_;
  callingsccpaddr_ = NULL;
  return temp;
}

// optional fixed32 lastSentTcapCptopcode = 36;
inline bool pbIwfFsmInfo::has_lastsenttcapcptopcode() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void pbIwfFsmInfo::set_has_lastsenttcapcptopcode() {
  _has_bits_[1] |= 0x00000008u;
}
inline void pbIwfFsmInfo::clear_has_lastsenttcapcptopcode() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void pbIwfFsmInfo::clear_lastsenttcapcptopcode() {
  lastsenttcapcptopcode_ = 0u;
  clear_has_lastsenttcapcptopcode();
}
inline ::google::protobuf::uint32 pbIwfFsmInfo::lastsenttcapcptopcode() const {
  return lastsenttcapcptopcode_;
}
inline void pbIwfFsmInfo::set_lastsenttcapcptopcode(::google::protobuf::uint32 value) {
  set_has_lastsenttcapcptopcode();
  lastsenttcapcptopcode_ = value;
}

// optional bool isCCFHActionTaken = 37 [default = false];
inline bool pbIwfFsmInfo::has_isccfhactiontaken() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void pbIwfFsmInfo::set_has_isccfhactiontaken() {
  _has_bits_[1] |= 0x00000010u;
}
inline void pbIwfFsmInfo::clear_has_isccfhactiontaken() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void pbIwfFsmInfo::clear_isccfhactiontaken() {
  isccfhactiontaken_ = false;
  clear_has_isccfhactiontaken();
}
inline bool pbIwfFsmInfo::isccfhactiontaken() const {
  return isccfhactiontaken_;
}
inline void pbIwfFsmInfo::set_isccfhactiontaken(bool value) {
  set_has_isccfhactiontaken();
  isccfhactiontaken_ = value;
}

// optional bool dontTriggerFollowOnSessionforCCAUError = 38 [default = false];
inline bool pbIwfFsmInfo::has_donttriggerfollowonsessionforccauerror() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void pbIwfFsmInfo::set_has_donttriggerfollowonsessionforccauerror() {
  _has_bits_[1] |= 0x00000020u;
}
inline void pbIwfFsmInfo::clear_has_donttriggerfollowonsessionforccauerror() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void pbIwfFsmInfo::clear_donttriggerfollowonsessionforccauerror() {
  donttriggerfollowonsessionforccauerror_ = false;
  clear_has_donttriggerfollowonsessionforccauerror();
}
inline bool pbIwfFsmInfo::donttriggerfollowonsessionforccauerror() const {
  return donttriggerfollowonsessionforccauerror_;
}
inline void pbIwfFsmInfo::set_donttriggerfollowonsessionforccauerror(bool value) {
  set_has_donttriggerfollowonsessionforccauerror();
  donttriggerfollowonsessionforccauerror_ = value;
}

// -------------------------------------------------------------------

// pbIwfSessionContextData

// optional string originHost = 1;
inline bool pbIwfSessionContextData::has_originhost() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pbIwfSessionContextData::set_has_originhost() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pbIwfSessionContextData::clear_has_originhost() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pbIwfSessionContextData::clear_originhost() {
  if (originhost_ != &::google::protobuf::internal::kEmptyString) {
    originhost_->clear();
  }
  clear_has_originhost();
}
inline const ::std::string& pbIwfSessionContextData::originhost() const {
  return *originhost_;
}
inline void pbIwfSessionContextData::set_originhost(const ::std::string& value) {
  set_has_originhost();
  if (originhost_ == &::google::protobuf::internal::kEmptyString) {
    originhost_ = new ::std::string;
  }
  originhost_->assign(value);
}
inline void pbIwfSessionContextData::set_originhost(const char* value) {
  set_has_originhost();
  if (originhost_ == &::google::protobuf::internal::kEmptyString) {
    originhost_ = new ::std::string;
  }
  originhost_->assign(value);
}
inline void pbIwfSessionContextData::set_originhost(const char* value, size_t size) {
  set_has_originhost();
  if (originhost_ == &::google::protobuf::internal::kEmptyString) {
    originhost_ = new ::std::string;
  }
  originhost_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbIwfSessionContextData::mutable_originhost() {
  set_has_originhost();
  if (originhost_ == &::google::protobuf::internal::kEmptyString) {
    originhost_ = new ::std::string;
  }
  return originhost_;
}
inline ::std::string* pbIwfSessionContextData::release_originhost() {
  clear_has_originhost();
  if (originhost_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = originhost_;
    originhost_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string originRealm = 2;
inline bool pbIwfSessionContextData::has_originrealm() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pbIwfSessionContextData::set_has_originrealm() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pbIwfSessionContextData::clear_has_originrealm() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pbIwfSessionContextData::clear_originrealm() {
  if (originrealm_ != &::google::protobuf::internal::kEmptyString) {
    originrealm_->clear();
  }
  clear_has_originrealm();
}
inline const ::std::string& pbIwfSessionContextData::originrealm() const {
  return *originrealm_;
}
inline void pbIwfSessionContextData::set_originrealm(const ::std::string& value) {
  set_has_originrealm();
  if (originrealm_ == &::google::protobuf::internal::kEmptyString) {
    originrealm_ = new ::std::string;
  }
  originrealm_->assign(value);
}
inline void pbIwfSessionContextData::set_originrealm(const char* value) {
  set_has_originrealm();
  if (originrealm_ == &::google::protobuf::internal::kEmptyString) {
    originrealm_ = new ::std::string;
  }
  originrealm_->assign(value);
}
inline void pbIwfSessionContextData::set_originrealm(const char* value, size_t size) {
  set_has_originrealm();
  if (originrealm_ == &::google::protobuf::internal::kEmptyString) {
    originrealm_ = new ::std::string;
  }
  originrealm_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbIwfSessionContextData::mutable_originrealm() {
  set_has_originrealm();
  if (originrealm_ == &::google::protobuf::internal::kEmptyString) {
    originrealm_ = new ::std::string;
  }
  return originrealm_;
}
inline ::std::string* pbIwfSessionContextData::release_originrealm() {
  clear_has_originrealm();
  if (originrealm_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = originrealm_;
    originrealm_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string oldHost = 3;
inline bool pbIwfSessionContextData::has_oldhost() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void pbIwfSessionContextData::set_has_oldhost() {
  _has_bits_[0] |= 0x00000004u;
}
inline void pbIwfSessionContextData::clear_has_oldhost() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void pbIwfSessionContextData::clear_oldhost() {
  if (oldhost_ != &::google::protobuf::internal::kEmptyString) {
    oldhost_->clear();
  }
  clear_has_oldhost();
}
inline const ::std::string& pbIwfSessionContextData::oldhost() const {
  return *oldhost_;
}
inline void pbIwfSessionContextData::set_oldhost(const ::std::string& value) {
  set_has_oldhost();
  if (oldhost_ == &::google::protobuf::internal::kEmptyString) {
    oldhost_ = new ::std::string;
  }
  oldhost_->assign(value);
}
inline void pbIwfSessionContextData::set_oldhost(const char* value) {
  set_has_oldhost();
  if (oldhost_ == &::google::protobuf::internal::kEmptyString) {
    oldhost_ = new ::std::string;
  }
  oldhost_->assign(value);
}
inline void pbIwfSessionContextData::set_oldhost(const char* value, size_t size) {
  set_has_oldhost();
  if (oldhost_ == &::google::protobuf::internal::kEmptyString) {
    oldhost_ = new ::std::string;
  }
  oldhost_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbIwfSessionContextData::mutable_oldhost() {
  set_has_oldhost();
  if (oldhost_ == &::google::protobuf::internal::kEmptyString) {
    oldhost_ = new ::std::string;
  }
  return oldhost_;
}
inline ::std::string* pbIwfSessionContextData::release_oldhost() {
  clear_has_oldhost();
  if (oldhost_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = oldhost_;
    oldhost_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string oldRealm = 4;
inline bool pbIwfSessionContextData::has_oldrealm() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void pbIwfSessionContextData::set_has_oldrealm() {
  _has_bits_[0] |= 0x00000008u;
}
inline void pbIwfSessionContextData::clear_has_oldrealm() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void pbIwfSessionContextData::clear_oldrealm() {
  if (oldrealm_ != &::google::protobuf::internal::kEmptyString) {
    oldrealm_->clear();
  }
  clear_has_oldrealm();
}
inline const ::std::string& pbIwfSessionContextData::oldrealm() const {
  return *oldrealm_;
}
inline void pbIwfSessionContextData::set_oldrealm(const ::std::string& value) {
  set_has_oldrealm();
  if (oldrealm_ == &::google::protobuf::internal::kEmptyString) {
    oldrealm_ = new ::std::string;
  }
  oldrealm_->assign(value);
}
inline void pbIwfSessionContextData::set_oldrealm(const char* value) {
  set_has_oldrealm();
  if (oldrealm_ == &::google::protobuf::internal::kEmptyString) {
    oldrealm_ = new ::std::string;
  }
  oldrealm_->assign(value);
}
inline void pbIwfSessionContextData::set_oldrealm(const char* value, size_t size) {
  set_has_oldrealm();
  if (oldrealm_ == &::google::protobuf::internal::kEmptyString) {
    oldrealm_ = new ::std::string;
  }
  oldrealm_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbIwfSessionContextData::mutable_oldrealm() {
  set_has_oldrealm();
  if (oldrealm_ == &::google::protobuf::internal::kEmptyString) {
    oldrealm_ = new ::std::string;
  }
  return oldrealm_;
}
inline ::std::string* pbIwfSessionContextData::release_oldrealm() {
  clear_has_oldrealm();
  if (oldrealm_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = oldrealm_;
    oldrealm_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .pbSCCPParameters sccpParameters = 5;
inline bool pbIwfSessionContextData::has_sccpparameters() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void pbIwfSessionContextData::set_has_sccpparameters() {
  _has_bits_[0] |= 0x00000010u;
}
inline void pbIwfSessionContextData::clear_has_sccpparameters() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void pbIwfSessionContextData::clear_sccpparameters() {
  if (sccpparameters_ != NULL) sccpparameters_->::pbSCCPParameters::Clear();
  clear_has_sccpparameters();
}
inline const ::pbSCCPParameters& pbIwfSessionContextData::sccpparameters() const {
  return sccpparameters_ != NULL ? *sccpparameters_ : *default_instance_->sccpparameters_;
}
inline ::pbSCCPParameters* pbIwfSessionContextData::mutable_sccpparameters() {
  set_has_sccpparameters();
  if (sccpparameters_ == NULL) sccpparameters_ = new ::pbSCCPParameters;
  return sccpparameters_;
}
inline ::pbSCCPParameters* pbIwfSessionContextData::release_sccpparameters() {
  clear_has_sccpparameters();
  ::pbSCCPParameters* temp = sccpparameters_;
  sccpparameters_ = NULL;
  return temp;
}

// optional .pbSccpAddress oldcpaitu = 6;
inline bool pbIwfSessionContextData::has_oldcpaitu() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void pbIwfSessionContextData::set_has_oldcpaitu() {
  _has_bits_[0] |= 0x00000020u;
}
inline void pbIwfSessionContextData::clear_has_oldcpaitu() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void pbIwfSessionContextData::clear_oldcpaitu() {
  if (oldcpaitu_ != NULL) oldcpaitu_->::pbSccpAddress::Clear();
  clear_has_oldcpaitu();
}
inline const ::pbSccpAddress& pbIwfSessionContextData::oldcpaitu() const {
  return oldcpaitu_ != NULL ? *oldcpaitu_ : *default_instance_->oldcpaitu_;
}
inline ::pbSccpAddress* pbIwfSessionContextData::mutable_oldcpaitu() {
  set_has_oldcpaitu();
  if (oldcpaitu_ == NULL) oldcpaitu_ = new ::pbSccpAddress;
  return oldcpaitu_;
}
inline ::pbSccpAddress* pbIwfSessionContextData::release_oldcpaitu() {
  clear_has_oldcpaitu();
  ::pbSccpAddress* temp = oldcpaitu_;
  oldcpaitu_ = NULL;
  return temp;
}

// optional bool OldCallingPartyAddrpresent = 7;
inline bool pbIwfSessionContextData::has_oldcallingpartyaddrpresent() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void pbIwfSessionContextData::set_has_oldcallingpartyaddrpresent() {
  _has_bits_[0] |= 0x00000040u;
}
inline void pbIwfSessionContextData::clear_has_oldcallingpartyaddrpresent() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void pbIwfSessionContextData::clear_oldcallingpartyaddrpresent() {
  oldcallingpartyaddrpresent_ = false;
  clear_has_oldcallingpartyaddrpresent();
}
inline bool pbIwfSessionContextData::oldcallingpartyaddrpresent() const {
  return oldcallingpartyaddrpresent_;
}
inline void pbIwfSessionContextData::set_oldcallingpartyaddrpresent(bool value) {
  set_has_oldcallingpartyaddrpresent();
  oldcallingpartyaddrpresent_ = value;
}

// optional fixed32 oldopc = 8;
inline bool pbIwfSessionContextData::has_oldopc() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void pbIwfSessionContextData::set_has_oldopc() {
  _has_bits_[0] |= 0x00000080u;
}
inline void pbIwfSessionContextData::clear_has_oldopc() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void pbIwfSessionContextData::clear_oldopc() {
  oldopc_ = 0u;
  clear_has_oldopc();
}
inline ::google::protobuf::uint32 pbIwfSessionContextData::oldopc() const {
  return oldopc_;
}
inline void pbIwfSessionContextData::set_oldopc(::google::protobuf::uint32 value) {
  set_has_oldopc();
  oldopc_ = value;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pbIwfTimerData_ETimerType>() {
  return ::pbIwfTimerData_ETimerType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pbIwfTimerData_EKeyType>() {
  return ::pbIwfTimerData_EKeyType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< pbProtocol>() {
  return pbProtocol_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< TransState>() {
  return TransState_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_iwf_2eproto__INCLUDED
