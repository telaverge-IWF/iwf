/****************************************************************************
 *                                                                          *
 *     Copyright 2008 IntelliNet Technologies, Inc. All Rights Reserved.    *
 *             Manufactured in the United States of America.                *
 *       1990 W. New Haven Ste. 312, Melbourne, Florida, 32904 U.S.A.       *
 *                                                                          *
 *   This product and related documentation is protected by copyright and   *
 *   distributed under licenses restricting its use, copying, distribution  *
 *   and decompilation.  No part of this product or related documentation   *
 *   may be reproduced in any form by any means without prior written       *
 *   authorization of IntelliNet Technologies and its licensors, if any.    *
 *                                                                          *
 *   RESTRICTED RIGHTS LEGEND:  Use, duplication, or disclosure by the      *
 *   government is subject to restrictions as set forth in subparagraph     *
 *   (c)(1)(ii) of the Rights in Technical Data and Computer Software       *
 *   clause at DFARS 252.227-7013 and FAR 52.227-19.                        *
 *                                                                          *
 ****************************************************************************
 *                                                                          *
 * CONTRACT: INTERNAL                                                       *
 *                                                                          *
 ****************************************************************************/

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/select.h>
#include <sys/ioctl.h>

#include <net-snmp/net-snmp-config.h>
#ifdef HAVE_SIGNAL
#include <signal.h>
#endif /* HAVE_SIGNAL */
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

#include <pthread.h>
#include <signal.h>
#include <its.h>
#include <its_emlist.h>
#include <its_hmi.h>
#include <its_thread.h>
#include <its_sockets.h>
#include "stacks.h"
#include "subagent.h"
#include "dremib.h"
#include "AlarmAPIImpl.h"
#include "SubAgentMeSS.h"
using namespace dre;

extern char* instance_id;

static char* sync_data = "ISS7SSI";
static ITS_INT   sd_len = 7;

const char *app_name = "sub";

#if defined(_SOL_SNMP_)
int netsnmp_running;
#else
extern int netsnmp_running;
#endif

ITS_INT agent_RecvInitialise(SAClientInfo *ClientInfo);
ITS_INT DIASA_PutEventOnTaskQue(ITS_EVENT *evt);
static ITS_INT DIASA_GetEventFromTaskQue(ITS_EVENT *evt);

static ITS_INT ReadEvent(ITS_HANDLE h, ITS_EVENT *ev);
netsnmp_session session, *ss;

ITS_BOOLEAN agentTraceEnable;
SubAgentMeSS subAgentMeSS;

#ifdef __GNUC__
#define UNUSED __attribute__((unused))
#else
#define UNUSED
#endif

/* Global definitions */

#define BUFLEN 5000

ITS_SocketInfo *sockinfo;
struct sockaddr_in ntfyClientAddr, ntfyServerAddr;
static ITS_THREAD   recvClientThread;
static ITS_THREAD   processAlarmThread;
const ITS_INT ITS_OAM_NOTIFY_THREAD_STACK_SIZE = (2 * 1024 * 1024);

SAClientInfo CLI;
ITS_BOOLEAN connDown = ITS_TRUE;
int             inform = 0;


RETSIGTYPE
stop_server(UNUSED int a) {
    netsnmp_running = 0;
}

typedef struct _diasa_trans
{
    EMLIST_Manager       *taskQue;
    ITS_UINT             noCurrEnts;
}DIASA_TRANS_QUE;

DIASA_TRANS_QUE saTrans;

/* Autogenerated */
static void
usage(const char *prog)
{
    fprintf(stderr,
            "USAGE: %s [OPTIONS]\n"
            "\n"
            "OPTIONS:\n", prog);

    fprintf(stderr,
            "  -d\t\t\tdump all traffic\n"
            "  -D TOKEN[,...]\tturn on debugging output for the specified "
            "TOKENs\n"
            "\t\t\t   (ALL gives extremely verbose debugging output)\n"
            "  -f\t\t\tDo not fork() from the calling shell.\n"
            "  -h\t\t\tdisplay this help message\n"
            "  -H\t\t\tdisplay a list of configuration file directives\n"
            "  -L LOGOPTS\t\tToggle various defaults controlling logging:\n");
#ifndef _SOL_SNMP_
    snmp_log_options_usage("\t\t\t  ", stderr);
#endif

#ifndef DISABLE_MIB_LOADING
    fprintf(stderr,
            "  -m MIB[:...]\t\tload given list of MIBs (ALL loads "
            "everything)\n"
            "  -M DIR[:...]\t\tlook in given list of directories for MIBs\n");
#endif /* DISABLE_MIB_LOADING */

#ifndef DISABLE_MIB_LOADING
    fprintf(stderr,
            "  -P MIBOPTS\t\tToggle various defaults controlling mib "
            "parsing:\n");
    snmp_mib_toggle_options_usage("\t\t\t  ", stderr);
#endif /* DISABLE_MIB_LOADING */

    fprintf(stderr,
            "  -v\t\t\tdisplay package version number\n"
            "  -x TRANSPORT\tconnect to master agent using TRANSPORT\n");
    exit(1);
}

/* Autogenerated */
static void
version(void)
{
    fprintf(stderr, "NET-SNMP version: %s\n", netsnmp_get_version());
    exit(0);
}


int
snmp_input(int operation,
           netsnmp_session * session,
           int reqid, netsnmp_pdu *pdu, void *magic)
{
    return 1;
}
static void
optProc(int argc, char *const *argv, int opt)
{
    switch (opt) {
    case 'C':
        while (*optarg) {
            switch (*optarg++) {
            case 'i':
                inform = 1;
                break;
            default:
                fprintf(stderr,
                        "Unknown flag passed to -C: %c\n", optarg[-1]);
                exit(1);
            }
        }
        break;
    }
}
/* 
 * This is automatically generated code from which IntelliNet initalise 
 * functions will be called 
 */
int
main (int argc, char **argv)
{
    int arg;
    char* cp = NULL;
    int dont_fork = 0, do_help = 0;
    ITS_INT rc;

/////////////////////////////////
#if defined(_SOL_SNMP_)
    netsnmp_pdu    *pdu, *response;
    in_addr_t      *pdu_in_addr_t;
    oid             name[MAX_OID_LEN];
    size_t          name_length;
    int             argG;
    int             status;
    char           *trap = NULL, *specific = NULL, *description =
        NULL, *agent = NULL;
    char           *prognam;
    int             exitval = 0;
    
    snmp_sess_init( &session );
    session.version = SNMP_VERSION_2c;
    session.community = "public";
    session.community_len = strlen(session.community);
    session.peername = argv[3];
    init_snmp("snmpapp");
#endif

    SAClientInfo ClientInfo;

    memset(&ClientInfo, 0, sizeof(ClientInfo));

    if (argc < 3)
    {
        CLOG_ERROR("USAGE Error: subagent -a <serverIpAddr> -p <port>\n");
        return 0;
    }

    while ((arg = getopt(argc, argv, "dD:fhHL:i:a:p:"
#ifndef DISABLE_MIB_LOADING
                       "m:M:"
#endif /* DISABLE_MIB_LOADING */
                       "n:"
#ifndef DISABLE_MIB_LOADING
                       "P:"
#endif /* DISABLE_MIB_LOADING */
                       "vx:")) != EOF) {
        switch (arg) {
            case 'd':
                netsnmp_ds_set_boolean(NETSNMP_DS_LIBRARY_ID,
                                     NETSNMP_DS_LIB_DUMP_PACKET, 1);
            break;

            case 'D':
                debug_register_tokens(optarg);
                snmp_set_do_debugging(1);
            break;

            case 'f':
                dont_fork = 1;
            break;

            case 'h':
                usage(argv[0]);
            break;

            case 'H':
                do_help = 1;
            break;

            case 'L':
#ifndef _SOL_SNMP_
                if (snmp_log_options(optarg, argc, argv) < 0) {
                    exit(1);
                    }
#else
                 init_snmp_logging();
                 snmp_enable_syslog();
                 snmp_enable_stderrlog();
                 snmp_enable_calllog();
#endif
            break;

#ifndef DISABLE_MIB_LOADING
            case 'm':
                if (optarg != NULL) {
                    setenv("MIBS", optarg, 1);
                    } else {
                    usage(argv[0]);
                    }
            break;

            case 'M':
                if (optarg != NULL) {
                    setenv("MIBDIRS", optarg, 1);
                    } else {
                    usage(argv[0]);
                    }
            break;
#endif /* DISABLE_MIB_LOADING */

            case 'n':
                if (optarg != NULL) {
                    app_name = optarg;
                    netsnmp_ds_set_string(NETSNMP_DS_LIBRARY_ID,
                                  NETSNMP_DS_LIB_APPTYPE, app_name);
                    } else {
                    usage(argv[0]);
                    }
            break;

#ifndef DISABLE_MIB_LOADING
            case 'P':
                cp = snmp_mib_toggle_options(optarg);
                if (cp != NULL) {
                    fprintf(stderr, "Unknown parser option to -P: %c.\n", *cp);
                    usage(argv[0]);
                    }
            break;
#endif /* DISABLE_MIB_LOADING */

            case 'v':
                version();
            break;

            case 'x':
                  if (optarg != NULL) {
                    netsnmp_ds_set_string(NETSNMP_DS_APPLICATION_ID,
                                          NETSNMP_DS_AGENT_X_SOCKET, optarg);
                      } else {
                        usage(argv[0]);
                      }
            break;
            case 'i':
                if (optarg != NULL) {
                    instance_id = optarg;
                }
                break;
            case 'a':
 
                //Copy Into Fix Sized Buffer. 
                if (optarg != NULL) {
                    strncpy(ClientInfo.ipAddr,optarg, 20);
                    //printf( "-a arg value is %s",optarg);
                }
                break;

            case 'p':
                if (optarg != NULL) {
                    ClientInfo.port = atoi(optarg);
                }
                break;

            default:
              fprintf(stderr, "invalid option: -%c\n", arg);
              CLOG_ERROR("Invalid option %c",arg);
              usage(argv[0]);
              break;
        }
    }

    netsnmp_ds_set_boolean(NETSNMP_DS_LIBRARY_ID,
            NETSNMP_DS_LIB_ALARM_DONT_USE_SIG,1);
#ifndef _SOL_SNMP_
    if (do_help) {
        netsnmp_ds_set_boolean(NETSNMP_DS_APPLICATION_ID,
                               NETSNMP_DS_AGENT_NO_ROOT_ACCESS, 1);
        } else {
        /* we are a subagent */
        netsnmp_ds_set_boolean(NETSNMP_DS_APPLICATION_ID,
                               NETSNMP_DS_AGENT_ROLE, 1);

     /* initialize tcpip, if necessary */
        SOCK_STARTUP;
    }

    /* initialize the agent library */
    init_agent(app_name);

    /* initialize your mib code here */

    /* subagent will be used to read subagent.conf files. */
    init_snmp("subagent");

    if (do_help) {
        fprintf(stderr, "Configuration directives understood:\n");
        CLOG_ERROR("Configuration directives understood");
        read_config_print_usage("  ");
        exit(0);
    }
#endif

    /* In case we received a request to stop (kill -TERM or kill -INT) */
    netsnmp_running = 1;

#ifdef SIGTERM
    signal(SIGTERM, stop_server);
#endif


#ifdef SIGINT
    signal(SIGINT, stop_server);
#endif

#if defined(_SOL_SNMP_)
    SOCK_STARTUP;
    session.callback = snmp_input;
    session.callback_magic = NULL;
    netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DEFAULT_PORT, 
                        SNMP_TRAP_PORT);
    ss = snmp_open(&session);
    if (ss == NULL) {
        /*
         * diagnose snmp_open errors with the input netsnmp_session pointer 
         */
        CLOG_CRITICAL("netsnmp_open failed");
        snmp_sess_perror("iiisnmptrap", &session);
        SOCK_CLEANUP;
        exit(1);
    }
#endif

    //CLOG_DEBUG("argc = %d, argv[1] = %s argv[2] = %s\n",argc,  argv[1], argv[2]);
    //strcpy(ClientInfo.ipAddr,  argv[1]);
    CLOG_DEBUG("Server Ip = %s \n", ClientInfo.ipAddr);
//    ClientInfo.port = atoi(argv[2]);
    CLOG_DEBUG("Port Number = %d\n", ClientInfo.port);


    try
    {
    /* This is IntelliNet API */
    rc = agent_RecvInitialise(&ClientInfo);
    if (rc < 0)
    {
        CLOG_CRITICAL("Sub-Agent initialize failed \n");
        //Exiting here so that avamgr will restart.
        exit(1);
    }
    }
    catch(eAccelero::SystemException& ocException)
    {
       CLOG_CRITICAL("Sub-Agent initialize Failed \n");
       exit(1);
    }

    /* main loop here... */
    while(netsnmp_running) {
        sleep(1);
    }

    /* at shutdown time */
    snmp_shutdown(app_name);
    SOCK_CLEANUP;
    return 0;
}

/*implemt: public
 ****************************************************************************
 *  Purpose:
 *      This thread is used to recieve notification from Diameter Application
 *
 *  Input Parameters:
 *      
 *
 *  Output Parameters:
 *      
 *
 *  Return Value:
 *      Returs ITS_SUCCESS
 *
 *  Notes:
 *
 *  See Also:
 *
 *  Revision History:
 *  ---------------------------------------------------------------------------
 *   Name               Date        Reference               Description
 *  ---------------------------------------------------------------------------
 *
 ****************************************************************************/
void* 
NotificationHandlerThread(void* param)
{
    CLOG_DEBUG("NotificationHandlerThread:: Entering \n");
    ITS_EVENT ev;
    ITS_INT ret;

    /*ret = DIASA_Connect(&CLI);

    if (ret == ITS_SUCCESS)
    {
        CLOG_DEBUG("Connect to Server success\n");
    }
    else
    {
        CLOG_ERROR("Connect to Server failed\n");
    }*/

    //while(1)
     while(netsnmp_running)
    {
        //CLOG_DEBUG("sockinfo->socket = %d \n", sockinfo->socket);
        memset(&ev, 0, sizeof(ITS_EVENT));
        ret = ReadEvent(sockinfo, &ev);
        
        if (sockinfo == NULL || ret == ITS_ERCVFAIL)
        {
            if(sockinfo != NULL)
            {
                SOCK_Close(sockinfo);
            }
            /* 
             * If Server connection is down wait for some time
             * before try to re-connect 
             */
#ifdef WIN32
            Sleep(5);
#else
            sleep(5);
#endif
            ret = DIASA_Connect(&CLI);
            
            if (ret == ITS_SUCCESS)
            {
                CLOG_DEBUG("Connect to Server success\n");
            }
        }
        else if (ret != ITS_SUCCESS)
        {
            //CLOG_ERROR("Read Failure with error %d \n",ret);
            continue;
        }

        if (ev.data == NULL)
        {
            CLOG_DEBUG("NULL EVent Recieved \n");
            continue;
        }
       
        CLOG_DEBUG("Put event to taskQueue ev.data = %s\n", ev.data);
        DIASA_PutEventOnTaskQue(&ev);
    }

    THREAD_NORMAL_EXIT;
}

/*implemt: public
 ****************************************************************************
 *  Purpose:
 *      This thread is used to Process the alarm and send notification to master  agent
 *
 *  Input Parameters:
 *      
 *
 *  Output Parameters:
 *      
 *
 *  Return Value:
 *      Returs ITS_SUCCESS
 *
 *  Notes:
 *
 *  See Also:
 *
 *  Revision History:
 *  ---------------------------------------------------------------------------
 *   Name               Date        Reference               Description
 *  ---------------------------------------------------------------------------
 *
 ****************************************************************************/
void*
ProcessAlarmThread(void* param)
{    
    CLOG_DEBUG("ProcessAlarmThread:: Entering \n");
    ITS_EVENT event;
    //Initializing event
    ITS_EVENT_INIT(&event,0,0);
    ITS_INT ret;
    ITS_INT alarmId = 0;
    ITS_CHAR alarmIdStr[ALARM_ID_LEN];
    /* for Tokenising */
    ITS_CHAR *token = NULL;
    ITS_INT Index = 0;
    ITS_CHAR bytes[255] = {'\0'};
    ITS_CHAR alarmString[100] = {'\0'};

    //while(1)
    while(netsnmp_running)
    {
        Index = 0;
        ret = DIASA_GetEventFromTaskQue(&event);

        if(ret != ITS_SUCCESS)
        {
            //EINTR not handled in the TaskQueue, so this error might get reported often
            CLOG_DEBUG("DIASA_GetEventFromTaskQue::Failed %d \n",ret);
            continue;
        }

        CLOG_INFO("In Process Alarm Thread event.src= %d, ev.len=%d ev.data = %s\n", 
                            event.src,event.len, event.data);
        /* Process the Recieved AlarmText here */
        strncpy(bytes,(const char*)event.data, event.len);
        bytes[event.len] = '\0';
        ITS_Free(event.data);

        CLOG_INFO("PRINTING bytes = %s\n", bytes);


        /*
         * Alarm Format will be as follows 
         * alarmid|SUBSYS|SEV|CLASS|descripFileNam |Fun|lin|Actual dat
         */


        token = strtok(bytes, "|");
        
        while ( token != NULL )
        {
            switch ( Index )
            {
                case 0:
                {
                    /* AlarmId */
                    alarmId = (ITS_UINT)atoi(token);
                    strncpy(alarmIdStr,token,ALARM_ID_LEN);
                    Index++;
                    token = strtok(NULL, "|");
                    break;
                }
                case 1:
                {
                    /* Subsystem string - Not needed*/ 
                    Index++;
                    token = strtok(NULL, "|");
                    break;
                }
                case 2:
                {
                    /* Alarm Severity Needed. However since Clear Alarm has 
                     * different alarmId we dont need this information this 
                     * is locally present for us
                     */

                    Index++;
                    token = strtok(NULL, "|");                    
                    break;
                }
                case 3:
                {
                    /* Alarm object.If classname is different; based on which
                     * alarms will be raised needed 
                     */

                    Index++;
                    //strcpy(className,token);
                    token = strtok(NULL, "|");
                    break;
                }
                case 4:
                {
                    /* description */
                    Index++;
                    token = strtok(NULL, "|");
                    break;
                }
                case 5:
                {
                    /* file name */
                    Index++;
                    token = strtok(NULL, "|");
                    break;
                }
                case 6:
                {
                    /* function name */
                    Index++;
                    token = strtok(NULL, "|");
                    break;
                }
                case 7:
                {
                    /* line Number */
                    Index++;
                    //token = strtok(NULL, "|");
                    strcpy(alarmString,token);
                    CLOG_DEBUG("alarmString = %s\n", alarmString);
                    break;
                }
                
                default:
                {
                    token = NULL;
                    break;
                }
            }
        }
        Index = 0;

        if(event.src == ALARM_SRC_DRE) // New Alarms from DRE.
        {
            send_alarm(alarmIdStr,alarmString);
        }
        else //Existing Diameter Stack Alarms
        {
	    StackAlarmInfo stackAlarmInfo={alarmId,'\0'};
            //get the new alarm defined for the stack alarm  
	    if( subAgentMeSS.MapStackAlarm(alarmId,stackAlarmInfo.alarmIdString) == ITS_SUCCESS)
	    {
		    CLOG_DEBUG("StackAlarmId=%d,AlarmIdString=%s",alarmId,
                    stackAlarmInfo.alarmIdString);
	    }
	    else
	    {
	        CLOG_ERROR("StackAlarmId = %d AlarmIdString = %s not mapped in the application",
                    alarmId,stackAlarmInfo.alarmIdString);
	    }	
            if ((ALARM_SEVERITY(alarmId)) == major)
            {
                ret = send_diaMajorNotification_trap(&stackAlarmInfo, alarmString);
            }
            else if ((ALARM_SEVERITY(alarmId)) == minor)
            {
                ret = send_diaMinorNotification_trap(&stackAlarmInfo, alarmString);
            }
            else if ((ALARM_SEVERITY(alarmId)) == cleared)
            {
                ret = send_diaClearedNotification_trap(&stackAlarmInfo, alarmString);
            }
            else if ((ALARM_SEVERITY(alarmId)) == critical) 
            {
                ret = send_diaCriticalNotification_trap(&stackAlarmInfo, alarmString);
            }
            else 
            {
                ret = send_diaInfoNotification_trap(&stackAlarmInfo, alarmString);
            }
        }
        agent_check_and_process(0);
    }

    THREAD_NORMAL_EXIT;
}

/*implemt: public
 ****************************************************************************
 *  Purpose:
 *      This method is used to initalise subagent 
 *
 *  Input Parameters:
 *      
 *
 *  Output Parameters:
 *      
 *
 *  Return Value:
 *      Returs ITS_SUCCESS
 *
 *  Notes:
 *
 *  See Also:
 *
 *  Revision History:
 *  ---------------------------------------------------------------------------
 *   Name               Date        Reference               Description
 *  ---------------------------------------------------------------------------
 *                                                          subagent Recieve 
 *                                                          initialise
 ****************************************************************************/
ITS_INT 
agent_RecvInitialise(SAClientInfo *ClientInfo)
{
    CLOG_DEBUG("agent_RecvInitialise:: ClientInfo Address=%s port = %d\n", 
                        ClientInfo->ipAddr, ClientInfo->port);
    ITS_INT ret;

    strcpy(CLI.ipAddr, ClientInfo->ipAddr);
    CLI.port = ClientInfo->port;

    CLOG_DEBUG("CLI Addr = %s CLI port = %d \n",CLI.ipAddr,CLI.port);

#if defined(DEBUG)
{
    agentTraceEnable = ITS_TRUE;
}
#else
{
    agentTraceEnable = ITS_FALSE;
}
#endif

    /* Create queue for recieving event in Process alarm thread */
    saTrans.taskQue = EMLIST_Create();

    /* Thread for Processing alarms */
    if(ITS_SUCCESS !=  THREAD_CreateThread(&processAlarmThread,
         ITS_OAM_NOTIFY_THREAD_STACK_SIZE,
         ProcessAlarmThread, NULL, 1))
    {
        CLOG_CRITICAL("Thread Creation For Processing Alarms Failed \n");
        return -1;
    }

    ret = agent_meSSInitialize();
    if (ret < 0)
    {
        CLOG_CRITICAL("MeSS Thread initialize failed \n");
    }
    else {
        CLOG_DEBUG("MeSS Thread initialized successfully \n");
    }

    //Connect to the TCP server
    ret = DIASA_Connect(&CLI);

    if (ret == ITS_SUCCESS)
    {
        CLOG_DEBUG("Connect to Server success\n");
    }
    else
    {
        CLOG_ERROR("Connect to Server failed\n");
    }

    return ITS_SUCCESS;
}

ITS_INT agent_meSSInitialize()
{
    //MeSS Thread
    eAccelero::Thread* messThread = new eAccelero::Thread("MeSS Thread");
    messThread->Start((eAccelero::Runnable*)&subAgentMeSS);
    return ITS_SUCCESS;
}

/*implemt: public
 ****************************************************************************
 *  Purpose:
 *      This method retrieves the event from the task que.
 *
 *  Input Parameters:
 *      taskTran  -   of type DIASA_TRANS_QUE
 *
 *  Output Parameters:
 *      evt   -   of type ITS_EVENT
 *
 *  Return Value:
 *      Returs ITS_SUCCESS
 *
 *  Notes:
 *
 *  See Also:
 ****************************************************************************/
static ITS_INT
DIASA_GetEventFromTaskQue(ITS_EVENT *evt)
{
    CLOG_DEBUG("DIASA_GetEventFromTaskQue:: Entering\n");
    ITS_INT len = 0, ret;
    void *data = 0;
    ITS_INT interval = 5;

repeat:
    if ((ret = EMLIST_GetNextEventWithTimeOut(saTrans.taskQue,
                       &data, &len, interval)) != ITS_SUCCESS)
    {
        if (ret == ITS_ETIMEOUT)
        {
            agent_check_and_process(0);

            if(!netsnmp_running)
            {
                /* Returning because
                 * subagent MeSS exited
                 */
                return (ret);
            }

            goto repeat;
        }

        if (data != NULL)
        {
            ITS_Free(data);
        }
        return (ret);
    }
    memcpy(evt, data, len);

    if (EMLIST_Lock(saTrans.taskQue) != ITS_SUCCESS)
    {
        ITS_Free(data);
        return (ITS_EBADMUTEX);
    }

    --saTrans.noCurrEnts;

    EMLIST_Unlock(saTrans.taskQue);

    ITS_Free(data);

    return (ret);
}

/*implemt: public
 ****************************************************************************
 *  Purpose:
 *      This method puts the event on to the task que.
 *
 *  Input Parameters:
 *      taskTran  -   of type DIASA_TRANS_QUE
 *      evt   -   of type ITS_EVENT
 *
 *  Output Parameters:
 *      None.
 *
 *  Return Value:
 *      Returs ITS_SUCCESS
 *
 *  Notes:
 *
 *  See Also:
 *
 ****************************************************************************/
ITS_INT
DIASA_PutEventOnTaskQue(ITS_EVENT *evt)
{
    CLOG_DEBUG("DIASA_PutEventOnTaskQue:: Entering\n");
    ITS_INT ret = ITS_SUCCESS;

    if (EMLIST_Lock(saTrans.taskQue) != ITS_SUCCESS)
    {
        return (ITS_EBADMUTEX);
    }

    ret = EMLIST_PutEvent(saTrans.taskQue,(ITS_CHAR*)evt,sizeof(ITS_EVENT));

    ++saTrans.noCurrEnts;

    EMLIST_Unlock(saTrans.taskQue);

    return (ret);
}

/*implemt: public
 ****************************************************************************
 *  Purpose:
 *      This method connects to the server.
 *      socket
 *
 *  Input Parameters:
 *      info  -   of type IDS_CONNECTION_INFO
 *
 *  Output Parameters:
 *      None.
 *
 *  Return Value:
 *      Returs ITS_SUCCESS
 *
 *  Notes:
 *      This function doesn't return until it connects to the server.
 *
 *  See Also:
 *
 ****************************************************************************/
ITS_INT
DIASA_Connect(SAClientInfo *ClientInfo)
{
    CLOG_DEBUG("DIASA_Connect:: \n");
    ITS_INT ret =0;
    ITS_INT repeat_count = 1;
    ITS_BOOLEAN isUp = ITS_FALSE;
    ITS_CHAR ipAddr[20];
    ITS_INT port;
    int i = 0;

    while(netsnmp_running)
    {
        i = 0;
        strcpy(ipAddr, ClientInfo->ipAddr);
        port = ClientInfo->port;

        CLOG_DEBUG("DIASA_Connect:: ipaddr = %s port = %d \n", 
                                                     ipAddr, port);

        ret = SOCK_ClientOpen(&sockinfo,
                              INET_DOMAIN,
                              ipAddr,
                              port);
        if (ret != ITS_SUCCESS)
        {
            CLOG_ERROR("IDSCL_Connect: Create client failed ret = %d\n", 
                                                                      ret);
            return (ret);
        }

        CLOG_DEBUG("sockinfo->socket = %d \n", sockinfo->socket);

        ret = SOCK_ClientConnect(sockinfo);
        if (ret != ITS_SUCCESS)
        {
            CLOG_ERROR("Connect to server failed. Trying Again \n");
            SOCK_Close(sockinfo);
            sockinfo = NULL;
            while(netsnmp_running && i < 5)
            {

                /*
                 * Granularity of sleep reduced so
                 * if the subagent MeSS thread is exiting
                 * we can exit from the while loop immediately
                 */
#ifdef WIN32
                Sleep(1);
#else
                sleep(1);
#endif
                i++;
            }
            repeat_count++;
        }
        else
        {
            isUp = ITS_TRUE;
            CLOG_DEBUG("IDSCL_Connect:: Connected to server\n");
            break;
        }
    }

    return (ret);
}

/*implemt: public
 ****************************************************************************
 *  Purpose:
 *      This method used to ReadEvent
 *      socket
 *
 *  Input Parameters:
 *      sd  -   Socket descriptor
 *
 *  Output Parameters:
 *      None.
 *
 *  Return Value:
 *      Returs ITS_SUCCESS
 *
 *  Notes:
 *      
 *
 *  See Also:
 *
 ****************************************************************************/
ITS_INT
ReadEvent(ITS_HANDLE h, ITS_EVENT *ev)
{
    int ret;
    unsigned i, dosCount;
    ITS_USHORT tmp;
    char b;
    ITS_SocketInfo* sockInfo  = (ITS_SocketInfo *)h;

    ITS_BOOLEAN firstTime = ITS_TRUE;

    if (h == NULL || ev == NULL)
    {
        return !ITS_SUCCESS;
    }

    /* synchronize the stream */
    for (i = 0, dosCount = 0;
         i < (unsigned)sd_len && dosCount < ITS_MAX_EVENT_SIZE;
         i++, dosCount++)
    {
        /*
         * this should be the blocking point
         */
        if (firstTime)
        {
            ITS_SockPollInfo info;

repeat:
            memset(&info, 0, sizeof(info));

            info.lookFor = SOCK_POLL_READ;
            info.sinfo = sockInfo;

            ret = SOCK_Poll(&info, 1,
                            HMI_GetTimeOutInterval() * 1000);

            if (ret < ITS_SUCCESS)
            {
                return (ITS_ERCVFAIL);
            }

            if (ret == 0)
            {
                goto repeat;
            }
            firstTime = ITS_FALSE;
        }
        ret = SOCK_Read(sockInfo, &b, sizeof(char));
        if (ret != sizeof(char))
        {
            return (ITS_ERCVFAIL);
        }

        if (b != sync_data[i])
        {
            i = ~0U;
            continue;
        }
    }

    /* read the source */
    ret = SOCK_Read(sockInfo, (char *)&tmp, sizeof(ITS_USHORT));

    if (ret != sizeof(ITS_USHORT))
    {
        return (ITS_ERCVFAIL);
    }
    ev->src = SOCK_NToHS(tmp);

    /* read the length */
    ret = SOCK_Read(sockInfo, (char *)&tmp, sizeof(ITS_USHORT));

    if (ret != sizeof(ITS_USHORT))
    {
        return (ITS_ERCVFAIL);
    }

    ev->len = SOCK_NToHS(tmp);

    ev->data = (ITS_OCTET *)ITS_Malloc(ev->len);
    memset(ev->data,0,ev->len);

    if (ev->data == NULL)
    {
        return (ITS_ENOMEM);
    }
    /* read the data */
    if (ev->len)
    {
        ret = SOCK_Read(sockInfo, (char *)ev->data, ev->len);
        if (ret != ev->len)
        {
            ITS_Free(ev->data);
            ev->data = NULL;
            return (ITS_ERCVFAIL);
        }
    }

    return (ITS_SUCCESS);
}

void send_alarm(char * alarmId,char* alarmText)
{
    CLOG_DEBUG("Send_alaram AlarmId = %s, AlarmText = %s\n",alarmId,alarmText);
    AlarmInfo *aInfo = subAgentMeSS.fetchAlarmInfo(alarmId);
    if(aInfo == NULL)
    {
        CLOG_ERROR("AlarmId = %s not found",alarmId);
        return;
    }
    switch (aInfo->GetAlarmSeverity())
    {
        case critical:
            send_dreCriticalNotification_trap(aInfo,alarmText);
            break;
        case major:
            send_dreMajorNotification_trap(aInfo,alarmText);
            break;
        case minor:
            send_dreMinorNotification_trap(aInfo,alarmText);
            break;
        case warning:
            send_dreWarningNotification_trap(aInfo,alarmText);
            break;
        case cleared:
            send_dreClearedNotification_trap(aInfo,alarmText);
            break;
        case info:
            send_dreInfoNotification_trap(aInfo,alarmText);
            break;
    }
}

void agent_terminate()
{
    netsnmp_running = 0;
}
